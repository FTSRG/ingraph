@Ecore(
	nsURI="http://ingraph/relalg"
)
@GenModel(
    bundleManifest="false",
    modelDirectory="ingraph-relalg-xcore/build/xcore/main",
    complianceLevel="8.0"
)
package relalg

class RelalgContainer {
	refers Operator rootExpression
	contains NamedElement[] elements opposite ^container
	contains Operator[] operators opposite ^container
	contains Expression[] expressions opposite ^container
}

abstract class NamedElement {
	String name
	refers RelalgContainer ^container opposite elements
}

abstract class Label extends NamedElement {}
class VertexLabel extends Label {}
class EdgeLabel extends Label {}

/* Variables */
abstract class Variable extends NamedElement, ReturnableElement, ComparableElement {
	boolean dontCare = "false"
}
class ElementVariable extends Variable {
	refers AttributeVariable[] attributes opposite element
}
class VertexVariable extends ElementVariable {
	refers VertexLabel[] vertexLabels // the vertex must have *all* of these labels
}
class EdgeVariable extends ElementVariable {
	refers EdgeLabel[] edgeLabels // the edge must have *one* of these labels
}
class AttributeVariable extends Variable {
	refers ElementVariable element opposite attributes
}

abstract class ReturnableElement {}


/* Operators */

abstract class Operator {
	refers RelalgContainer ^container opposite operators
	String description
	refers Variable[] schema
}

/* Nullary operators */

class GetVerticesOperator extends Operator {
	refers VertexVariable vertexVariable
}

// (sourceVertexVariable)-[edgeVariable]->(targetVertexVariable)
class GetEdgesOperator extends Operator {
	refers VertexVariable sourceVertexVariable
	refers EdgeVariable edgeVariable
	refers VertexVariable targetVertexVariable
}

/* Alpha operators */

abstract class AlphaOperator extends Operator {
	refers Operator input
}

class ProductionOperator extends AlphaOperator {}

class SelectionOperator extends AlphaOperator {
	String conditionString
	refers Expression condition
}

class ProjectionOperator extends AlphaOperator {
	refers Variable[] variables
}

class ExpandOperator extends AlphaOperator {
	Direction direction
	refers VertexVariable sourceVertexVariable
	refers EdgeVariable edgeVariable
	refers VertexVariable targetVertexVariable
}

class DuplicateEliminationOperator extends AlphaOperator {

}

class AllDifferentOperator extends AlphaOperator {
	refers EdgeVariable[] edgeVariables
}

/* Beta operators */

abstract class BetaOperator extends Operator {
	contains Operator leftInput
	contains Operator rightInput
}

abstract class AbstractJoinOperator extends BetaOperator {
	refers Variable[] mutualVariables
}

class JoinOperator extends AbstractJoinOperator {}

class AntiJoinOperator extends AbstractJoinOperator {}

class UnionOperator extends BetaOperator {}

/* expression */

abstract class Expression {
	refers RelalgContainer ^container opposite expressions
	String text
}

abstract class BinaryExpression extends Expression {}

class ArithmeticOperationExpression extends BinaryExpression {
	BinaryArithmeticOperator operator
}

class ArithmeticComparisonExpression extends BinaryExpression {
	ArithmeticComparisonOperator operator
	refers ComparableElement leftOperand
	refers ComparableElement rightOperand
}

abstract class ComparableElement {}

abstract class Atom extends Expression {}

abstract class Literal extends Atom, ComparableElement {}

class StringLiteral extends Literal {
	String value
}

abstract class NumberLiteral {}

class DoubleLiteral extends NumberLiteral {
	Double value
}

class IntegerLiteral extends NumberLiteral {
	Integer value
}

/* enums */

enum Direction {
	BOTH,
	IN,
	OUT
}

enum Order {
	ASCENDING,
	DESCENDING
}

enum BinaryArithmeticOperator {
	PLUS,
	MINUS,
	MULTIPLICATION,
	DIVISION,
	MOD,
	POWER
}

enum ArithmeticComparisonOperator {
	EQUAL_TO,
	NOT_EQUAL_TO,
	GREATER_THAN,
	GREATER_THAN_OR_EQUAL,
	LESS_THAN,
	LESS_THAN_OR_EQUAL
}

enum UnaryArithmeticOperator {
	MINUS,
	PLUS
}

enum BinaryLogicalOperator {
	AND,
	OR,
	XOR
}
