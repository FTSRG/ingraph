package ingraph.optimization.patterns

import "http://ingraph/relalg";

// [0] transformation for eliminating left outer joins on the Dual table
pattern unnecessaryLeftOuterJoin(leftInputOperator : Operator, dualOperator : DualObjectSourceOperator, leftOuterJoinOperator : LeftOuterJoinOperator, parentOperator : Operator) {
	find parentOperator(leftOuterJoinOperator, parentOperator);
	LeftOuterJoinOperator.leftInput(leftOuterJoinOperator, leftInputOperator);
	LeftOuterJoinOperator.rightInput(leftOuterJoinOperator, dualOperator);
}

/*
    parentOperator
          |
          | *input
          V
    expandOperator
          |
          | input
          V
  getVerticesOperator

*/
pattern defaultExpandOperator(expandOperator : ExpandOperator) {
  ExpandOperator.minHops(expandOperator, 1);
  ExpandOperator.maxHops(expandOperator, maxHops);
  MaxHops.maxHopsType(maxHops, ::LIMITED);
  MaxHops.hops(maxHops, 1);
}

// [1a] transformation for eliminating default expand operators connected to a getVerticesOperator
pattern expandVertex(getVerticesOperator : GetVerticesOperator, expandOperator : ExpandOperator, parentOperator : Operator) {
	find parentOperator(expandOperator, parentOperator);
	find defaultExpandOperator(expandOperator);
	ExpandOperator.input(expandOperator, getVerticesOperator);
	GetVerticesOperator(getVerticesOperator);
}

/*
    parentOperator
          |
          | *input
          V
    expandOperator
*/
// [2a] transformation for eliminating the remaining default expand operators
pattern expandOperatorA(expandOperator : ExpandOperator, parentOperator : Operator) {
	find parentOperator(expandOperator, parentOperator);
	find defaultExpandOperator(expandOperator);
}

// [2b] transformation for eliminating the remaining non-default expand operators
pattern expandOperatorB(expandOperator : ExpandOperator, parentOperator : Operator) {
  find parentOperator(expandOperator, parentOperator);
  neg find defaultExpandOperator(expandOperator);
}

pattern topAndProjectionOperator(topOperator : TopOperator, projectionOperator : ProjectionOperator, parentOperator : Operator) {
  find parentOperator(topOperator, parentOperator);
  TopOperator.input(topOperator, projectionOperator);
}

/*
    parentOperator
          |
          | *input
          V
     topOperator (skips/limits a given amount of tuples)
          |
          | input
          V
     sortOperator (orders the tuples according to some variables and asc/desc directions)
*/
// [3b] transformation for combining adjacent sort and top operators to a single sortAndTop operator
pattern sortAndTopOperator(sortOperator : SortOperator, topOperator : TopOperator, parentOperator : Operator) {
  find parentOperator(topOperator, parentOperator);
  TopOperator.input(topOperator, sortOperator);
}

/*
    parentOperator
          |
          | *input
          V
  projectionOperator
          |
          | input
          V
   groupingOperator
*/
// [4] transformation for combining adjacent grouping and projection operators to a single groupingAndProjection operator
pattern groupingAndProjectionOperator(projectionOperator : ProjectionOperator, groupingOperator : GroupingOperator, parentOperator : Operator) {
  find parentOperator(projectionOperator, parentOperator);
  ProjectionOperator.input(projectionOperator, groupingOperator);
}

/*
       parentOperator
            |
            | *input
            V
       selectionOperator.condition = NOT(...)
            |
            | *input
            V
     leftOuterJoinOperator
        |         |
       /           \
      /             \
     | leftInput     | rightInput
     V               V
   leftInputOp...  getEdgesOperator
*/
// [5] (run after [2])
// transformation for combining adjacent selection and leftOuterJoin operators to a single antijoin operator
pattern leftOuterJoinAndSelection(
  parentOperator : Operator,
  selectionOperator : SelectionOperator,
  leftOuterJoinOperator: LeftOuterJoinOperator,
  leftInputOperator: Operator,
  getEdgesOperator: GetEdgesOperator
) {
  find parentOperator(selectionOperator, parentOperator);
  SelectionOperator.input(selectionOperator, leftOuterJoinOperator);
  SelectionOperator.condition(selectionOperator, condition);
  UnaryLogicalExpression.operator(condition, ::NOT);
  UnaryLogicalExpression.operand(condition, conditionInternalExpression);
  
  find variablesInLogicalExpression(conditionInternalExpression);
  
  LeftOuterJoinOperator.leftInput(leftOuterJoinOperator, leftInputOperator);
  LeftOuterJoinOperator.rightInput(leftOuterJoinOperator, getEdgesOperator);
}

pattern variablesInLogicalExpression(expression : Expression) {
  BinaryLogicalExpression.operator(expression, ::AND);
  
  find leftDeepTreeNodes+(expression, expression2);
  
  BinaryLogicalExpression.rightOperand(expression2, notNull);
  UnaryGraphObjectLogicalExpression.operator(notNull, ::IS_NOT_NULL);
}

pattern leftDeepTreeNodes(parent : BinaryLogicalExpression, child : BinaryLogicalExpression) {
  BinaryLogicalExpression.leftOperand(parent, child);
  BinaryLogicalExpression(child);
}
