\chapter{Static Analysis for JavaScript}
\label{chp:static-analysis-javascript}

\section{BlockStatement}

\subsection*{Query specification}

\begin{lstlisting}
MATCH
  (bs:BlockStatement)-[:block]->(b:Block)-[:statements]->(list:List),

  (bs)    -[:`_end`]->  (bsE:End),
  (list)  -[:`_end`]->  (listE:End)

MERGE
  (bs)    -[:`_normal`]-> (list)    -[:`_end`]->
  (listE) -[:`_normal`]-> (bsE)
\end{lstlisting}

\subsection*{Relational algebra expression}

\begin{flalign*}
\alldifferent{} \Big(\expandout{b}{list}{List}{\_e833}{statements}{}{} \Big(\expandout{bs}{b}{Block}{\_e832}{block}{}{} \Big(\getvertices{bs}{BlockStatement}\Big)\Big) \join \expandout{bs}{bsE}{End}{\_e834}{\_end}{}{} \Big(\getvertices{bs}{BlockStatement}\Big) \join \expandout{list}{listE}{End}{\_e835}{\_end}{}{} \Big(\getvertices{list}{List}\Big)\Big)
\end{flalign*}

\subsection*{Relational algebra tree}
\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsection*{Relational algebra tree for incremental queries}
\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{b}{list}{List}{\_e841}{statements}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{bs}{b}{Block}{\_e840}{block}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{bs}{BlockStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{bs}{bsE}{End}{\_e842}{\_end}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{bs}{BlockStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{list}{listE}{End}{\_e843}{\_end}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{list}{List}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\section{Boolean}

\subsection*{Query specification}

\begin{lstlisting}
MATCH
  (lit:LiteralBooleanExpression),
  (ts:TypeSystem)-[:`_instance`]->(tag:Tag:`Boolean`)

MERGE
  (lit)-[:`_type`]->(tag)
\end{lstlisting}

\subsection*{Relational algebra expression}

\begin{flalign*}
\alldifferent{} \Big(\getvertices{lit}{LiteralBooleanExpression} \join \expandout{ts}{tag}{Tag \land Boolean}{\_e844}{\_instance}{}{} \Big(\getvertices{ts}{TypeSystem}\Big)\Big)
\end{flalign*}

\subsection*{Relational algebra tree}
\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsection*{Relational algebra tree for incremental queries}
\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{lit}{LiteralBooleanExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\expandout{ts}{tag}{Tag \land Boolean}{\_e846}{\_instance}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{ts}{TypeSystem}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\section{CallExpressionNoParam}

\subsection*{Query specification}

\begin{lstlisting}
MATCH
  (call:CallExpression)-[:callee]->(:IdentifierExpression)
  <-[:node]-(:Reference)<-[:references]-(:Variable)
  -[:declarations]->(:Declaration)-[:node]->(:BindingIdentifier)
  <-[:name]-(fd:FunctionDeclaration),

  (call)    -[:`_end`]->  (callE:End),
  (fd)      -[:`_end`]->  (fdE:End)

WHERE
  NOT (call)-[:arguments]->()

MERGE
  (call)    -[:`_normal`]-> (fd)      -[:`_end`]->
  (fdE)     -[:`_normal`]-> (callE)
\end{lstlisting}

\subsection*{Relational algebra expression}

\begin{flalign*}
\selection{\neg \left( \var{call} IS NOT NULL \land \var{_e860} IS NOT NULL \land \var{_e861} IS NOT NULL \right)} \Big(\alldifferent{} \Big(\expandin{\_e855}{fd}{FunctionDeclaration}{\_e857}{name}{}{} \Big(\expandout{\_e853}{\_e855}{BindingIdentifier}{\_e856}{node}{}{} \Big(\expandout{\_e851}{\_e853}{Declaration}{\_e854}{declarations}{}{} \Big(\expandin{\_e849}{\_e851}{Variable}{\_e852}{references}{}{} \Big(\expandin{\_e847}{\_e849}{Reference}{\_e850}{node}{}{} \Big(\expandout{call}{\_e847}{IdentifierExpression}{\_e848}{callee}{}{} \Big(\getvertices{call}{CallExpression}\Big)\Big)\Big)\Big)\Big)\Big) \join \expandout{call}{callE}{End}{\_e858}{\_end}{}{} \Big(\getvertices{call}{CallExpression}\Big) \join \expandout{fd}{fdE}{End}{\_e859}{\_end}{}{} \Big(\getvertices{fd}{FunctionDeclaration}\Big)\Big) \leftouterjoin \expandout{call}{\_e861}{}{\_e860}{arguments}{}{} \Big(\getvertices{call}{CallExpression}\Big)\Big)
\end{flalign*}

\subsection*{Relational algebra tree}
\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsection*{Relational algebra tree for incremental queries}
\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\selection{\neg \left( \var{call} IS NOT NULL \land \var{_e890} IS NOT NULL \land \var{_e891} IS NOT NULL \right)}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\leftouterjoin$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandin{\_e885}{fd}{FunctionDeclaration}{\_e887}{name}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e883}{\_e885}{BindingIdentifier}{\_e886}{node}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e881}{\_e883}{Declaration}{\_e884}{declarations}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandin{\_e879}{\_e881}{Variable}{\_e882}{references}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandin{\_e877}{\_e879}{Reference}{\_e880}{node}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{call}{\_e877}{IdentifierExpression}{\_e878}{callee}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{call}{CallExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
]
[
	{$\expandout{call}{callE}{End}{\_e888}{\_end}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{call}{CallExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{fd}{fdE}{End}{\_e889}{\_end}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{fd}{FunctionDeclaration}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
[
	{$\expandout{call}{\_e891}{}{\_e890}{arguments}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{call}{CallExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\section{CallExpressionParam}

\subsection*{Query specification}

\begin{lstlisting}
MATCH
  (arguments:List) <-[:arguments]- (callExp:CallExpression) -[:callee]->
  (:IdentifierExpression) <-[:`node`]- (:Reference) <-[:references]-
  (:Variable) -[:declarations]-> (:Declaration) -[:`node`]->
  (:BindingIdentifier) <-[:name]- (fd:FunctionDeclaration) -[:params]->
  (:FormalParameters) -[:items]-> (params:List),

  (callExp)     -[:`_end`]->  (callExpE:`End`),
  (fd)          -[:`_end`]->  (fdE:`End`),
  (arguments)   -[:`_end`]->  (argumentsE:`End`)

MERGE
  (callExp)     -[:`_normal`]-> (arguments) -[:`_end`]->
  (argumentsE)  -[:`_normal`]-> (fd)        -[:`_end`]->
  (fdE)         -[:`_normal`]-> (callExpE)

\end{lstlisting}

\subsection*{Relational algebra expression}

\begin{flalign*}
\alldifferent{} \Big(\expandout{\_e904}{params}{List}{\_e906}{items}{}{} \Big(\expandout{fd}{\_e904}{FormalParameters}{\_e905}{params}{}{} \Big(\expandin{\_e901}{fd}{FunctionDeclaration}{\_e903}{name}{}{} \Big(\expandout{\_e899}{\_e901}{BindingIdentifier}{\_e902}{node}{}{} \Big(\expandout{\_e897}{\_e899}{Declaration}{\_e900}{declarations}{}{} \Big(\expandin{\_e895}{\_e897}{Variable}{\_e898}{references}{}{} \Big(\expandin{\_e893}{\_e895}{Reference}{\_e896}{node}{}{} \Big(\expandout{callExp}{\_e893}{IdentifierExpression}{\_e894}{callee}{}{} \Big(\expandin{arguments}{callExp}{CallExpression}{\_e892}{arguments}{}{} \Big(\getvertices{arguments}{List}\Big)\Big)\Big)\Big)\Big)\Big)\Big)\Big)\Big) \join \expandout{callExp}{callExpE}{End}{\_e907}{\_end}{}{} \Big(\getvertices{callExp}{CallExpression}\Big) \join \expandout{fd}{fdE}{End}{\_e908}{\_end}{}{} \Big(\getvertices{fd}{FunctionDeclaration}\Big) \join \expandout{arguments}{argumentsE}{End}{\_e909}{\_end}{}{} \Big(\getvertices{arguments}{List}\Big)\Big)
\end{flalign*}

\subsection*{Relational algebra tree}
\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsection*{Relational algebra tree for incremental queries}
\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e940}{params}{List}{\_e942}{items}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{fd}{\_e940}{FormalParameters}{\_e941}{params}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandin{\_e937}{fd}{FunctionDeclaration}{\_e939}{name}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e935}{\_e937}{BindingIdentifier}{\_e938}{node}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e933}{\_e935}{Declaration}{\_e936}{declarations}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandin{\_e931}{\_e933}{Variable}{\_e934}{references}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandin{\_e929}{\_e931}{Reference}{\_e932}{node}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{callExp}{\_e929}{IdentifierExpression}{\_e930}{callee}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandin{arguments}{callExp}{CallExpression}{\_e928}{arguments}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{arguments}{List}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
]
]
]
]
[
	{$\expandout{callExp}{callExpE}{End}{\_e943}{\_end}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{callExp}{CallExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{fd}{fdE}{End}{\_e944}{\_end}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{fd}{FunctionDeclaration}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{arguments}{argumentsE}{End}{\_e945}{\_end}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{arguments}{List}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\section{ExpressionStatement}

\subsection*{Query specification}

\begin{lstlisting}
MATCH
  (es:ExpressionStatement)-[:expression]->(exp:Expression),

  (es)  -[:`_end`]->  (esE:End),
  (exp) -[:`_end`]->  (expE:End)

MERGE
  (es)    -[:`_normal`]-> (exp)   -[:`_end`]->
  (expE)  -[:`_normal`]-> (esE)
\end{lstlisting}

\subsection*{Relational algebra expression}

\begin{flalign*}
\alldifferent{} \Big(\expandout{es}{exp}{Expression}{\_e946}{expression}{}{} \Big(\getvertices{es}{ExpressionStatement}\Big) \join \expandout{es}{esE}{End}{\_e947}{\_end}{}{} \Big(\getvertices{es}{ExpressionStatement}\Big) \join \expandout{exp}{expE}{End}{\_e948}{\_end}{}{} \Big(\getvertices{exp}{Expression}\Big)\Big)
\end{flalign*}

\subsection*{Relational algebra tree}
\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsection*{Relational algebra tree for incremental queries}
\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{es}{exp}{Expression}{\_e952}{expression}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{es}{ExpressionStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\expandout{es}{esE}{End}{\_e953}{\_end}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{es}{ExpressionStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{exp}{expE}{End}{\_e954}{\_end}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{exp}{Expression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\section{FunctionDeclaration}

\subsection*{Query specification}

\begin{lstlisting}
MATCH
  (fd:FunctionDeclaration)-[:body]->(b:FunctionBody)-[:statements]->(list:List),

  (fd)    -[:`_end`]->  (fdE:End),
  (list)  -[:`_end`]->  (listE:End)

MERGE
  (fd)    -[:`_normal`]-> (list)    -[:`_end`]->
  (listE) -[:`_normal`]-> (fdE)
\end{lstlisting}

\subsection*{Relational algebra expression}

\begin{flalign*}
\alldifferent{} \Big(\expandout{b}{list}{List}{\_e956}{statements}{}{} \Big(\expandout{fd}{b}{FunctionBody}{\_e955}{body}{}{} \Big(\getvertices{fd}{FunctionDeclaration}\Big)\Big) \join \expandout{fd}{fdE}{End}{\_e957}{\_end}{}{} \Big(\getvertices{fd}{FunctionDeclaration}\Big) \join \expandout{list}{listE}{End}{\_e958}{\_end}{}{} \Big(\getvertices{list}{List}\Big)\Big)
\end{flalign*}

\subsection*{Relational algebra tree}
\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsection*{Relational algebra tree for incremental queries}
\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{b}{list}{List}{\_e964}{statements}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{fd}{b}{FunctionBody}{\_e963}{body}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{fd}{FunctionDeclaration}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{fd}{fdE}{End}{\_e965}{\_end}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{fd}{FunctionDeclaration}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{list}{listE}{End}{\_e966}{\_end}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{list}{List}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\section{IfStatementAlternate}

\subsection*{Query specification}

\begin{lstlisting}
MATCH
  (test:Node)<-[:test]-(if:IfStatement)-[:consequent]->(consequent:Node),
  (if)-[:alternate]->(alternate:Statement),

  (alternate)   -[:`_end`]->    (alternateE:End),

  (if)          -[:`_end`]->  (ifE:End),
  (test)        -[:`_end`]->  (testE:End),
  (consequent)  -[:`_end`]->  (consequentE:End)

MERGE
  (if)          -[:`_normal`]-> (test)        -[:`_end`]->
  (testE)       -[:`_true`]->   (consequent)  -[:`_end`]->
  (consequentE) -[:`_normal`]-> (ifE)

MERGE
  (testE)       -[:`_false`]->  (alternate)   -[:`_end`]->
  (alternateE)  -[:`_normal`]-> (ifE)
\end{lstlisting}

\subsection*{Relational algebra expression}

\begin{flalign*}
\alldifferent{} \Big(\expandout{if}{consequent}{Node}{\_e968}{consequent}{}{} \Big(\expandin{test}{if}{IfStatement}{\_e967}{test}{}{} \Big(\getvertices{test}{Node}\Big)\Big) \join \expandout{if}{alternate}{Statement}{\_e969}{alternate}{}{} \Big(\getvertices{if}{IfStatement}\Big) \join \expandout{alternate}{alternateE}{End}{\_e970}{\_end}{}{} \Big(\getvertices{alternate}{Statement}\Big) \join \expandout{if}{ifE}{End}{\_e971}{\_end}{}{} \Big(\getvertices{if}{IfStatement}\Big) \join \expandout{test}{testE}{End}{\_e972}{\_end}{}{} \Big(\getvertices{test}{Node}\Big) \join \expandout{consequent}{consequentE}{End}{\_e973}{\_end}{}{} \Big(\getvertices{consequent}{Node}\Big)\Big)
\end{flalign*}

\subsection*{Relational algebra tree}
\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsection*{Relational algebra tree for incremental queries}
\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{if}{consequent}{Node}{\_e982}{consequent}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandin{test}{if}{IfStatement}{\_e981}{test}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{test}{Node}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{if}{alternate}{Statement}{\_e983}{alternate}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{if}{IfStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{alternate}{alternateE}{End}{\_e984}{\_end}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{alternate}{Statement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{if}{ifE}{End}{\_e985}{\_end}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{if}{IfStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{test}{testE}{End}{\_e986}{\_end}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{test}{Node}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{consequent}{consequentE}{End}{\_e987}{\_end}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{consequent}{Node}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\section{IfStatementNoAlternate}

\subsection*{Query specification}

\begin{lstlisting}
MATCH
  (test:Node)<-[:test]-(if:IfStatement)-[:consequent]->(consequent:Node),

  (if)          -[:`_end`]->  (ifE:End),
  (test)        -[:`_end`]->  (testE:End),
  (consequent)  -[:`_end`]->  (consequentE:End)

WHERE
  NOT (if)-[:alternate]->(:Statement)

MERGE
  (if)	        -[:`_normal`]-> (test)       -[:`_end`]->
  (testE)       -[:`_true`]->   (consequent) -[:`_end`]->
  (consequentE)	-[:`_normal`]-> (ifE)
\end{lstlisting}

\subsection*{Relational algebra expression}

\begin{flalign*}
\selection{\neg \left( \var{if} IS NOT NULL \land \var{_e993} IS NOT NULL \land \var{_e994} IS NOT NULL \right)} \Big(\alldifferent{} \Big(\expandout{if}{consequent}{Node}{\_e989}{consequent}{}{} \Big(\expandin{test}{if}{IfStatement}{\_e988}{test}{}{} \Big(\getvertices{test}{Node}\Big)\Big) \join \expandout{if}{ifE}{End}{\_e990}{\_end}{}{} \Big(\getvertices{if}{IfStatement}\Big) \join \expandout{test}{testE}{End}{\_e991}{\_end}{}{} \Big(\getvertices{test}{Node}\Big) \join \expandout{consequent}{consequentE}{End}{\_e992}{\_end}{}{} \Big(\getvertices{consequent}{Node}\Big)\Big) \leftouterjoin \expandout{if}{\_e994}{Statement}{\_e993}{alternate}{}{} \Big(\getvertices{if}{IfStatement}\Big)\Big)
\end{flalign*}

\subsection*{Relational algebra tree}
\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsection*{Relational algebra tree for incremental queries}
\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\selection{\neg \left( \var{if} IS NOT NULL \land \var{_e1007} IS NOT NULL \land \var{_e1008} IS NOT NULL \right)}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\leftouterjoin$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{if}{consequent}{Node}{\_e1003}{consequent}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandin{test}{if}{IfStatement}{\_e1002}{test}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{test}{Node}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{if}{ifE}{End}{\_e1004}{\_end}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{if}{IfStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{test}{testE}{End}{\_e1005}{\_end}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{test}{Node}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{consequent}{consequentE}{End}{\_e1006}{\_end}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{consequent}{Node}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
[
	{$\expandout{if}{\_e1008}{Statement}{\_e1007}{alternate}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{if}{IfStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\section{Infinity}

\subsection*{Query specification}

\begin{lstlisting}
MATCH
  (lit:LiteralInfinityExpression),
  (ts:TypeSystem)-[:`_instance`]->(tag:Tag:`Infinity`)

MERGE
  (lit)-[:`_type`]->(tag)
\end{lstlisting}

\subsection*{Relational algebra expression}

\begin{flalign*}
\alldifferent{} \Big(\getvertices{lit}{LiteralInfinityExpression} \join \expandout{ts}{tag}{Tag \land Infinity}{\_e1009}{\_instance}{}{} \Big(\getvertices{ts}{TypeSystem}\Big)\Big)
\end{flalign*}

\subsection*{Relational algebra tree}
\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsection*{Relational algebra tree for incremental queries}
\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{lit}{LiteralInfinityExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\expandout{ts}{tag}{Tag \land Infinity}{\_e1011}{\_instance}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{ts}{TypeSystem}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\section{ListNoItem}

\subsection*{Query specification}

\begin{lstlisting}
MATCH
  (l:List),

  (l)     -[:`_end`]->  (lE:End)

WHERE
  NOT (l)-[:`0`]->()

MERGE
  (l)     -[:`_normal`]-> (lE)
\end{lstlisting}

\subsection*{Relational algebra expression}

\begin{flalign*}
\text{Cannot convert to expression.}
\end{flalign*}

\subsection*{Relational algebra tree}
\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsection*{Relational algebra tree for incremental queries}
\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\section{ListWithItem}

\subsection*{Query specification}

\begin{lstlisting}
MATCH
  (l:List)-[:`0`]->(first),
  (l)-[:last]->(last),

  (l)     -[:`_end`]->  (lE:End),
  (last)  -[:`_end`]->  (lastE:End)

MERGE (l)     -[:`_normal`]-> (first)
MERGE (lastE) -[:`_normal`]-> (lE)
\end{lstlisting}

\subsection*{Relational algebra expression}

\begin{flalign*}
\alldifferent{} \Big(\expandout{l}{first}{}{\_e1015}{\_e1016}{}{} \Big(\getvertices{l}{List}\Big) \join \expandout{l}{last}{}{\_e1017}{last}{}{} \Big(\getvertices{l}{List}\Big) \join \expandout{l}{lE}{End}{\_e1018}{\_end}{}{} \Big(\getvertices{l}{List}\Big) \join \expandout{last}{lastE}{End}{\_e1019}{\_end}{}{} \Big(\getvertices{last}{}\Big)\Big)
\end{flalign*}

\subsection*{Relational algebra tree}
\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsection*{Relational algebra tree for incremental queries}
\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{l}{first}{}{\_e1025}{\_e1026}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{l}{List}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\expandout{l}{last}{}{\_e1027}{last}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{l}{List}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{l}{lE}{End}{\_e1028}{\_end}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{l}{List}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{last}{lastE}{End}{\_e1029}{\_end}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{last}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\section{LiteralX}

\subsection*{Query specification}

\begin{lstlisting}
MATCH (le:Literal)  -[:`_end`]->  (leE:End)
MERGE (le)    -[:`_normal`]-> (leE)
\end{lstlisting}

\subsection*{Relational algebra expression}

\begin{flalign*}
\alldifferent{} \Big(\expandout{le}{leE}{End}{\_e1030}{\_end}{}{} \Big(\getvertices{le}{Literal}\Big)\Big)
\end{flalign*}

\subsection*{Relational algebra tree}
\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsection*{Relational algebra tree for incremental queries}
\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{le}{leE}{End}{\_e1032}{\_end}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{le}{Literal}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\section{LogicalOr}

\subsection*{Query specification}

\begin{lstlisting}
MATCH
  (ltag:Tag)<-[:`_type`]-(left:Expression)
  <-[:left]-(exp:BinaryExpression)-[:right]->
  (right:Expression)-[:`_type`]->(rtag:Tag),

  (ts:TypeSystem)-[:`_instance`]->(btag:Tag:`Boolean`)

WHERE
  exp.operator = 'LogicalOr'

MERGE (exp)-[:`_type`]->(rtag)
MERGE (exp)-[:`_type`]->(ltag)
MERGE (exp)-[:`_type`]->(btag)
\end{lstlisting}

\subsection*{Relational algebra expression}

\begin{flalign*}
\selection{\var{exp.operator} = \literal{''LogicalOr''}} \Big(\alldifferent{} \Big(\expandout{right}{rtag}{Tag}{\_e1036}{\_type}{}{} \Big(\expandout{exp}{right}{Expression}{\_e1035}{right}{}{} \Big(\expandin{left}{exp}{BinaryExpression}{\_e1034}{left}{}{} \Big(\expandin{ltag}{left}{Expression}{\_e1033}{\_type}{}{} \Big(\getvertices{ltag}{Tag}\Big)\Big)\Big)\Big) \join \expandout{ts}{btag}{Tag \land Boolean}{\_e1037}{\_instance}{}{} \Big(\getvertices{ts}{TypeSystem}\Big)\Big)\Big)
\end{flalign*}

\subsection*{Relational algebra tree}
\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsection*{Relational algebra tree for incremental queries}
\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\selection{\var{exp.operator} = \literal{''LogicalOr''}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{right}{rtag}{Tag}{\_e1046}{\_type}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{exp}{right}{Expression}{\_e1045}{right}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandin{left}{exp}{BinaryExpression}{\_e1044}{left}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandin{ltag}{left}{Expression}{\_e1043}{\_type}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{ltag}{Tag}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
[
	{$\expandout{ts}{btag}{Tag \land Boolean}{\_e1047}{\_instance}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{ts}{TypeSystem}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\section{Null}

\subsection*{Query specification}

\begin{lstlisting}
MATCH
  (lit:LiteralNullExpression),
  (ts:TypeSystem)-[:`_instance`]->(tag:Tag:`Null`)

MERGE
  (lit)-[:`_type`]->(tag)
\end{lstlisting}

\subsection*{Relational algebra expression}

\begin{flalign*}
\alldifferent{} \Big(\getvertices{lit}{LiteralNullExpression} \join \expandout{ts}{tag}{Tag \land Null}{\_e1048}{\_instance}{}{} \Big(\getvertices{ts}{TypeSystem}\Big)\Big)
\end{flalign*}

\subsection*{Relational algebra tree}
\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsection*{Relational algebra tree for incremental queries}
\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{lit}{LiteralNullExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\expandout{ts}{tag}{Tag \land Null}{\_e1050}{\_instance}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{ts}{TypeSystem}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\section{Numeric}

\subsection*{Query specification}

\begin{lstlisting}
MATCH
  (lit:LiteralNumericExpression),
  (ts:TypeSystem)-[:`_instance`]->(tag:Tag:`Number`)

MERGE
  (lit)-[:`_type`]->(tag)
\end{lstlisting}

\subsection*{Relational algebra expression}

\begin{flalign*}
\alldifferent{} \Big(\getvertices{lit}{LiteralNumericExpression} \join \expandout{ts}{tag}{Tag \land Number}{\_e1051}{\_instance}{}{} \Big(\getvertices{ts}{TypeSystem}\Big)\Big)
\end{flalign*}

\subsection*{Relational algebra tree}
\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsection*{Relational algebra tree for incremental queries}
\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{lit}{LiteralNumericExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\expandout{ts}{tag}{Tag \land Number}{\_e1053}{\_instance}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{ts}{TypeSystem}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\section{Read}

\subsection*{Query specification}

\begin{lstlisting}
MATCH
  (v:Variable)-[:references]->(r:Reference)-[:node]->(ide:IdentifierExpression),
  (v)-[:`_type`]->(tag:Tag)

MERGE
  (ide)-[:`_type`]->(tag)
\end{lstlisting}

\subsection*{Relational algebra expression}

\begin{flalign*}
\alldifferent{} \Big(\expandout{r}{ide}{IdentifierExpression}{\_e1055}{node}{}{} \Big(\expandout{v}{r}{Reference}{\_e1054}{references}{}{} \Big(\getvertices{v}{Variable}\Big)\Big) \join \expandout{v}{tag}{Tag}{\_e1056}{\_type}{}{} \Big(\getvertices{v}{Variable}\Big)\Big)
\end{flalign*}

\subsection*{Relational algebra tree}
\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsection*{Relational algebra tree for incremental queries}
\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{r}{ide}{IdentifierExpression}{\_e1061}{node}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{v}{r}{Reference}{\_e1060}{references}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{v}{Variable}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{v}{tag}{Tag}{\_e1062}{\_type}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{v}{Variable}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\section{RegExp}

\subsection*{Query specification}

\begin{lstlisting}
MATCH
  (lit:LiteralRegExpExpression),
  (ts:TypeSystem)-[:`_instance`]->(tag:Tag:`RegExp`)

MERGE
  (lit)-[:`_type`]->(tag)
\end{lstlisting}

\subsection*{Relational algebra expression}

\begin{flalign*}
\alldifferent{} \Big(\getvertices{lit}{LiteralRegExpExpression} \join \expandout{ts}{tag}{Tag \land RegExp}{\_e1063}{\_instance}{}{} \Big(\getvertices{ts}{TypeSystem}\Big)\Big)
\end{flalign*}

\subsection*{Relational algebra tree}
\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsection*{Relational algebra tree for incremental queries}
\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{lit}{LiteralRegExpExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\expandout{ts}{tag}{Tag \land RegExp}{\_e1065}{\_instance}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{ts}{TypeSystem}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\section{String}

\subsection*{Query specification}

\begin{lstlisting}
MATCH
  (lit:LiteralStringExpression),
  (ts:TypeSystem)-[:`_instance`]->(tag:Tag:`String`)

MERGE
  (lit)-[:`_type`]->(tag)
\end{lstlisting}

\subsection*{Relational algebra expression}

\begin{flalign*}
\alldifferent{} \Big(\getvertices{lit}{LiteralStringExpression} \join \expandout{ts}{tag}{Tag \land String}{\_e1066}{\_instance}{}{} \Big(\getvertices{ts}{TypeSystem}\Big)\Big)
\end{flalign*}

\subsection*{Relational algebra tree}
\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsection*{Relational algebra tree for incremental queries}
\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{lit}{LiteralStringExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\expandout{ts}{tag}{Tag \land String}{\_e1068}{\_instance}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{ts}{TypeSystem}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\section{TypeSystem}

\subsection*{Query specification}

\begin{lstlisting}
MERGE (ts:TypeSystem)

MERGE (ts)-[:`_instance`]->(:Tag:`Undefined`)
MERGE (ts)-[:`_instance`]->(:Tag:`Null`)
MERGE (ts)-[:`_instance`]->(:Tag:`Boolean`)
MERGE (ts)-[:`_instance`]->(:Tag:`Number`)
MERGE (ts)-[:`_instance`]->(:Tag:`String:`)
MERGE (ts)-[:`_instance`]->(:Tag:`Symbol`)
MERGE (ts)-[:`_instance`]->(:Tag:`Object`)
MERGE (ts)-[:`_instance`]->(:Tag:`Function`)
MERGE (ts)-[:`_instance`]->(:Tag:`Error`)

MERGE (ts)-[:`_instance`]->(:Tag:`Math`)
MERGE (ts)-[:`_instance`]->(:Tag:`Date`)
MERGE (ts)-[:`_instance`]->(:Tag:`RegExp`)
MERGE (ts)-[:`_instance`]->(:Tag:`Array`)
MERGE (ts)-[:`_instance`]->(:Tag:`Map`)
MERGE (ts)-[:`_instance`]->(:Tag:`Set`)
MERGE (ts)-[:`_instance`]->(:Tag:`JSON`)
MERGE (ts)-[:`_instance`]->(:Tag:`ArrayBuffer`)
MERGE (ts)-[:`_instance`]->(:Tag:`DataView`)
MERGE (ts)-[:`_instance`]->(:Tag:`Promise`)
MERGE (ts)-[:`_instance`]->(:Tag:`Proxy`)
MERGE (ts)-[:`_instance`]->(:Tag:`Reflect`)


MERGE (ts)-[:`_instance`]->(:Tag:`Infinity`)
\end{lstlisting}

\subsection*{Relational algebra expression}

\begin{flalign*}
\text{Cannot convert to expression.}
\end{flalign*}

\subsection*{Relational algebra tree}
\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsection*{Relational algebra tree for incremental queries}
\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\section{VariableDeclarationStatement}

\subsection*{Query specification}

\begin{lstlisting}
MATCH
  (vds:VariableDeclarationStatement)-[:declaration]->(vdion:VariableDeclaration)
  -[:declarators]->(vdor:VariableDeclarator)-[:init]->(exp:Expression),

  (vds)     -[:`_end`]->  (vdsE:End),
  (vdion)   -[:`_end`]->  (vdionE:End),
  (exp)     -[:`_end`]->  (expE:End)

MERGE (vdion)   -[:`_normal`]-> (vdionE)

MERGE
  (vds)     -[:`_normal`]-> (exp)   -[:`_end`]->
  (expE)    -[:`_normal`]-> (vdion) -[:`_end`]->
  (vdionE)  -[:`_normal`]-> (vdsE)
\end{lstlisting}

\subsection*{Relational algebra expression}

\begin{flalign*}
\alldifferent{} \Big(\expandout{vdor}{exp}{Expression}{\_e1071}{init}{}{} \Big(\expandout{vdion}{vdor}{VariableDeclarator}{\_e1070}{declarators}{}{} \Big(\expandout{vds}{vdion}{VariableDeclaration}{\_e1069}{declaration}{}{} \Big(\getvertices{vds}{VariableDeclarationStatement}\Big)\Big)\Big) \join \expandout{vds}{vdsE}{End}{\_e1072}{\_end}{}{} \Big(\getvertices{vds}{VariableDeclarationStatement}\Big) \join \expandout{vdion}{vdionE}{End}{\_e1073}{\_end}{}{} \Big(\getvertices{vdion}{VariableDeclaration}\Big) \join \expandout{exp}{expE}{End}{\_e1074}{\_end}{}{} \Big(\getvertices{exp}{Expression}\Big)\Big)
\end{flalign*}

\subsection*{Relational algebra tree}
\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsection*{Relational algebra tree for incremental queries}
\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{vdor}{exp}{Expression}{\_e1083}{init}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{vdion}{vdor}{VariableDeclarator}{\_e1082}{declarators}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{vds}{vdion}{VariableDeclaration}{\_e1081}{declaration}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{vds}{VariableDeclarationStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
[
	{$\expandout{vds}{vdsE}{End}{\_e1084}{\_end}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{vds}{VariableDeclarationStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{vdion}{vdionE}{End}{\_e1085}{\_end}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{vdion}{VariableDeclaration}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{exp}{expE}{End}{\_e1086}{\_end}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{exp}{Expression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\section{VariableDeclarator}

\subsection*{Query specification}

\begin{lstlisting}
MATCH
  (bi:BindingIdentifier)<-[:binding]-
    (vd:VariableDeclarator)
      -[:init]->(exp:Expression),

  (exp)-[:`_type`]->(tag:Tag)

MERGE
  (bi)-[:`_type`]->(tag)
\end{lstlisting}

\subsection*{Relational algebra expression}

\begin{flalign*}
\alldifferent{} \Big(\expandout{vd}{exp}{Expression}{\_e1088}{init}{}{} \Big(\expandin{bi}{vd}{VariableDeclarator}{\_e1087}{binding}{}{} \Big(\getvertices{bi}{BindingIdentifier}\Big)\Big) \join \expandout{exp}{tag}{Tag}{\_e1089}{\_type}{}{} \Big(\getvertices{exp}{Expression}\Big)\Big)
\end{flalign*}

\subsection*{Relational algebra tree}
\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsection*{Relational algebra tree for incremental queries}
\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{vd}{exp}{Expression}{\_e1094}{init}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandin{bi}{vd}{VariableDeclarator}{\_e1093}{binding}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{bi}{BindingIdentifier}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{exp}{tag}{Tag}{\_e1095}{\_type}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{exp}{Expression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\section{Write}

\subsection*{Query specification}

\begin{lstlisting}
MATCH
  (v:Variable)-[:references]->(r:Reference)-[:node]->(bid:BindingIdentifier),
  (bid)-[:`_type`]->(tag:Tag)

MERGE
  (v)-[:`_type`]->(tag)
\end{lstlisting}

\subsection*{Relational algebra expression}

\begin{flalign*}
\alldifferent{} \Big(\expandout{r}{bid}{BindingIdentifier}{\_e1097}{node}{}{} \Big(\expandout{v}{r}{Reference}{\_e1096}{references}{}{} \Big(\getvertices{v}{Variable}\Big)\Big) \join \expandout{bid}{tag}{Tag}{\_e1098}{\_type}{}{} \Big(\getvertices{bid}{BindingIdentifier}\Big)\Big)
\end{flalign*}

\subsection*{Relational algebra tree}
\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsection*{Relational algebra tree for incremental queries}
\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{r}{bid}{BindingIdentifier}{\_e1103}{node}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{v}{r}{Reference}{\_e1102}{references}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{v}{Variable}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{bid}{tag}{Tag}{\_e1104}{\_type}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{bid}{BindingIdentifier}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\section{generatecalls}

\subsection*{Query specification}

\begin{lstlisting}
MATCH
    // Match called FunctionDeclarations for every CallExpression
    (call:CallExpression)-[:callee]->(:IdentifierExpression)
    <-[:node]-(:Reference)<-[:references]-(:Variable)
    -[:declarations]->(:Declaration)-[:node]->(:BindingIdentifier)
    <-[:name]-(fd:FunctionDeclaration)
MATCH
    // List every call from a function body
    (fun:FunctionDeclaration), (call:CallExpression),
    p = shortestPath((fun)-[*]->(call))

MERGE
    // Create a calls relationship between the caller
    // FunctionDeclaration and the called FunctionDeclaration
    (fun)-[:calls]->(fd)
\end{lstlisting}

\subsection*{Relational algebra expression}

\begin{flalign*}
\text{Cannot convert to expression.}
\end{flalign*}

\subsection*{Relational algebra tree}
\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsection*{Relational algebra tree for incremental queries}
\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\section{getlastcommithash}

\subsection*{Query specification}

\begin{lstlisting}
MATCH (:MetaInfo)-[:lastCommit]->(c:Commit)
RETURN c.hash as commitHash
\end{lstlisting}

\subsection*{Relational algebra expression}

\begin{flalign*}
\projection{\var{c.hash}} \Big(\alldifferent{} \Big(\expandout{\_e1138}{c}{Commit}{\_e1139}{lastCommit}{}{} \Big(\getvertices{\_e1138}{MetaInfo}\Big)\Big)\Big)
\end{flalign*}

\subsection*{Relational algebra tree}
\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsection*{Relational algebra tree for incremental queries}
\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.hash}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e1142}{c}{Commit}{\_e1143}{lastCommit}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{\_e1142}{MetaInfo}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\section{removefile}

\subsection*{Query specification}

\begin{lstlisting}
MATCH
	( cu:CompilationUnit
		{
			path: {path}
		}
	)-[:contains]-(el)
WHERE
  // iff the provided sessionid parameter is NULL, then delete the fix graph of
  // the CompilationUnit; else delete the temporal one with the given sessionid
     ( {sessionid} IS NULL AND NOT exists(cu.sessionid) )
  OR ( cu.sessionid = {sessionid} )
DETACH DELETE
	cu, el
\end{lstlisting}

\subsection*{Relational algebra expression}

\begin{flalign*}
\text{Cannot convert to expression.}
\end{flalign*}

\subsection*{Relational algebra tree}
\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsection*{Relational algebra tree for incremental queries}
\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\section{setcommithash}

\subsection*{Query specification}

\begin{lstlisting}
MERGE (:MetaInfo)-[:lastCommit]->(c:Commit)
SET c.hash = {commithash}
\end{lstlisting}

\subsection*{Relational algebra expression}

\begin{flalign*}
\text{Cannot convert to expression.}
\end{flalign*}

\subsection*{Relational algebra tree}
\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsection*{Relational algebra tree for incremental queries}
\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\section{typing}

\subsection*{Query specification}

\begin{lstlisting}
/**
 * Type inferencing
 *
 * Repeat the following steps until either no change occurs in the database or a
 * given repeat limit is reached.
 *
 *  1. Find the literal values and assign type tags to them.
 *  2. Propagate the type information to the Variables in the given Scope for
 *     every VariableDeclaration with initial value. Handle the corner cases.
 *  3. Handle built-in Unary and Binary Expressions.
 *  4. Propagate type information into function calls taking care of in-function
 *     type differentiation based on input types.
 */

/**
 *  1. Find the literal values and assign type tags to them.
 *     - LiteralNumericExpression -> NumberTag
 *     - LiteralStringExpression  -> StringTag
 *     - LiteralBooleanExpression -> BooleanTag
 *     - LiteralNullExpression    -> NullTag
 */

// LiteralNumericExpression -> NumberTag
MATCH (exp:LiteralNumericExpression)
MERGE (exp)-[:type]->(tag:Tag:NumberTag)
SET tag.session = exp.session
;

// LiteralStringExpression  -> StringTag
MATCH (exp:LiteralStringExpression)
MERGE (exp)-[:type]->(tag:Tag:StringTag)
SET tag.session = exp.session
;

// LiteralBooleanExpression -> BooleanTag
MATCH (exp:LiteralBooleanExpression)
MERGE (exp)-[:type]->(tag:Tag:BooleanTag)
SET tag.session = exp.session
;

// LiteralNullExpression    -> NullTag
MATCH (exp:LiteralNullExpression)
MERGE (exp)-[:type]->(tag:Tag:NullTag)
SET tag.session = exp.session
;

/**
 *  2. Propagate the type information to Variables from their VariableDeclaration.
 */

MATCH
    //(vds:VariableDeclarationStatement)-[:declaration]->
    //(vdion:VariableDeclaration)-[declarators]->(vdor)
    (var:Variable)-[:declarations]->
    (dec:Declaration)-[:node]->
    (bi:BindingIdentifier)<-[:binding]-
    (vdor:VariableDeclarator)-[:init]->
    (exp:Expression)-[:type]->
    (type:Tag)
//MERGE
//    (var)-[:type]->(tag:Tag)
//CALL apoc.create.addLabels(tag, labels(type))
WHERE
    NOT (var)-[:type]-(:Tag)-[:from]->(type)
CALL
    apoc.refactor.cloneNodes([type]) YIELD input, output as tag, error
MERGE
    (var)-[:type]->(tag)-[:from]->(type)
//MERGE
//    (tag)-[:from]->(type)
MERGE
    (tag)-[:through]->(vdor)
;


/**
 * Find the VariableDeclarators without initial value and mark them as
 * undefined.
 */

 MATCH
     (var:Variable)-[:declarations]->
     (dec:Declaration)-[:node]->
     (bi:BindingIdentifier)<-[:binding]-
     (vdor:VariableDeclarator)
 WHERE
     NOT (vdor)-[:init]->(:Expression)
 MERGE
     (var)-[:type]->(tag:Tag:UndefinedTag)
 SET
     tag.session = var.session
 MERGE
     (tag)-[:through]->(vdor)
 ;

/**
 * Find ArrayExpressions and tag them.
 */
 // TODO

/**
 * Find ObjectExpressions and tag them.
 */
 // TODO


/**
 *  3. Handle built-in Unary and Binary Expressions.
 */

/**
 * Propagate the Variable type information to the appropriate
 * IdentifierExpression.
 */

MATCH
    (type:Tag)<-[:type]-
    (var:Variable)-[:references]->
    (ref:Reference)-[:node]->
    (exp:Expression)
WHERE
    NOT (exp)-[:type]-(:Tag)-[:from]->(type)
CALL
    apoc.refactor.cloneNodes([type]) YIELD input, output as tag, error
MERGE
    (exp)-[:type]->(tag)-[:from]->(type)
;

/**
 * PLUS binary operator.
 */
MATCH
    (ltag:Tag)<-[:type]-(left:Expression)
    <-[:left]-(exp:BinaryExpression)-[:right]->
    (right:Expression)-[:type]->(rtag:Tag)
WHERE
        exp.operator = 'Plus'
    AND ltag :NumberTag
    AND rtag :NumberTag
MERGE
    (exp)-[:type]->(tag:Tag:NumberTag)
MERGE
    (ltag)<-[:from]-(tag)-[:from]->(rtag)
SET
    tag.session = ltag.session
;
\end{lstlisting}

\subsection*{Relational algebra expression}

\begin{flalign*}
\alldifferent{} \Big(\getvertices{exp}{LiteralNumericExpression}\Big)
\end{flalign*}

\subsection*{Relational algebra tree}
\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsection*{Relational algebra tree for incremental queries}
\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{exp}{LiteralNumericExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
;
\end{forest}
}

\section{unusedfunctions}

\subsection*{Query specification}

\begin{lstlisting}
/**
 * Get not used FunctionDeclarations
 */
MATCH
    // Find the exported FunctionDeclaration that may be an entrance point
    p = (main)-[:items]->(:ExportDeclaration)-[:declaration]->(fd:FunctionDeclaration)

MATCH
    // Find every FunctionDeclaration that should be available through the
    // entrance points
    q = (dead:FunctionDeclaration)-[:location]->(span:SourceSpan),
        (start:SourceLocation)<-[:start]-(span)-[:end]->(end:SourceLocation)

WHERE
    // List the ones that are not available (Kleene closure) from the
    // entrance nodes (thus are not the entrance nodes "<>").
        ( NOT (fd)-[:calls*]->(dead) )
    AND ( dead <> fd )
    AND ( main:Script OR main:Module )
    AND ( ALL (
                x in (nodes(p) + nodes(q))
                WHERE NOT exists(x.session) OR x.session = {sessionid}
          ) )

RETURN DISTINCT
    ID(dead) as id, start.line, start.column, end.line, end.column, dead.session
\end{lstlisting}

\subsection*{Relational algebra expression}

\begin{flalign*}
\text{Cannot convert to expression.}
\end{flalign*}

\subsection*{Relational algebra tree}
\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsection*{Relational algebra tree for incremental queries}
\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

