\chapter{Static Analysis for JavaScript}
\label{chp:static-analysis-javascript}

\section{Queries}

\subsection{BlockStatement}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (bs:BlockStatement)-[:block]->(b:Block)-[:statements]->(list:List),

  (bs)    -[:`_end`]->  (bsE:End),
  (list)  -[:`_end`]->  (listE:End)

MERGE
  (bs)    -[:`_normal`]-> (list)    -[:`_end`]->
  (listE) -[:`_normal`]-> (bsE)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\alldifferent{} \Big(\expandout{b}{list}{List}{\_e2}{statements}{1}{1} \Big(\expandout{bs}{b}{Block}{\_e1}{block}{1}{1} \Big(\getvertices{bs}{BlockStatement}
\Big)
\Big)
 \join \expandout{bs}{bsE}{End}{\_e3}{\_end}{1}{1} \Big(\getvertices{bs}{BlockStatement}
\Big)
 \join \expandout{list}{listE}{End}{\_e4}{\_end}{1}{1} \Big(\getvertices{list}{List}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bs, \_e1, b, \_e2, list, \_e3, bsE, \_e4, listE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{bs, \_e1, b, \_e2, list, \_e3, bsE, \_e4, listE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{bs, \_e1, b, \_e2, list, \_e3, bsE} \rangle$
			}
[
	{$\expandout{b}{list}{List}{\_e2}{statements}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bs, \_e1, b, \_e2, list} \rangle$
			}
[
	{$\expandout{bs}{b}{Block}{\_e1}{block}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bs, \_e1, b} \rangle$
			}
[
	{$\getvertices{bs}{BlockStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bs} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{bs}{bsE}{End}{\_e3}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bs, \_e3, bsE} \rangle$
			}
[
	{$\getvertices{bs}{BlockStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bs} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{list}{listE}{End}{\_e4}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{list, \_e4, listE} \rangle$
			}
[
	{$\getvertices{list}{List}$
			\\
			\footnotesize
			$\color{gray} \langle \var{list} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bs, \_e1, b, \_e2, list, \_e3, bsE, \_e4, listE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{bs, \_e1, b, \_e2, list, \_e3, bsE, \_e4, listE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{bs, \_e1, b, \_e2, list, \_e3, bsE} \rangle$
			}
[
	{$\expandout{b}{list}{List}{\_e2}{statements}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bs, \_e1, b, \_e2, list} \rangle$
			}
[
	{$\expandout{bs}{b}{Block}{\_e1}{block}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bs, \_e1, b} \rangle$
			}
[
	{$\getvertices{bs}{BlockStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bs} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{bs}{bsE}{End}{\_e3}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bs, \_e3, bsE} \rangle$
			}
[
	{$\getvertices{bs}{BlockStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bs} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{list}{listE}{End}{\_e4}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{list, \_e4, listE} \rangle$
			}
[
	{$\getvertices{list}{List}$
			\\
			\footnotesize
			$\color{gray} \langle \var{list} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}
\subsection{Boolean}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (lit:LiteralBooleanExpression),
  (ts:TypeSystem)-[:`_instance`]->(tag:Tag:`Boolean`)

MERGE
  (lit)-[:`_type`]->(tag)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\alldifferent{} \Big(\getvertices{lit}{LiteralBooleanExpression}
 \join \expandout{ts}{tag}{Tag \land Boolean}{\_e5}{\_instance}{1}{1} \Big(\getvertices{ts}{TypeSystem}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e5, tag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e5, tag} \rangle$
			}
[
	{$\getvertices{lit}{LiteralBooleanExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\expandout{ts}{tag}{Tag \land Boolean}{\_e5}{\_instance}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts, \_e5, tag} \rangle$
			}
[
	{$\getvertices{ts}{TypeSystem}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e5, tag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e5, tag} \rangle$
			}
[
	{$\getvertices{lit}{LiteralBooleanExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\expandout{ts}{tag}{Tag \land Boolean}{\_e5}{\_instance}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts, \_e5, tag} \rangle$
			}
[
	{$\getvertices{ts}{TypeSystem}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}
\subsection{CallExpressionNoParam}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (call:CallExpression)-[:callee]->(:IdentifierExpression)
  <-[:node]-(:Reference)<-[:references]-(:Variable)
  -[:declarations]->(:Declaration)-[:node]->(:BindingIdentifier)
  <-[:name]-(fd:FunctionDeclaration),

  (call)    -[:`_end`]->  (callE:End),
  (fd)      -[:`_end`]->  (fdE:End)

WHERE
  NOT (call)-[:arguments]->()

MERGE
  (call)    -[:`_normal`]-> (fd)      -[:`_end`]->
  (fdE)     -[:`_normal`]-> (callE)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\selection{\neg \left( \var{call} IS NOT NULL \land \var{\_e19} IS NOT NULL \land \var{\_e20} IS NOT NULL \right)} \Big(\alldifferent{} \Big(\expandin{\_e14}{fd}{FunctionDeclaration}{\_e16}{name}{1}{1} \Big(\expandout{\_e12}{\_e14}{BindingIdentifier}{\_e15}{node}{1}{1} \Big(\expandout{\_e10}{\_e12}{Declaration}{\_e13}{declarations}{1}{1} \Big(\expandin{\_e8}{\_e10}{Variable}{\_e11}{references}{1}{1} \Big(\expandin{\_e6}{\_e8}{Reference}{\_e9}{node}{1}{1} \Big(\expandout{call}{\_e6}{IdentifierExpression}{\_e7}{callee}{1}{1} \Big(\getvertices{call}{CallExpression}
\Big)
\Big)
\Big)
\Big)
\Big)
\Big)
 \join \expandout{call}{callE}{End}{\_e17}{\_end}{1}{1} \Big(\getvertices{call}{CallExpression}
\Big)
 \join \expandout{fd}{fdE}{End}{\_e18}{\_end}{1}{1} \Big(\getvertices{fd}{FunctionDeclaration}
\Big)
\Big)
 \leftouterjoin \expandout{call}{\_e20}{}{\_e19}{arguments}{1}{1} \Big(\getvertices{call}{CallExpression}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\selection{\neg \left( \var{call} IS NOT NULL \land \var{\_e19} IS NOT NULL \land \var{\_e20} IS NOT NULL \right)}$
			\\
			\footnotesize
			$\color{gray} \langle \var{call, \_e7, \_e6, \_e9, \_e8, \_e11, \_e10, \_e13, \_e12, \_e15, \_e14, \_e16, fd, \_e17, callE, \_e18, fdE, \_e19, \_e20} \rangle$
			}
[
	{$\leftouterjoin$
			\\
			\footnotesize
			$\color{gray} \langle \var{call, \_e7, \_e6, \_e9, \_e8, \_e11, \_e10, \_e13, \_e12, \_e15, \_e14, \_e16, fd, \_e17, callE, \_e18, fdE, \_e19, \_e20} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{call, \_e7, \_e6, \_e9, \_e8, \_e11, \_e10, \_e13, \_e12, \_e15, \_e14, \_e16, fd, \_e17, callE, \_e18, fdE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{call, \_e7, \_e6, \_e9, \_e8, \_e11, \_e10, \_e13, \_e12, \_e15, \_e14, \_e16, fd, \_e17, callE, \_e18, fdE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{call, \_e7, \_e6, \_e9, \_e8, \_e11, \_e10, \_e13, \_e12, \_e15, \_e14, \_e16, fd, \_e17, callE} \rangle$
			}
[
	{$\expandin{\_e14}{fd}{FunctionDeclaration}{\_e16}{name}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{call, \_e7, \_e6, \_e9, \_e8, \_e11, \_e10, \_e13, \_e12, \_e15, \_e14, \_e16, fd} \rangle$
			}
[
	{$\expandout{\_e12}{\_e14}{BindingIdentifier}{\_e15}{node}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{call, \_e7, \_e6, \_e9, \_e8, \_e11, \_e10, \_e13, \_e12, \_e15, \_e14} \rangle$
			}
[
	{$\expandout{\_e10}{\_e12}{Declaration}{\_e13}{declarations}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{call, \_e7, \_e6, \_e9, \_e8, \_e11, \_e10, \_e13, \_e12} \rangle$
			}
[
	{$\expandin{\_e8}{\_e10}{Variable}{\_e11}{references}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{call, \_e7, \_e6, \_e9, \_e8, \_e11, \_e10} \rangle$
			}
[
	{$\expandin{\_e6}{\_e8}{Reference}{\_e9}{node}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{call, \_e7, \_e6, \_e9, \_e8} \rangle$
			}
[
	{$\expandout{call}{\_e6}{IdentifierExpression}{\_e7}{callee}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{call, \_e7, \_e6} \rangle$
			}
[
	{$\getvertices{call}{CallExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{call} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
]
[
	{$\expandout{call}{callE}{End}{\_e17}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{call, \_e17, callE} \rangle$
			}
[
	{$\getvertices{call}{CallExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{call} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{fd}{fdE}{End}{\_e18}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd, \_e18, fdE} \rangle$
			}
[
	{$\getvertices{fd}{FunctionDeclaration}$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
[
	{$\expandout{call}{\_e20}{}{\_e19}{arguments}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{call, \_e19, \_e20} \rangle$
			}
[
	{$\getvertices{call}{CallExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{call} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\selection{\neg \left( \var{call} IS NOT NULL \land \var{\_e19} IS NOT NULL \land \var{\_e20} IS NOT NULL \right)}$
			\\
			\footnotesize
			$\color{gray} \langle \var{call, \_e7, \_e6, \_e9, \_e8, \_e11, \_e10, \_e13, \_e12, \_e15, \_e14, \_e16, fd, \_e17, callE, \_e18, fdE, \_e19, \_e20} \rangle$
			}
[
	{$\leftouterjoin$
			\\
			\footnotesize
			$\color{gray} \langle \var{call, \_e7, \_e6, \_e9, \_e8, \_e11, \_e10, \_e13, \_e12, \_e15, \_e14, \_e16, fd, \_e17, callE, \_e18, fdE, \_e19, \_e20} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{call, \_e7, \_e6, \_e9, \_e8, \_e11, \_e10, \_e13, \_e12, \_e15, \_e14, \_e16, fd, \_e17, callE, \_e18, fdE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{call, \_e7, \_e6, \_e9, \_e8, \_e11, \_e10, \_e13, \_e12, \_e15, \_e14, \_e16, fd, \_e17, callE, \_e18, fdE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{call, \_e7, \_e6, \_e9, \_e8, \_e11, \_e10, \_e13, \_e12, \_e15, \_e14, \_e16, fd, \_e17, callE} \rangle$
			}
[
	{$\expandin{\_e14}{fd}{FunctionDeclaration}{\_e16}{name}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{call, \_e7, \_e6, \_e9, \_e8, \_e11, \_e10, \_e13, \_e12, \_e15, \_e14, \_e16, fd} \rangle$
			}
[
	{$\expandout{\_e12}{\_e14}{BindingIdentifier}{\_e15}{node}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{call, \_e7, \_e6, \_e9, \_e8, \_e11, \_e10, \_e13, \_e12, \_e15, \_e14} \rangle$
			}
[
	{$\expandout{\_e10}{\_e12}{Declaration}{\_e13}{declarations}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{call, \_e7, \_e6, \_e9, \_e8, \_e11, \_e10, \_e13, \_e12} \rangle$
			}
[
	{$\expandin{\_e8}{\_e10}{Variable}{\_e11}{references}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{call, \_e7, \_e6, \_e9, \_e8, \_e11, \_e10} \rangle$
			}
[
	{$\expandin{\_e6}{\_e8}{Reference}{\_e9}{node}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{call, \_e7, \_e6, \_e9, \_e8} \rangle$
			}
[
	{$\expandout{call}{\_e6}{IdentifierExpression}{\_e7}{callee}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{call, \_e7, \_e6} \rangle$
			}
[
	{$\getvertices{call}{CallExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{call} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
]
[
	{$\expandout{call}{callE}{End}{\_e17}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{call, \_e17, callE} \rangle$
			}
[
	{$\getvertices{call}{CallExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{call} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{fd}{fdE}{End}{\_e18}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd, \_e18, fdE} \rangle$
			}
[
	{$\getvertices{fd}{FunctionDeclaration}$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
[
	{$\expandout{call}{\_e20}{}{\_e19}{arguments}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{call, \_e19, \_e20} \rangle$
			}
[
	{$\getvertices{call}{CallExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{call} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}
\subsection{CallExpressionParam}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (arguments:List) <-[:arguments]- (callExp:CallExpression) -[:callee]->
  (:IdentifierExpression) <-[:`node`]- (:Reference) <-[:references]-
  (:Variable) -[:declarations]-> (:Declaration) -[:`node`]->
  (:BindingIdentifier) <-[:name]- (fd:FunctionDeclaration) -[:params]->
  (:FormalParameters) -[:items]-> (params:List),

  (callExp)     -[:`_end`]->  (callExpE:`End`),
  (fd)          -[:`_end`]->  (fdE:`End`),
  (arguments)   -[:`_end`]->  (argumentsE:`End`)

MERGE
  (callExp)     -[:`_normal`]-> (arguments) -[:`_end`]->
  (argumentsE)  -[:`_normal`]-> (fd)        -[:`_end`]->
  (fdE)         -[:`_normal`]-> (callExpE)

\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\alldifferent{} \Big(\expandout{\_e33}{params}{List}{\_e35}{items}{1}{1} \Big(\expandout{fd}{\_e33}{FormalParameters}{\_e34}{params}{1}{1} \Big(\expandin{\_e30}{fd}{FunctionDeclaration}{\_e32}{name}{1}{1} \Big(\expandout{\_e28}{\_e30}{BindingIdentifier}{\_e31}{node}{1}{1} \Big(\expandout{\_e26}{\_e28}{Declaration}{\_e29}{declarations}{1}{1} \Big(\expandin{\_e24}{\_e26}{Variable}{\_e27}{references}{1}{1} \Big(\expandin{\_e22}{\_e24}{Reference}{\_e25}{node}{1}{1} \Big(\expandout{callExp}{\_e22}{IdentifierExpression}{\_e23}{callee}{1}{1} \Big(\expandin{arguments}{callExp}{CallExpression}{\_e21}{arguments}{1}{1} \Big(\getvertices{arguments}{List}
\Big)
\Big)
\Big)
\Big)
\Big)
\Big)
\Big)
\Big)
\Big)
 \join \expandout{callExp}{callExpE}{End}{\_e36}{\_end}{1}{1} \Big(\getvertices{callExp}{CallExpression}
\Big)
 \join \expandout{fd}{fdE}{End}{\_e37}{\_end}{1}{1} \Big(\getvertices{fd}{FunctionDeclaration}
\Big)
 \join \expandout{arguments}{argumentsE}{End}{\_e38}{\_end}{1}{1} \Big(\getvertices{arguments}{List}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e21, callExp, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26, \_e29, \_e28, \_e31, \_e30, \_e32, fd, \_e34, \_e33, \_e35, params, \_e36, callExpE, \_e37, fdE, \_e38, argumentsE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e21, callExp, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26, \_e29, \_e28, \_e31, \_e30, \_e32, fd, \_e34, \_e33, \_e35, params, \_e36, callExpE, \_e37, fdE, \_e38, argumentsE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e21, callExp, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26, \_e29, \_e28, \_e31, \_e30, \_e32, fd, \_e34, \_e33, \_e35, params, \_e36, callExpE, \_e37, fdE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e21, callExp, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26, \_e29, \_e28, \_e31, \_e30, \_e32, fd, \_e34, \_e33, \_e35, params, \_e36, callExpE} \rangle$
			}
[
	{$\expandout{\_e33}{params}{List}{\_e35}{items}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e21, callExp, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26, \_e29, \_e28, \_e31, \_e30, \_e32, fd, \_e34, \_e33, \_e35, params} \rangle$
			}
[
	{$\expandout{fd}{\_e33}{FormalParameters}{\_e34}{params}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e21, callExp, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26, \_e29, \_e28, \_e31, \_e30, \_e32, fd, \_e34, \_e33} \rangle$
			}
[
	{$\expandin{\_e30}{fd}{FunctionDeclaration}{\_e32}{name}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e21, callExp, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26, \_e29, \_e28, \_e31, \_e30, \_e32, fd} \rangle$
			}
[
	{$\expandout{\_e28}{\_e30}{BindingIdentifier}{\_e31}{node}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e21, callExp, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26, \_e29, \_e28, \_e31, \_e30} \rangle$
			}
[
	{$\expandout{\_e26}{\_e28}{Declaration}{\_e29}{declarations}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e21, callExp, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26, \_e29, \_e28} \rangle$
			}
[
	{$\expandin{\_e24}{\_e26}{Variable}{\_e27}{references}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e21, callExp, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26} \rangle$
			}
[
	{$\expandin{\_e22}{\_e24}{Reference}{\_e25}{node}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e21, callExp, \_e23, \_e22, \_e25, \_e24} \rangle$
			}
[
	{$\expandout{callExp}{\_e22}{IdentifierExpression}{\_e23}{callee}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e21, callExp, \_e23, \_e22} \rangle$
			}
[
	{$\expandin{arguments}{callExp}{CallExpression}{\_e21}{arguments}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e21, callExp} \rangle$
			}
[
	{$\getvertices{arguments}{List}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
]
]
]
]
[
	{$\expandout{callExp}{callExpE}{End}{\_e36}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{callExp, \_e36, callExpE} \rangle$
			}
[
	{$\getvertices{callExp}{CallExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{callExp} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{fd}{fdE}{End}{\_e37}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd, \_e37, fdE} \rangle$
			}
[
	{$\getvertices{fd}{FunctionDeclaration}$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{arguments}{argumentsE}{End}{\_e38}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e38, argumentsE} \rangle$
			}
[
	{$\getvertices{arguments}{List}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e21, callExp, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26, \_e29, \_e28, \_e31, \_e30, \_e32, fd, \_e34, \_e33, \_e35, params, \_e36, callExpE, \_e37, fdE, \_e38, argumentsE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e21, callExp, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26, \_e29, \_e28, \_e31, \_e30, \_e32, fd, \_e34, \_e33, \_e35, params, \_e36, callExpE, \_e37, fdE, \_e38, argumentsE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e21, callExp, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26, \_e29, \_e28, \_e31, \_e30, \_e32, fd, \_e34, \_e33, \_e35, params, \_e36, callExpE, \_e37, fdE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e21, callExp, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26, \_e29, \_e28, \_e31, \_e30, \_e32, fd, \_e34, \_e33, \_e35, params, \_e36, callExpE} \rangle$
			}
[
	{$\expandout{\_e33}{params}{List}{\_e35}{items}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e21, callExp, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26, \_e29, \_e28, \_e31, \_e30, \_e32, fd, \_e34, \_e33, \_e35, params} \rangle$
			}
[
	{$\expandout{fd}{\_e33}{FormalParameters}{\_e34}{params}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e21, callExp, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26, \_e29, \_e28, \_e31, \_e30, \_e32, fd, \_e34, \_e33} \rangle$
			}
[
	{$\expandin{\_e30}{fd}{FunctionDeclaration}{\_e32}{name}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e21, callExp, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26, \_e29, \_e28, \_e31, \_e30, \_e32, fd} \rangle$
			}
[
	{$\expandout{\_e28}{\_e30}{BindingIdentifier}{\_e31}{node}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e21, callExp, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26, \_e29, \_e28, \_e31, \_e30} \rangle$
			}
[
	{$\expandout{\_e26}{\_e28}{Declaration}{\_e29}{declarations}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e21, callExp, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26, \_e29, \_e28} \rangle$
			}
[
	{$\expandin{\_e24}{\_e26}{Variable}{\_e27}{references}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e21, callExp, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26} \rangle$
			}
[
	{$\expandin{\_e22}{\_e24}{Reference}{\_e25}{node}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e21, callExp, \_e23, \_e22, \_e25, \_e24} \rangle$
			}
[
	{$\expandout{callExp}{\_e22}{IdentifierExpression}{\_e23}{callee}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e21, callExp, \_e23, \_e22} \rangle$
			}
[
	{$\expandin{arguments}{callExp}{CallExpression}{\_e21}{arguments}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e21, callExp} \rangle$
			}
[
	{$\getvertices{arguments}{List}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
]
]
]
]
[
	{$\expandout{callExp}{callExpE}{End}{\_e36}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{callExp, \_e36, callExpE} \rangle$
			}
[
	{$\getvertices{callExp}{CallExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{callExp} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{fd}{fdE}{End}{\_e37}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd, \_e37, fdE} \rangle$
			}
[
	{$\getvertices{fd}{FunctionDeclaration}$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{arguments}{argumentsE}{End}{\_e38}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e38, argumentsE} \rangle$
			}
[
	{$\getvertices{arguments}{List}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}
\subsection{ExpressionStatement}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (es:ExpressionStatement)-[:expression]->(exp:Expression),

  (es)  -[:`_end`]->  (esE:End),
  (exp) -[:`_end`]->  (expE:End)

MERGE
  (es)    -[:`_normal`]-> (exp)   -[:`_end`]->
  (expE)  -[:`_normal`]-> (esE)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\alldifferent{} \Big(\expandout{es}{exp}{Expression}{\_e39}{expression}{1}{1} \Big(\getvertices{es}{ExpressionStatement}
\Big)
 \join \expandout{es}{esE}{End}{\_e40}{\_end}{1}{1} \Big(\getvertices{es}{ExpressionStatement}
\Big)
 \join \expandout{exp}{expE}{End}{\_e41}{\_end}{1}{1} \Big(\getvertices{exp}{Expression}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{es, \_e39, exp, \_e40, esE, \_e41, expE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{es, \_e39, exp, \_e40, esE, \_e41, expE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{es, \_e39, exp, \_e40, esE} \rangle$
			}
[
	{$\expandout{es}{exp}{Expression}{\_e39}{expression}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{es, \_e39, exp} \rangle$
			}
[
	{$\getvertices{es}{ExpressionStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{es} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\expandout{es}{esE}{End}{\_e40}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{es, \_e40, esE} \rangle$
			}
[
	{$\getvertices{es}{ExpressionStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{es} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{exp}{expE}{End}{\_e41}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{exp, \_e41, expE} \rangle$
			}
[
	{$\getvertices{exp}{Expression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{exp} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{es, \_e39, exp, \_e40, esE, \_e41, expE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{es, \_e39, exp, \_e40, esE, \_e41, expE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{es, \_e39, exp, \_e40, esE} \rangle$
			}
[
	{$\expandout{es}{exp}{Expression}{\_e39}{expression}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{es, \_e39, exp} \rangle$
			}
[
	{$\getvertices{es}{ExpressionStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{es} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\expandout{es}{esE}{End}{\_e40}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{es, \_e40, esE} \rangle$
			}
[
	{$\getvertices{es}{ExpressionStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{es} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{exp}{expE}{End}{\_e41}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{exp, \_e41, expE} \rangle$
			}
[
	{$\getvertices{exp}{Expression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{exp} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}
\subsection{FunctionDeclaration}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (fd:FunctionDeclaration)-[:body]->(b:FunctionBody)-[:statements]->(list:List),

  (fd)    -[:`_end`]->  (fdE:End),
  (list)  -[:`_end`]->  (listE:End)

MERGE
  (fd)    -[:`_normal`]-> (list)    -[:`_end`]->
  (listE) -[:`_normal`]-> (fdE)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\alldifferent{} \Big(\expandout{b}{list}{List}{\_e43}{statements}{1}{1} \Big(\expandout{fd}{b}{FunctionBody}{\_e42}{body}{1}{1} \Big(\getvertices{fd}{FunctionDeclaration}
\Big)
\Big)
 \join \expandout{fd}{fdE}{End}{\_e44}{\_end}{1}{1} \Big(\getvertices{fd}{FunctionDeclaration}
\Big)
 \join \expandout{list}{listE}{End}{\_e45}{\_end}{1}{1} \Big(\getvertices{list}{List}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd, \_e42, b, \_e43, list, \_e44, fdE, \_e45, listE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd, \_e42, b, \_e43, list, \_e44, fdE, \_e45, listE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd, \_e42, b, \_e43, list, \_e44, fdE} \rangle$
			}
[
	{$\expandout{b}{list}{List}{\_e43}{statements}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd, \_e42, b, \_e43, list} \rangle$
			}
[
	{$\expandout{fd}{b}{FunctionBody}{\_e42}{body}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd, \_e42, b} \rangle$
			}
[
	{$\getvertices{fd}{FunctionDeclaration}$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{fd}{fdE}{End}{\_e44}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd, \_e44, fdE} \rangle$
			}
[
	{$\getvertices{fd}{FunctionDeclaration}$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{list}{listE}{End}{\_e45}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{list, \_e45, listE} \rangle$
			}
[
	{$\getvertices{list}{List}$
			\\
			\footnotesize
			$\color{gray} \langle \var{list} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd, \_e42, b, \_e43, list, \_e44, fdE, \_e45, listE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd, \_e42, b, \_e43, list, \_e44, fdE, \_e45, listE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd, \_e42, b, \_e43, list, \_e44, fdE} \rangle$
			}
[
	{$\expandout{b}{list}{List}{\_e43}{statements}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd, \_e42, b, \_e43, list} \rangle$
			}
[
	{$\expandout{fd}{b}{FunctionBody}{\_e42}{body}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd, \_e42, b} \rangle$
			}
[
	{$\getvertices{fd}{FunctionDeclaration}$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{fd}{fdE}{End}{\_e44}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd, \_e44, fdE} \rangle$
			}
[
	{$\getvertices{fd}{FunctionDeclaration}$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{list}{listE}{End}{\_e45}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{list, \_e45, listE} \rangle$
			}
[
	{$\getvertices{list}{List}$
			\\
			\footnotesize
			$\color{gray} \langle \var{list} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}
\subsection{IfStatementAlternate}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (test:Node)<-[:test]-(if:IfStatement)-[:consequent]->(consequent:Node),
  (if)-[:alternate]->(alternate:Statement),

  (alternate)   -[:`_end`]->    (alternateE:End),

  (if)          -[:`_end`]->  (ifE:End),
  (test)        -[:`_end`]->  (testE:End),
  (consequent)  -[:`_end`]->  (consequentE:End)

MERGE
  (if)          -[:`_normal`]-> (test)        -[:`_end`]->
  (testE)       -[:`_true`]->   (consequent)  -[:`_end`]->
  (consequentE) -[:`_normal`]-> (ifE)

MERGE
  (testE)       -[:`_false`]->  (alternate)   -[:`_end`]->
  (alternateE)  -[:`_normal`]-> (ifE)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\alldifferent{} \Big(\expandout{if}{consequent}{Node}{\_e47}{consequent}{1}{1} \Big(\expandin{test}{if}{IfStatement}{\_e46}{test}{1}{1} \Big(\getvertices{test}{Node}
\Big)
\Big)
 \join \expandout{if}{alternate}{Statement}{\_e48}{alternate}{1}{1} \Big(\getvertices{if}{IfStatement}
\Big)
 \join \expandout{alternate}{alternateE}{End}{\_e49}{\_end}{1}{1} \Big(\getvertices{alternate}{Statement}
\Big)
 \join \expandout{if}{ifE}{End}{\_e50}{\_end}{1}{1} \Big(\getvertices{if}{IfStatement}
\Big)
 \join \expandout{test}{testE}{End}{\_e51}{\_end}{1}{1} \Big(\getvertices{test}{Node}
\Big)
 \join \expandout{consequent}{consequentE}{End}{\_e52}{\_end}{1}{1} \Big(\getvertices{consequent}{Node}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e46, if, \_e47, consequent, \_e48, alternate, \_e49, alternateE, \_e50, ifE, \_e51, testE, \_e52, consequentE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e46, if, \_e47, consequent, \_e48, alternate, \_e49, alternateE, \_e50, ifE, \_e51, testE, \_e52, consequentE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e46, if, \_e47, consequent, \_e48, alternate, \_e49, alternateE, \_e50, ifE, \_e51, testE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e46, if, \_e47, consequent, \_e48, alternate, \_e49, alternateE, \_e50, ifE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e46, if, \_e47, consequent, \_e48, alternate, \_e49, alternateE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e46, if, \_e47, consequent, \_e48, alternate} \rangle$
			}
[
	{$\expandout{if}{consequent}{Node}{\_e47}{consequent}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e46, if, \_e47, consequent} \rangle$
			}
[
	{$\expandin{test}{if}{IfStatement}{\_e46}{test}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e46, if} \rangle$
			}
[
	{$\getvertices{test}{Node}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{if}{alternate}{Statement}{\_e48}{alternate}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{if, \_e48, alternate} \rangle$
			}
[
	{$\getvertices{if}{IfStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{if} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{alternate}{alternateE}{End}{\_e49}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{alternate, \_e49, alternateE} \rangle$
			}
[
	{$\getvertices{alternate}{Statement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{alternate} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{if}{ifE}{End}{\_e50}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{if, \_e50, ifE} \rangle$
			}
[
	{$\getvertices{if}{IfStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{if} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{test}{testE}{End}{\_e51}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e51, testE} \rangle$
			}
[
	{$\getvertices{test}{Node}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{consequent}{consequentE}{End}{\_e52}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{consequent, \_e52, consequentE} \rangle$
			}
[
	{$\getvertices{consequent}{Node}$
			\\
			\footnotesize
			$\color{gray} \langle \var{consequent} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e46, if, \_e47, consequent, \_e48, alternate, \_e49, alternateE, \_e50, ifE, \_e51, testE, \_e52, consequentE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e46, if, \_e47, consequent, \_e48, alternate, \_e49, alternateE, \_e50, ifE, \_e51, testE, \_e52, consequentE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e46, if, \_e47, consequent, \_e48, alternate, \_e49, alternateE, \_e50, ifE, \_e51, testE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e46, if, \_e47, consequent, \_e48, alternate, \_e49, alternateE, \_e50, ifE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e46, if, \_e47, consequent, \_e48, alternate, \_e49, alternateE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e46, if, \_e47, consequent, \_e48, alternate} \rangle$
			}
[
	{$\expandout{if}{consequent}{Node}{\_e47}{consequent}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e46, if, \_e47, consequent} \rangle$
			}
[
	{$\expandin{test}{if}{IfStatement}{\_e46}{test}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e46, if} \rangle$
			}
[
	{$\getvertices{test}{Node}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{if}{alternate}{Statement}{\_e48}{alternate}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{if, \_e48, alternate} \rangle$
			}
[
	{$\getvertices{if}{IfStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{if} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{alternate}{alternateE}{End}{\_e49}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{alternate, \_e49, alternateE} \rangle$
			}
[
	{$\getvertices{alternate}{Statement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{alternate} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{if}{ifE}{End}{\_e50}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{if, \_e50, ifE} \rangle$
			}
[
	{$\getvertices{if}{IfStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{if} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{test}{testE}{End}{\_e51}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e51, testE} \rangle$
			}
[
	{$\getvertices{test}{Node}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{consequent}{consequentE}{End}{\_e52}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{consequent, \_e52, consequentE} \rangle$
			}
[
	{$\getvertices{consequent}{Node}$
			\\
			\footnotesize
			$\color{gray} \langle \var{consequent} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}
\subsection{IfStatementNoAlternate}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (test:Node)<-[:test]-(if:IfStatement)-[:consequent]->(consequent:Node),

  (if)          -[:`_end`]->  (ifE:End),
  (test)        -[:`_end`]->  (testE:End),
  (consequent)  -[:`_end`]->  (consequentE:End)

WHERE
  NOT (if)-[:alternate]->(:Statement)

MERGE
  (if)	        -[:`_normal`]-> (test)       -[:`_end`]->
  (testE)       -[:`_true`]->   (consequent) -[:`_end`]->
  (consequentE)	-[:`_normal`]-> (ifE)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\selection{\neg \left( \var{if} IS NOT NULL \land \var{\_e58} IS NOT NULL \land \var{\_e59} IS NOT NULL \right)} \Big(\alldifferent{} \Big(\expandout{if}{consequent}{Node}{\_e54}{consequent}{1}{1} \Big(\expandin{test}{if}{IfStatement}{\_e53}{test}{1}{1} \Big(\getvertices{test}{Node}
\Big)
\Big)
 \join \expandout{if}{ifE}{End}{\_e55}{\_end}{1}{1} \Big(\getvertices{if}{IfStatement}
\Big)
 \join \expandout{test}{testE}{End}{\_e56}{\_end}{1}{1} \Big(\getvertices{test}{Node}
\Big)
 \join \expandout{consequent}{consequentE}{End}{\_e57}{\_end}{1}{1} \Big(\getvertices{consequent}{Node}
\Big)
\Big)
 \leftouterjoin \expandout{if}{\_e59}{Statement}{\_e58}{alternate}{1}{1} \Big(\getvertices{if}{IfStatement}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\selection{\neg \left( \var{if} IS NOT NULL \land \var{\_e58} IS NOT NULL \land \var{\_e59} IS NOT NULL \right)}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e53, if, \_e54, consequent, \_e55, ifE, \_e56, testE, \_e57, consequentE, \_e58, \_e59} \rangle$
			}
[
	{$\leftouterjoin$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e53, if, \_e54, consequent, \_e55, ifE, \_e56, testE, \_e57, consequentE, \_e58, \_e59} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e53, if, \_e54, consequent, \_e55, ifE, \_e56, testE, \_e57, consequentE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e53, if, \_e54, consequent, \_e55, ifE, \_e56, testE, \_e57, consequentE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e53, if, \_e54, consequent, \_e55, ifE, \_e56, testE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e53, if, \_e54, consequent, \_e55, ifE} \rangle$
			}
[
	{$\expandout{if}{consequent}{Node}{\_e54}{consequent}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e53, if, \_e54, consequent} \rangle$
			}
[
	{$\expandin{test}{if}{IfStatement}{\_e53}{test}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e53, if} \rangle$
			}
[
	{$\getvertices{test}{Node}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{if}{ifE}{End}{\_e55}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{if, \_e55, ifE} \rangle$
			}
[
	{$\getvertices{if}{IfStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{if} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{test}{testE}{End}{\_e56}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e56, testE} \rangle$
			}
[
	{$\getvertices{test}{Node}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{consequent}{consequentE}{End}{\_e57}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{consequent, \_e57, consequentE} \rangle$
			}
[
	{$\getvertices{consequent}{Node}$
			\\
			\footnotesize
			$\color{gray} \langle \var{consequent} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
[
	{$\expandout{if}{\_e59}{Statement}{\_e58}{alternate}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{if, \_e58, \_e59} \rangle$
			}
[
	{$\getvertices{if}{IfStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{if} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\selection{\neg \left( \var{if} IS NOT NULL \land \var{\_e58} IS NOT NULL \land \var{\_e59} IS NOT NULL \right)}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e53, if, \_e54, consequent, \_e55, ifE, \_e56, testE, \_e57, consequentE, \_e58, \_e59} \rangle$
			}
[
	{$\leftouterjoin$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e53, if, \_e54, consequent, \_e55, ifE, \_e56, testE, \_e57, consequentE, \_e58, \_e59} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e53, if, \_e54, consequent, \_e55, ifE, \_e56, testE, \_e57, consequentE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e53, if, \_e54, consequent, \_e55, ifE, \_e56, testE, \_e57, consequentE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e53, if, \_e54, consequent, \_e55, ifE, \_e56, testE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e53, if, \_e54, consequent, \_e55, ifE} \rangle$
			}
[
	{$\expandout{if}{consequent}{Node}{\_e54}{consequent}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e53, if, \_e54, consequent} \rangle$
			}
[
	{$\expandin{test}{if}{IfStatement}{\_e53}{test}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e53, if} \rangle$
			}
[
	{$\getvertices{test}{Node}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{if}{ifE}{End}{\_e55}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{if, \_e55, ifE} \rangle$
			}
[
	{$\getvertices{if}{IfStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{if} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{test}{testE}{End}{\_e56}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e56, testE} \rangle$
			}
[
	{$\getvertices{test}{Node}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{consequent}{consequentE}{End}{\_e57}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{consequent, \_e57, consequentE} \rangle$
			}
[
	{$\getvertices{consequent}{Node}$
			\\
			\footnotesize
			$\color{gray} \langle \var{consequent} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
[
	{$\expandout{if}{\_e59}{Statement}{\_e58}{alternate}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{if, \_e58, \_e59} \rangle$
			}
[
	{$\getvertices{if}{IfStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{if} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}
\subsection{Infinity}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (lit:LiteralInfinityExpression),
  (ts:TypeSystem)-[:`_instance`]->(tag:Tag:`Infinity`)

MERGE
  (lit)-[:`_type`]->(tag)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\alldifferent{} \Big(\getvertices{lit}{LiteralInfinityExpression}
 \join \expandout{ts}{tag}{Tag \land Infinity}{\_e60}{\_instance}{1}{1} \Big(\getvertices{ts}{TypeSystem}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e60, tag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e60, tag} \rangle$
			}
[
	{$\getvertices{lit}{LiteralInfinityExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\expandout{ts}{tag}{Tag \land Infinity}{\_e60}{\_instance}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts, \_e60, tag} \rangle$
			}
[
	{$\getvertices{ts}{TypeSystem}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e60, tag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e60, tag} \rangle$
			}
[
	{$\getvertices{lit}{LiteralInfinityExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\expandout{ts}{tag}{Tag \land Infinity}{\_e60}{\_instance}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts, \_e60, tag} \rangle$
			}
[
	{$\getvertices{ts}{TypeSystem}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}
\subsection{ListNoItem}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (l:List),

  (l)     -[:`_end`]->  (lE:End)

WHERE
  NOT (l)-[:`0`]->()

MERGE
  (l)     -[:`_normal`]-> (lE)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
\subsection{ListWithItem}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (l:List)-[:`0`]->(first),
  (l)-[:last]->(last),

  (l)     -[:`_end`]->  (lE:End),
  (last)  -[:`_end`]->  (lastE:End)

MERGE (l)     -[:`_normal`]-> (first)
MERGE (lastE) -[:`_normal`]-> (lE)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\alldifferent{} \Big(\expandout{l}{first}{}{\_e62}{\_e63}{1}{1} \Big(\getvertices{l}{List}
\Big)
 \join \expandout{l}{last}{}{\_e64}{last}{1}{1} \Big(\getvertices{l}{List}
\Big)
 \join \expandout{l}{lE}{End}{\_e65}{\_end}{1}{1} \Big(\getvertices{l}{List}
\Big)
 \join \expandout{last}{lastE}{End}{\_e66}{\_end}{1}{1} \Big(\getvertices{last}{}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{l, \_e62, first, \_e64, last, \_e65, lE, \_e66, lastE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{l, \_e62, first, \_e64, last, \_e65, lE, \_e66, lastE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{l, \_e62, first, \_e64, last, \_e65, lE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{l, \_e62, first, \_e64, last} \rangle$
			}
[
	{$\expandout{l}{first}{}{\_e62}{\_e63}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{l, \_e62, first} \rangle$
			}
[
	{$\getvertices{l}{List}$
			\\
			\footnotesize
			$\color{gray} \langle \var{l} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\expandout{l}{last}{}{\_e64}{last}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{l, \_e64, last} \rangle$
			}
[
	{$\getvertices{l}{List}$
			\\
			\footnotesize
			$\color{gray} \langle \var{l} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{l}{lE}{End}{\_e65}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{l, \_e65, lE} \rangle$
			}
[
	{$\getvertices{l}{List}$
			\\
			\footnotesize
			$\color{gray} \langle \var{l} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{last}{lastE}{End}{\_e66}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{last, \_e66, lastE} \rangle$
			}
[
	{$\getvertices{last}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{last} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{l, \_e62, first, \_e64, last, \_e65, lE, \_e66, lastE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{l, \_e62, first, \_e64, last, \_e65, lE, \_e66, lastE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{l, \_e62, first, \_e64, last, \_e65, lE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{l, \_e62, first, \_e64, last} \rangle$
			}
[
	{$\expandout{l}{first}{}{\_e62}{\_e63}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{l, \_e62, first} \rangle$
			}
[
	{$\getvertices{l}{List}$
			\\
			\footnotesize
			$\color{gray} \langle \var{l} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\expandout{l}{last}{}{\_e64}{last}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{l, \_e64, last} \rangle$
			}
[
	{$\getvertices{l}{List}$
			\\
			\footnotesize
			$\color{gray} \langle \var{l} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{l}{lE}{End}{\_e65}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{l, \_e65, lE} \rangle$
			}
[
	{$\getvertices{l}{List}$
			\\
			\footnotesize
			$\color{gray} \langle \var{l} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{last}{lastE}{End}{\_e66}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{last, \_e66, lastE} \rangle$
			}
[
	{$\getvertices{last}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{last} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}
\subsection{LiteralX}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (le:Literal)  -[:`_end`]->  (leE:End)
MERGE (le)    -[:`_normal`]-> (leE)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\alldifferent{} \Big(\expandout{le}{leE}{End}{\_e67}{\_end}{1}{1} \Big(\getvertices{le}{Literal}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{le, \_e67, leE} \rangle$
			}
[
	{$\expandout{le}{leE}{End}{\_e67}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{le, \_e67, leE} \rangle$
			}
[
	{$\getvertices{le}{Literal}$
			\\
			\footnotesize
			$\color{gray} \langle \var{le} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{le, \_e67, leE} \rangle$
			}
[
	{$\expandout{le}{leE}{End}{\_e67}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{le, \_e67, leE} \rangle$
			}
[
	{$\getvertices{le}{Literal}$
			\\
			\footnotesize
			$\color{gray} \langle \var{le} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}
\subsection{LogicalOr}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (ltag:Tag)<-[:`_type`]-(left:Expression)
  <-[:left]-(exp:BinaryExpression)-[:right]->
  (right:Expression)-[:`_type`]->(rtag:Tag),

  (ts:TypeSystem)-[:`_instance`]->(btag:Tag:`Boolean`)

WHERE
  exp.operator = 'LogicalOr'

MERGE (exp)-[:`_type`]->(rtag)
MERGE (exp)-[:`_type`]->(ltag)
MERGE (exp)-[:`_type`]->(btag)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\selection{\var{exp.operator} = \literal{''LogicalOr''}} \Big(\alldifferent{} \Big(\expandout{right}{rtag}{Tag}{\_e71}{\_type}{1}{1} \Big(\expandout{exp}{right}{Expression}{\_e70}{right}{1}{1} \Big(\expandin{left}{exp}{BinaryExpression}{\_e69}{left}{1}{1} \Big(\expandin{ltag}{left}{Expression}{\_e68}{\_type}{1}{1} \Big(\getvertices{ltag}{Tag}
\Big)
\Big)
\Big)
\Big)
 \join \expandout{ts}{btag}{Tag \land Boolean}{\_e72}{\_instance}{1}{1} \Big(\getvertices{ts}{TypeSystem}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\selection{\var{exp.operator} = \literal{''LogicalOr''}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ltag, \_e68, left, \_e69, exp, \_e70, right, \_e71, rtag, ts, \_e72, btag} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ltag, \_e68, left, \_e69, exp, \_e70, right, \_e71, rtag, ts, \_e72, btag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{ltag, \_e68, left, \_e69, exp, \_e70, right, \_e71, rtag, ts, \_e72, btag} \rangle$
			}
[
	{$\expandout{right}{rtag}{Tag}{\_e71}{\_type}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ltag, \_e68, left, \_e69, exp, \_e70, right, \_e71, rtag} \rangle$
			}
[
	{$\expandout{exp}{right}{Expression}{\_e70}{right}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ltag, \_e68, left, \_e69, exp, \_e70, right} \rangle$
			}
[
	{$\expandin{left}{exp}{BinaryExpression}{\_e69}{left}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ltag, \_e68, left, \_e69, exp} \rangle$
			}
[
	{$\expandin{ltag}{left}{Expression}{\_e68}{\_type}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ltag, \_e68, left} \rangle$
			}
[
	{$\getvertices{ltag}{Tag}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ltag} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
[
	{$\expandout{ts}{btag}{Tag \land Boolean}{\_e72}{\_instance}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts, \_e72, btag} \rangle$
			}
[
	{$\getvertices{ts}{TypeSystem}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\selection{\var{exp.operator} = \literal{''LogicalOr''}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ltag, \_e68, left, \_e69, exp, \_e70, right, \_e71, rtag, ts, \_e72, btag} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ltag, \_e68, left, \_e69, exp, \_e70, right, \_e71, rtag, ts, \_e72, btag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{ltag, \_e68, left, \_e69, exp, \_e70, right, \_e71, rtag, ts, \_e72, btag} \rangle$
			}
[
	{$\expandout{right}{rtag}{Tag}{\_e71}{\_type}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ltag, \_e68, left, \_e69, exp, \_e70, right, \_e71, rtag} \rangle$
			}
[
	{$\expandout{exp}{right}{Expression}{\_e70}{right}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ltag, \_e68, left, \_e69, exp, \_e70, right} \rangle$
			}
[
	{$\expandin{left}{exp}{BinaryExpression}{\_e69}{left}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ltag, \_e68, left, \_e69, exp} \rangle$
			}
[
	{$\expandin{ltag}{left}{Expression}{\_e68}{\_type}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ltag, \_e68, left} \rangle$
			}
[
	{$\getvertices{ltag}{Tag}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ltag} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
[
	{$\expandout{ts}{btag}{Tag \land Boolean}{\_e72}{\_instance}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts, \_e72, btag} \rangle$
			}
[
	{$\getvertices{ts}{TypeSystem}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}
\subsection{Null}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (lit:LiteralNullExpression),
  (ts:TypeSystem)-[:`_instance`]->(tag:Tag:`Null`)

MERGE
  (lit)-[:`_type`]->(tag)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\alldifferent{} \Big(\getvertices{lit}{LiteralNullExpression}
 \join \expandout{ts}{tag}{Tag \land Null}{\_e73}{\_instance}{1}{1} \Big(\getvertices{ts}{TypeSystem}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e73, tag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e73, tag} \rangle$
			}
[
	{$\getvertices{lit}{LiteralNullExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\expandout{ts}{tag}{Tag \land Null}{\_e73}{\_instance}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts, \_e73, tag} \rangle$
			}
[
	{$\getvertices{ts}{TypeSystem}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e73, tag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e73, tag} \rangle$
			}
[
	{$\getvertices{lit}{LiteralNullExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\expandout{ts}{tag}{Tag \land Null}{\_e73}{\_instance}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts, \_e73, tag} \rangle$
			}
[
	{$\getvertices{ts}{TypeSystem}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}
\subsection{Numeric}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (lit:LiteralNumericExpression),
  (ts:TypeSystem)-[:`_instance`]->(tag:Tag:`Number`)

MERGE
  (lit)-[:`_type`]->(tag)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\alldifferent{} \Big(\getvertices{lit}{LiteralNumericExpression}
 \join \expandout{ts}{tag}{Tag \land Number}{\_e74}{\_instance}{1}{1} \Big(\getvertices{ts}{TypeSystem}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e74, tag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e74, tag} \rangle$
			}
[
	{$\getvertices{lit}{LiteralNumericExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\expandout{ts}{tag}{Tag \land Number}{\_e74}{\_instance}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts, \_e74, tag} \rangle$
			}
[
	{$\getvertices{ts}{TypeSystem}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e74, tag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e74, tag} \rangle$
			}
[
	{$\getvertices{lit}{LiteralNumericExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\expandout{ts}{tag}{Tag \land Number}{\_e74}{\_instance}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts, \_e74, tag} \rangle$
			}
[
	{$\getvertices{ts}{TypeSystem}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}
\subsection{Read}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (v:Variable)-[:references]->(r:Reference)-[:node]->(ide:IdentifierExpression),
  (v)-[:`_type`]->(tag:Tag)

MERGE
  (ide)-[:`_type`]->(tag)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\alldifferent{} \Big(\expandout{r}{ide}{IdentifierExpression}{\_e76}{node}{1}{1} \Big(\expandout{v}{r}{Reference}{\_e75}{references}{1}{1} \Big(\getvertices{v}{Variable}
\Big)
\Big)
 \join \expandout{v}{tag}{Tag}{\_e77}{\_type}{1}{1} \Big(\getvertices{v}{Variable}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v, \_e75, r, \_e76, ide, \_e77, tag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{v, \_e75, r, \_e76, ide, \_e77, tag} \rangle$
			}
[
	{$\expandout{r}{ide}{IdentifierExpression}{\_e76}{node}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v, \_e75, r, \_e76, ide} \rangle$
			}
[
	{$\expandout{v}{r}{Reference}{\_e75}{references}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v, \_e75, r} \rangle$
			}
[
	{$\getvertices{v}{Variable}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{v}{tag}{Tag}{\_e77}{\_type}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v, \_e77, tag} \rangle$
			}
[
	{$\getvertices{v}{Variable}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v, \_e75, r, \_e76, ide, \_e77, tag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{v, \_e75, r, \_e76, ide, \_e77, tag} \rangle$
			}
[
	{$\expandout{r}{ide}{IdentifierExpression}{\_e76}{node}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v, \_e75, r, \_e76, ide} \rangle$
			}
[
	{$\expandout{v}{r}{Reference}{\_e75}{references}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v, \_e75, r} \rangle$
			}
[
	{$\getvertices{v}{Variable}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{v}{tag}{Tag}{\_e77}{\_type}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v, \_e77, tag} \rangle$
			}
[
	{$\getvertices{v}{Variable}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}
\subsection{RegExp}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (lit:LiteralRegExpExpression),
  (ts:TypeSystem)-[:`_instance`]->(tag:Tag:`RegExp`)

MERGE
  (lit)-[:`_type`]->(tag)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\alldifferent{} \Big(\getvertices{lit}{LiteralRegExpExpression}
 \join \expandout{ts}{tag}{Tag \land RegExp}{\_e78}{\_instance}{1}{1} \Big(\getvertices{ts}{TypeSystem}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e78, tag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e78, tag} \rangle$
			}
[
	{$\getvertices{lit}{LiteralRegExpExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\expandout{ts}{tag}{Tag \land RegExp}{\_e78}{\_instance}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts, \_e78, tag} \rangle$
			}
[
	{$\getvertices{ts}{TypeSystem}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e78, tag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e78, tag} \rangle$
			}
[
	{$\getvertices{lit}{LiteralRegExpExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\expandout{ts}{tag}{Tag \land RegExp}{\_e78}{\_instance}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts, \_e78, tag} \rangle$
			}
[
	{$\getvertices{ts}{TypeSystem}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}
\subsection{String}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (lit:LiteralStringExpression),
  (ts:TypeSystem)-[:`_instance`]->(tag:Tag:`String`)

MERGE
  (lit)-[:`_type`]->(tag)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\alldifferent{} \Big(\getvertices{lit}{LiteralStringExpression}
 \join \expandout{ts}{tag}{Tag \land String}{\_e79}{\_instance}{1}{1} \Big(\getvertices{ts}{TypeSystem}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e79, tag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e79, tag} \rangle$
			}
[
	{$\getvertices{lit}{LiteralStringExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\expandout{ts}{tag}{Tag \land String}{\_e79}{\_instance}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts, \_e79, tag} \rangle$
			}
[
	{$\getvertices{ts}{TypeSystem}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e79, tag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e79, tag} \rangle$
			}
[
	{$\getvertices{lit}{LiteralStringExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\expandout{ts}{tag}{Tag \land String}{\_e79}{\_instance}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts, \_e79, tag} \rangle$
			}
[
	{$\getvertices{ts}{TypeSystem}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}
\subsection{TypeSystem}

\subsubsection*{Query specification}

\begin{lstlisting}
MERGE (ts:TypeSystem)

MERGE (ts)-[:`_instance`]->(:Tag:`Undefined`)
MERGE (ts)-[:`_instance`]->(:Tag:`Null`)
MERGE (ts)-[:`_instance`]->(:Tag:`Boolean`)
MERGE (ts)-[:`_instance`]->(:Tag:`Number`)
MERGE (ts)-[:`_instance`]->(:Tag:`String:`)
MERGE (ts)-[:`_instance`]->(:Tag:`Symbol`)
MERGE (ts)-[:`_instance`]->(:Tag:`Object`)
MERGE (ts)-[:`_instance`]->(:Tag:`Function`)
MERGE (ts)-[:`_instance`]->(:Tag:`Error`)

MERGE (ts)-[:`_instance`]->(:Tag:`Math`)
MERGE (ts)-[:`_instance`]->(:Tag:`Date`)
MERGE (ts)-[:`_instance`]->(:Tag:`RegExp`)
MERGE (ts)-[:`_instance`]->(:Tag:`Array`)
MERGE (ts)-[:`_instance`]->(:Tag:`Map`)
MERGE (ts)-[:`_instance`]->(:Tag:`Set`)
MERGE (ts)-[:`_instance`]->(:Tag:`JSON`)
MERGE (ts)-[:`_instance`]->(:Tag:`ArrayBuffer`)
MERGE (ts)-[:`_instance`]->(:Tag:`DataView`)
MERGE (ts)-[:`_instance`]->(:Tag:`Promise`)
MERGE (ts)-[:`_instance`]->(:Tag:`Proxy`)
MERGE (ts)-[:`_instance`]->(:Tag:`Reflect`)


MERGE (ts)-[:`_instance`]->(:Tag:`Infinity`)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
\subsection{VariableDeclarationStatement}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (vds:VariableDeclarationStatement)-[:declaration]->(vdion:VariableDeclaration)
  -[:declarators]->(vdor:VariableDeclarator)-[:init]->(exp:Expression),

  (vds)     -[:`_end`]->  (vdsE:End),
  (vdion)   -[:`_end`]->  (vdionE:End),
  (exp)     -[:`_end`]->  (expE:End)

MERGE (vdion)   -[:`_normal`]-> (vdionE)

MERGE
  (vds)     -[:`_normal`]-> (exp)   -[:`_end`]->
  (expE)    -[:`_normal`]-> (vdion) -[:`_end`]->
  (vdionE)  -[:`_normal`]-> (vdsE)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\alldifferent{} \Big(\expandout{vdor}{exp}{Expression}{\_e82}{init}{1}{1} \Big(\expandout{vdion}{vdor}{VariableDeclarator}{\_e81}{declarators}{1}{1} \Big(\expandout{vds}{vdion}{VariableDeclaration}{\_e80}{declaration}{1}{1} \Big(\getvertices{vds}{VariableDeclarationStatement}
\Big)
\Big)
\Big)
 \join \expandout{vds}{vdsE}{End}{\_e83}{\_end}{1}{1} \Big(\getvertices{vds}{VariableDeclarationStatement}
\Big)
 \join \expandout{vdion}{vdionE}{End}{\_e84}{\_end}{1}{1} \Big(\getvertices{vdion}{VariableDeclaration}
\Big)
 \join \expandout{exp}{expE}{End}{\_e85}{\_end}{1}{1} \Big(\getvertices{exp}{Expression}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds, \_e80, vdion, \_e81, vdor, \_e82, exp, \_e83, vdsE, \_e84, vdionE, \_e85, expE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds, \_e80, vdion, \_e81, vdor, \_e82, exp, \_e83, vdsE, \_e84, vdionE, \_e85, expE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds, \_e80, vdion, \_e81, vdor, \_e82, exp, \_e83, vdsE, \_e84, vdionE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds, \_e80, vdion, \_e81, vdor, \_e82, exp, \_e83, vdsE} \rangle$
			}
[
	{$\expandout{vdor}{exp}{Expression}{\_e82}{init}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds, \_e80, vdion, \_e81, vdor, \_e82, exp} \rangle$
			}
[
	{$\expandout{vdion}{vdor}{VariableDeclarator}{\_e81}{declarators}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds, \_e80, vdion, \_e81, vdor} \rangle$
			}
[
	{$\expandout{vds}{vdion}{VariableDeclaration}{\_e80}{declaration}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds, \_e80, vdion} \rangle$
			}
[
	{$\getvertices{vds}{VariableDeclarationStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
[
	{$\expandout{vds}{vdsE}{End}{\_e83}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds, \_e83, vdsE} \rangle$
			}
[
	{$\getvertices{vds}{VariableDeclarationStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{vdion}{vdionE}{End}{\_e84}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{vdion, \_e84, vdionE} \rangle$
			}
[
	{$\getvertices{vdion}{VariableDeclaration}$
			\\
			\footnotesize
			$\color{gray} \langle \var{vdion} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{exp}{expE}{End}{\_e85}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{exp, \_e85, expE} \rangle$
			}
[
	{$\getvertices{exp}{Expression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{exp} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds, \_e80, vdion, \_e81, vdor, \_e82, exp, \_e83, vdsE, \_e84, vdionE, \_e85, expE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds, \_e80, vdion, \_e81, vdor, \_e82, exp, \_e83, vdsE, \_e84, vdionE, \_e85, expE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds, \_e80, vdion, \_e81, vdor, \_e82, exp, \_e83, vdsE, \_e84, vdionE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds, \_e80, vdion, \_e81, vdor, \_e82, exp, \_e83, vdsE} \rangle$
			}
[
	{$\expandout{vdor}{exp}{Expression}{\_e82}{init}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds, \_e80, vdion, \_e81, vdor, \_e82, exp} \rangle$
			}
[
	{$\expandout{vdion}{vdor}{VariableDeclarator}{\_e81}{declarators}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds, \_e80, vdion, \_e81, vdor} \rangle$
			}
[
	{$\expandout{vds}{vdion}{VariableDeclaration}{\_e80}{declaration}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds, \_e80, vdion} \rangle$
			}
[
	{$\getvertices{vds}{VariableDeclarationStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
[
	{$\expandout{vds}{vdsE}{End}{\_e83}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds, \_e83, vdsE} \rangle$
			}
[
	{$\getvertices{vds}{VariableDeclarationStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{vdion}{vdionE}{End}{\_e84}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{vdion, \_e84, vdionE} \rangle$
			}
[
	{$\getvertices{vdion}{VariableDeclaration}$
			\\
			\footnotesize
			$\color{gray} \langle \var{vdion} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{exp}{expE}{End}{\_e85}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{exp, \_e85, expE} \rangle$
			}
[
	{$\getvertices{exp}{Expression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{exp} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}
\subsection{VariableDeclarator}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (bi:BindingIdentifier)<-[:binding]-
    (vd:VariableDeclarator)
      -[:init]->(exp:Expression),

  (exp)-[:`_type`]->(tag:Tag)

MERGE
  (bi)-[:`_type`]->(tag)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\alldifferent{} \Big(\expandout{vd}{exp}{Expression}{\_e87}{init}{1}{1} \Big(\expandin{bi}{vd}{VariableDeclarator}{\_e86}{binding}{1}{1} \Big(\getvertices{bi}{BindingIdentifier}
\Big)
\Big)
 \join \expandout{exp}{tag}{Tag}{\_e88}{\_type}{1}{1} \Big(\getvertices{exp}{Expression}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bi, \_e86, vd, \_e87, exp, \_e88, tag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{bi, \_e86, vd, \_e87, exp, \_e88, tag} \rangle$
			}
[
	{$\expandout{vd}{exp}{Expression}{\_e87}{init}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bi, \_e86, vd, \_e87, exp} \rangle$
			}
[
	{$\expandin{bi}{vd}{VariableDeclarator}{\_e86}{binding}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bi, \_e86, vd} \rangle$
			}
[
	{$\getvertices{bi}{BindingIdentifier}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bi} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{exp}{tag}{Tag}{\_e88}{\_type}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{exp, \_e88, tag} \rangle$
			}
[
	{$\getvertices{exp}{Expression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{exp} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bi, \_e86, vd, \_e87, exp, \_e88, tag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{bi, \_e86, vd, \_e87, exp, \_e88, tag} \rangle$
			}
[
	{$\expandout{vd}{exp}{Expression}{\_e87}{init}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bi, \_e86, vd, \_e87, exp} \rangle$
			}
[
	{$\expandin{bi}{vd}{VariableDeclarator}{\_e86}{binding}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bi, \_e86, vd} \rangle$
			}
[
	{$\getvertices{bi}{BindingIdentifier}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bi} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{exp}{tag}{Tag}{\_e88}{\_type}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{exp, \_e88, tag} \rangle$
			}
[
	{$\getvertices{exp}{Expression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{exp} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}
\subsection{Write}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (v:Variable)-[:references]->(r:Reference)-[:node]->(bid:BindingIdentifier),
  (bid)-[:`_type`]->(tag:Tag)

MERGE
  (v)-[:`_type`]->(tag)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\alldifferent{} \Big(\expandout{r}{bid}{BindingIdentifier}{\_e90}{node}{1}{1} \Big(\expandout{v}{r}{Reference}{\_e89}{references}{1}{1} \Big(\getvertices{v}{Variable}
\Big)
\Big)
 \join \expandout{bid}{tag}{Tag}{\_e91}{\_type}{1}{1} \Big(\getvertices{bid}{BindingIdentifier}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v, \_e89, r, \_e90, bid, \_e91, tag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{v, \_e89, r, \_e90, bid, \_e91, tag} \rangle$
			}
[
	{$\expandout{r}{bid}{BindingIdentifier}{\_e90}{node}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v, \_e89, r, \_e90, bid} \rangle$
			}
[
	{$\expandout{v}{r}{Reference}{\_e89}{references}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v, \_e89, r} \rangle$
			}
[
	{$\getvertices{v}{Variable}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{bid}{tag}{Tag}{\_e91}{\_type}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bid, \_e91, tag} \rangle$
			}
[
	{$\getvertices{bid}{BindingIdentifier}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bid} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v, \_e89, r, \_e90, bid, \_e91, tag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{v, \_e89, r, \_e90, bid, \_e91, tag} \rangle$
			}
[
	{$\expandout{r}{bid}{BindingIdentifier}{\_e90}{node}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v, \_e89, r, \_e90, bid} \rangle$
			}
[
	{$\expandout{v}{r}{Reference}{\_e89}{references}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v, \_e89, r} \rangle$
			}
[
	{$\getvertices{v}{Variable}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{bid}{tag}{Tag}{\_e91}{\_type}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bid, \_e91, tag} \rangle$
			}
[
	{$\getvertices{bid}{BindingIdentifier}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bid} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}
\subsection{generatecalls}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
    // Match called FunctionDeclarations for every CallExpression
    (call:CallExpression)-[:callee]->(:IdentifierExpression)
    <-[:node]-(:Reference)<-[:references]-(:Variable)
    -[:declarations]->(:Declaration)-[:node]->(:BindingIdentifier)
    <-[:name]-(fd:FunctionDeclaration)
MATCH
    // List every call from a function body
    (fun:FunctionDeclaration), (call:CallExpression),
    p = shortestPath((fun)-[*]->(call))

MERGE
    // Create a calls relationship between the caller
    // FunctionDeclaration and the called FunctionDeclaration
    (fun)-[:calls]->(fd)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
\subsection{getlastcommithash}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (:MetaInfo)-[:lastCommit]->(c:Commit)
RETURN c.hash as commitHash
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{c.hash}\assign \var{commitHash}} \Big(\alldifferent{} \Big(\expandout{\_e103}{c}{Commit}{\_e104}{lastCommit}{1}{1} \Big(\getvertices{\_e103}{MetaInfo}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.hash}\assign \var{commitHash}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{hash} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e103, \_e104, c} \rangle$
			}
[
	{$\expandout{\_e103}{c}{Commit}{\_e104}{lastCommit}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e103, \_e104, c} \rangle$
			}
[
	{$\getvertices{\_e103}{MetaInfo}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e103} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.hash}\assign \var{commitHash}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{hash} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e103, \_e104, c} \rangle$
			}
[
	{$\expandout{\_e103}{c}{Commit}{\_e104}{lastCommit}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e103, \_e104, c} \rangle$
			}
[
	{$\getvertices{\_e103}{MetaInfo}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e103} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}
\subsection{removefile}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
	( cu:CompilationUnit
		{
			path: {path}
		}
	)-[:contains]-(el)
WHERE
  // iff the provided sessionid parameter is NULL, then delete the fix graph of
  // the CompilationUnit; else delete the temporal one with the given sessionid
     ( {sessionid} IS NULL AND NOT exists(cu.sessionid) )
  OR ( cu.sessionid = {sessionid} )
DETACH DELETE
	cu, el
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
\subsection{setcommithash}

\subsubsection*{Query specification}

\begin{lstlisting}
MERGE (:MetaInfo)-[:lastCommit]->(c:Commit)
SET c.hash = {commithash}
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
\subsection{typing}

\subsubsection*{Query specification}

\begin{lstlisting}
/**
 * Type inferencing
 *
 * Repeat the following steps until either no change occurs in the database or a
 * given repeat limit is reached.
 *
 *  1. Find the literal values and assign type tags to them.
 *  2. Propagate the type information to the Variables in the given Scope for
 *     every VariableDeclaration with initial value. Handle the corner cases.
 *  3. Handle built-in Unary and Binary Expressions.
 *  4. Propagate type information into function calls taking care of in-function
 *     type differentiation based on input types.
 */

/**
 *  1. Find the literal values and assign type tags to them.
 *     - LiteralNumericExpression -> NumberTag
 *     - LiteralStringExpression  -> StringTag
 *     - LiteralBooleanExpression -> BooleanTag
 *     - LiteralNullExpression    -> NullTag
 */

// LiteralNumericExpression -> NumberTag
MATCH (exp:LiteralNumericExpression)
MERGE (exp)-[:type]->(tag:Tag:NumberTag)
SET tag.session = exp.session
;

// LiteralStringExpression  -> StringTag
MATCH (exp:LiteralStringExpression)
MERGE (exp)-[:type]->(tag:Tag:StringTag)
SET tag.session = exp.session
;

// LiteralBooleanExpression -> BooleanTag
MATCH (exp:LiteralBooleanExpression)
MERGE (exp)-[:type]->(tag:Tag:BooleanTag)
SET tag.session = exp.session
;

// LiteralNullExpression    -> NullTag
MATCH (exp:LiteralNullExpression)
MERGE (exp)-[:type]->(tag:Tag:NullTag)
SET tag.session = exp.session
;

/**
 *  2. Propagate the type information to Variables from their VariableDeclaration.
 */

MATCH
    //(vds:VariableDeclarationStatement)-[:declaration]->
    //(vdion:VariableDeclaration)-[declarators]->(vdor)
    (var:Variable)-[:declarations]->
    (dec:Declaration)-[:node]->
    (bi:BindingIdentifier)<-[:binding]-
    (vdor:VariableDeclarator)-[:init]->
    (exp:Expression)-[:type]->
    (type:Tag)
//MERGE
//    (var)-[:type]->(tag:Tag)
//CALL apoc.create.addLabels(tag, labels(type))
WHERE
    NOT (var)-[:type]-(:Tag)-[:from]->(type)
CALL
    apoc.refactor.cloneNodes([type]) YIELD input, output as tag, error
MERGE
    (var)-[:type]->(tag)-[:from]->(type)
//MERGE
//    (tag)-[:from]->(type)
MERGE
    (tag)-[:through]->(vdor)
;


/**
 * Find the VariableDeclarators without initial value and mark them as
 * undefined.
 */

 MATCH
     (var:Variable)-[:declarations]->
     (dec:Declaration)-[:node]->
     (bi:BindingIdentifier)<-[:binding]-
     (vdor:VariableDeclarator)
 WHERE
     NOT (vdor)-[:init]->(:Expression)
 MERGE
     (var)-[:type]->(tag:Tag:UndefinedTag)
 SET
     tag.session = var.session
 MERGE
     (tag)-[:through]->(vdor)
 ;

/**
 * Find ArrayExpressions and tag them.
 */
 // TODO

/**
 * Find ObjectExpressions and tag them.
 */
 // TODO


/**
 *  3. Handle built-in Unary and Binary Expressions.
 */

/**
 * Propagate the Variable type information to the appropriate
 * IdentifierExpression.
 */

MATCH
    (type:Tag)<-[:type]-
    (var:Variable)-[:references]->
    (ref:Reference)-[:node]->
    (exp:Expression)
WHERE
    NOT (exp)-[:type]-(:Tag)-[:from]->(type)
CALL
    apoc.refactor.cloneNodes([type]) YIELD input, output as tag, error
MERGE
    (exp)-[:type]->(tag)-[:from]->(type)
;

/**
 * PLUS binary operator.
 */
MATCH
    (ltag:Tag)<-[:type]-(left:Expression)
    <-[:left]-(exp:BinaryExpression)-[:right]->
    (right:Expression)-[:type]->(rtag:Tag)
WHERE
        exp.operator = 'Plus'
    AND ltag :NumberTag
    AND rtag :NumberTag
MERGE
    (exp)-[:type]->(tag:Tag:NumberTag)
MERGE
    (ltag)<-[:from]-(tag)-[:from]->(rtag)
SET
    tag.session = ltag.session
;
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\alldifferent{} \Big(\getvertices{exp}{LiteralNumericExpression}
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{exp} \rangle$
			}
[
	{$\getvertices{exp}{LiteralNumericExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{exp} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{exp} \rangle$
			}
[
	{$\getvertices{exp}{LiteralNumericExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{exp} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
;
\end{forest}
}
\subsection{unusedfunctions}

\subsubsection*{Query specification}

\begin{lstlisting}
/**
 * Get not used FunctionDeclarations
 */
MATCH
    // Find the exported FunctionDeclaration that may be an entrance point
    p = (main)-[:items]->(:ExportDeclaration)-[:declaration]->(fd:FunctionDeclaration)

MATCH
    // Find every FunctionDeclaration that should be available through the
    // entrance points
    q = (dead:FunctionDeclaration)-[:location]->(span:SourceSpan),
        (start:SourceLocation)<-[:start]-(span)-[:end]->(end:SourceLocation)

WHERE
    // List the ones that are not available (Kleene closure) from the
    // entrance nodes (thus are not the entrance nodes "<>").
        ( NOT (fd)-[:calls*]->(dead) )
    AND ( dead <> fd )
    AND ( main:Script OR main:Module )
    AND ( ALL (
                x in (nodes(p) + nodes(q))
                WHERE NOT exists(x.session) OR x.session = {sessionid}
          ) )

RETURN DISTINCT
    ID(dead) as id, start.line, start.column, end.line, end.column, dead.session
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
