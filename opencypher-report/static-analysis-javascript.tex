\chapter{Static Analysis for JavaScript}
\label{chp:static-analysis-javascript}

\section{Queries}

\subsection{BlockStatement}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (bs:BlockStatement)-[:block]->(b:Block)-[:statements]->(list:List),

  (bs)    -[:`_end`]->  (bsE:End),
  (list)  -[:`_end`]->  (listE:End)

MERGE
  (bs)    -[:`_normal`]-> (list)    -[:`_end`]->
  (listE) -[:`_normal`]-> (bsE)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \alldifferent{} \Big(\expandout{b}{list}{List}{\_e2}{statements}{1}{1} \Big(\expandout{bs}{b}{Block}{\_e1}{block}{1}{1} \Big(\getvertices{bs}{BlockStatement}\Big)\Big) \join \expandout{bs}{bsE}{End}{\_e3}{\_end}{1}{1} \Big(\getvertices{bs}{BlockStatement}\Big) \join \expandout{list}{listE}{End}{\_e4}{\_end}{1}{1} \Big(\getvertices{list}{List}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bs, \_e1, b, \_e2, list, \_e3, bsE, \_e4, listE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{bs, \_e1, b, \_e2, list, \_e3, bsE, \_e4, listE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{bs, \_e1, b, \_e2, list, \_e3, bsE} \rangle$
			}
[
	{$\expandout{b}{list}{List}{\_e2}{statements}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bs, \_e1, b, \_e2, list} \rangle$
			}
[
	{$\expandout{bs}{b}{Block}{\_e1}{block}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bs, \_e1, b} \rangle$
			}
[
	{$\getvertices{bs}{BlockStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bs} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{bs}{bsE}{End}{\_e3}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bs, \_e3, bsE} \rangle$
			}
[
	{$\getvertices{bs}{BlockStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bs} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{list}{listE}{End}{\_e4}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{list, \_e4, listE} \rangle$
			}
[
	{$\getvertices{list}{List}$
			\\
			\footnotesize
			$\color{gray} \langle \var{list} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bs, \_e1, b, \_e2, list, \_e3, bsE, \_e4, listE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{bs, \_e1, b, \_e2, list, \_e3, bsE, \_e4, listE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{bs, \_e1, b, \_e2, list, \_e3, bsE} \rangle$
			}
[
	{$\expandout{b}{list}{List}{\_e2}{statements}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bs, \_e1, b, \_e2, list} \rangle$
			}
[
	{$\expandout{bs}{b}{Block}{\_e1}{block}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bs, \_e1, b} \rangle$
			}
[
	{$\getvertices{bs}{BlockStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bs} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{bs}{bsE}{End}{\_e3}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bs, \_e3, bsE} \rangle$
			}
[
	{$\getvertices{bs}{BlockStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bs} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{list}{listE}{End}{\_e4}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{list, \_e4, listE} \rangle$
			}
[
	{$\getvertices{list}{List}$
			\\
			\footnotesize
			$\color{gray} \langle \var{list} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{Boolean}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (lit:LiteralBooleanExpression),
  (ts:TypeSystem)-[:`_instance`]->(tag:Tag:`Boolean`)

MERGE
  (lit)-[:`_type`]->(tag)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \alldifferent{} \Big(\getvertices{lit}{LiteralBooleanExpression} \join \expandout{ts}{tag}{Tag \land Boolean}{\_e5}{\_instance}{1}{1} \Big(\getvertices{ts}{TypeSystem}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e5, tag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e5, tag} \rangle$
			}
[
	{$\getvertices{lit}{LiteralBooleanExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\expandout{ts}{tag}{Tag \land Boolean}{\_e5}{\_instance}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts, \_e5, tag} \rangle$
			}
[
	{$\getvertices{ts}{TypeSystem}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e5, tag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e5, tag} \rangle$
			}
[
	{$\getvertices{lit}{LiteralBooleanExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\expandout{ts}{tag}{Tag \land Boolean}{\_e5}{\_instance}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts, \_e5, tag} \rangle$
			}
[
	{$\getvertices{ts}{TypeSystem}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{CallExpressionNoParam}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (call:CallExpression)-[:callee]->(:IdentifierExpression)
  <-[:node]-(:Reference)<-[:references]-(:Variable)
  -[:declarations]->(:Declaration)-[:node]->(:BindingIdentifier)
  <-[:name]-(fd:FunctionDeclaration),

  (call)    -[:`_end`]->  (callE:End),
  (fd)      -[:`_end`]->  (fdE:End)

WHERE
  NOT (call)-[:arguments]->()

MERGE
  (call)    -[:`_normal`]-> (fd)      -[:`_end`]->
  (fdE)     -[:`_normal`]-> (callE)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{CallExpressionParam}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (arguments:List) <-[:arguments]- (callExp:CallExpression) -[:callee]->
  (:IdentifierExpression) <-[:`node`]- (:Reference) <-[:references]-
  (:Variable) -[:declarations]-> (:Declaration) -[:`node`]->
  (:BindingIdentifier) <-[:name]- (fd:FunctionDeclaration) -[:params]->
  (:FormalParameters) -[:items]-> (params:List),

  (callExp)     -[:`_end`]->  (callExpE:`End`),
  (fd)          -[:`_end`]->  (fdE:`End`),
  (arguments)   -[:`_end`]->  (argumentsE:`End`)

MERGE
  (callExp)     -[:`_normal`]-> (arguments) -[:`_end`]->
  (argumentsE)  -[:`_normal`]-> (fd)        -[:`_end`]->
  (fdE)         -[:`_normal`]-> (callExpE)

\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \alldifferent{} \Big(\expandout{\_e31}{params}{List}{\_e33}{items}{1}{1} \Big(\expandout{fd}{\_e31}{FormalParameters}{\_e32}{params}{1}{1} \Big(\expandin{\_e28}{fd}{FunctionDeclaration}{\_e30}{name}{1}{1} \Big(\expandout{\_e26}{\_e28}{BindingIdentifier}{\_e29}{node}{1}{1} \Big(\expandout{\_e24}{\_e26}{Declaration}{\_e27}{declarations}{1}{1} \Big(\expandin{\_e22}{\_e24}{Variable}{\_e25}{references}{1}{1} \Big(\expandin{\_e20}{\_e22}{Reference}{\_e23}{node}{1}{1} \Big(\expandout{callExp}{\_e20}{IdentifierExpression}{\_e21}{callee}{1}{1} \Big(\expandin{arguments}{callExp}{CallExpression}{\_e19}{arguments}{1}{1} \Big(\getvertices{arguments}{List}\Big)\Big)\Big)\Big)\Big)\Big)\Big)\Big)\Big) \join \expandout{callExp}{callExpE}{End}{\_e34}{\_end}{1}{1} \Big(\getvertices{callExp}{CallExpression}\Big) \join \expandout{fd}{fdE}{End}{\_e35}{\_end}{1}{1} \Big(\getvertices{fd}{FunctionDeclaration}\Big) \join \expandout{arguments}{argumentsE}{End}{\_e36}{\_end}{1}{1} \Big(\getvertices{arguments}{List}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e19, callExp, \_e21, \_e20, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26, \_e29, \_e28, \_e30, fd, \_e32, \_e31, \_e33, params, \_e34, callExpE, \_e35, fdE, \_e36, argumentsE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e19, callExp, \_e21, \_e20, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26, \_e29, \_e28, \_e30, fd, \_e32, \_e31, \_e33, params, \_e34, callExpE, \_e35, fdE, \_e36, argumentsE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e19, callExp, \_e21, \_e20, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26, \_e29, \_e28, \_e30, fd, \_e32, \_e31, \_e33, params, \_e34, callExpE, \_e35, fdE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e19, callExp, \_e21, \_e20, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26, \_e29, \_e28, \_e30, fd, \_e32, \_e31, \_e33, params, \_e34, callExpE} \rangle$
			}
[
	{$\expandout{\_e31}{params}{List}{\_e33}{items}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e19, callExp, \_e21, \_e20, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26, \_e29, \_e28, \_e30, fd, \_e32, \_e31, \_e33, params} \rangle$
			}
[
	{$\expandout{fd}{\_e31}{FormalParameters}{\_e32}{params}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e19, callExp, \_e21, \_e20, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26, \_e29, \_e28, \_e30, fd, \_e32, \_e31} \rangle$
			}
[
	{$\expandin{\_e28}{fd}{FunctionDeclaration}{\_e30}{name}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e19, callExp, \_e21, \_e20, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26, \_e29, \_e28, \_e30, fd} \rangle$
			}
[
	{$\expandout{\_e26}{\_e28}{BindingIdentifier}{\_e29}{node}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e19, callExp, \_e21, \_e20, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26, \_e29, \_e28} \rangle$
			}
[
	{$\expandout{\_e24}{\_e26}{Declaration}{\_e27}{declarations}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e19, callExp, \_e21, \_e20, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26} \rangle$
			}
[
	{$\expandin{\_e22}{\_e24}{Variable}{\_e25}{references}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e19, callExp, \_e21, \_e20, \_e23, \_e22, \_e25, \_e24} \rangle$
			}
[
	{$\expandin{\_e20}{\_e22}{Reference}{\_e23}{node}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e19, callExp, \_e21, \_e20, \_e23, \_e22} \rangle$
			}
[
	{$\expandout{callExp}{\_e20}{IdentifierExpression}{\_e21}{callee}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e19, callExp, \_e21, \_e20} \rangle$
			}
[
	{$\expandin{arguments}{callExp}{CallExpression}{\_e19}{arguments}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e19, callExp} \rangle$
			}
[
	{$\getvertices{arguments}{List}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
]
]
]
]
[
	{$\expandout{callExp}{callExpE}{End}{\_e34}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{callExp, \_e34, callExpE} \rangle$
			}
[
	{$\getvertices{callExp}{CallExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{callExp} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{fd}{fdE}{End}{\_e35}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd, \_e35, fdE} \rangle$
			}
[
	{$\getvertices{fd}{FunctionDeclaration}$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{arguments}{argumentsE}{End}{\_e36}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e36, argumentsE} \rangle$
			}
[
	{$\getvertices{arguments}{List}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e19, callExp, \_e21, \_e20, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26, \_e29, \_e28, \_e30, fd, \_e32, \_e31, \_e33, params, \_e34, callExpE, \_e35, fdE, \_e36, argumentsE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e19, callExp, \_e21, \_e20, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26, \_e29, \_e28, \_e30, fd, \_e32, \_e31, \_e33, params, \_e34, callExpE, \_e35, fdE, \_e36, argumentsE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e19, callExp, \_e21, \_e20, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26, \_e29, \_e28, \_e30, fd, \_e32, \_e31, \_e33, params, \_e34, callExpE, \_e35, fdE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e19, callExp, \_e21, \_e20, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26, \_e29, \_e28, \_e30, fd, \_e32, \_e31, \_e33, params, \_e34, callExpE} \rangle$
			}
[
	{$\expandout{\_e31}{params}{List}{\_e33}{items}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e19, callExp, \_e21, \_e20, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26, \_e29, \_e28, \_e30, fd, \_e32, \_e31, \_e33, params} \rangle$
			}
[
	{$\expandout{fd}{\_e31}{FormalParameters}{\_e32}{params}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e19, callExp, \_e21, \_e20, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26, \_e29, \_e28, \_e30, fd, \_e32, \_e31} \rangle$
			}
[
	{$\expandin{\_e28}{fd}{FunctionDeclaration}{\_e30}{name}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e19, callExp, \_e21, \_e20, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26, \_e29, \_e28, \_e30, fd} \rangle$
			}
[
	{$\expandout{\_e26}{\_e28}{BindingIdentifier}{\_e29}{node}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e19, callExp, \_e21, \_e20, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26, \_e29, \_e28} \rangle$
			}
[
	{$\expandout{\_e24}{\_e26}{Declaration}{\_e27}{declarations}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e19, callExp, \_e21, \_e20, \_e23, \_e22, \_e25, \_e24, \_e27, \_e26} \rangle$
			}
[
	{$\expandin{\_e22}{\_e24}{Variable}{\_e25}{references}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e19, callExp, \_e21, \_e20, \_e23, \_e22, \_e25, \_e24} \rangle$
			}
[
	{$\expandin{\_e20}{\_e22}{Reference}{\_e23}{node}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e19, callExp, \_e21, \_e20, \_e23, \_e22} \rangle$
			}
[
	{$\expandout{callExp}{\_e20}{IdentifierExpression}{\_e21}{callee}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e19, callExp, \_e21, \_e20} \rangle$
			}
[
	{$\expandin{arguments}{callExp}{CallExpression}{\_e19}{arguments}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e19, callExp} \rangle$
			}
[
	{$\getvertices{arguments}{List}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
]
]
]
]
[
	{$\expandout{callExp}{callExpE}{End}{\_e34}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{callExp, \_e34, callExpE} \rangle$
			}
[
	{$\getvertices{callExp}{CallExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{callExp} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{fd}{fdE}{End}{\_e35}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd, \_e35, fdE} \rangle$
			}
[
	{$\getvertices{fd}{FunctionDeclaration}$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{arguments}{argumentsE}{End}{\_e36}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments, \_e36, argumentsE} \rangle$
			}
[
	{$\getvertices{arguments}{List}$
			\\
			\footnotesize
			$\color{gray} \langle \var{arguments} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{ExpressionStatement}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (es:ExpressionStatement)-[:expression]->(exp:Expression),

  (es)  -[:`_end`]->  (esE:End),
  (exp) -[:`_end`]->  (expE:End)

MERGE
  (es)    -[:`_normal`]-> (exp)   -[:`_end`]->
  (expE)  -[:`_normal`]-> (esE)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \alldifferent{} \Big(\expandout{es}{exp}{Expression}{\_e37}{expression}{1}{1} \Big(\getvertices{es}{ExpressionStatement}\Big) \join \expandout{es}{esE}{End}{\_e38}{\_end}{1}{1} \Big(\getvertices{es}{ExpressionStatement}\Big) \join \expandout{exp}{expE}{End}{\_e39}{\_end}{1}{1} \Big(\getvertices{exp}{Expression}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{es, \_e37, exp, \_e38, esE, \_e39, expE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{es, \_e37, exp, \_e38, esE, \_e39, expE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{es, \_e37, exp, \_e38, esE} \rangle$
			}
[
	{$\expandout{es}{exp}{Expression}{\_e37}{expression}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{es, \_e37, exp} \rangle$
			}
[
	{$\getvertices{es}{ExpressionStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{es} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\expandout{es}{esE}{End}{\_e38}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{es, \_e38, esE} \rangle$
			}
[
	{$\getvertices{es}{ExpressionStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{es} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{exp}{expE}{End}{\_e39}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{exp, \_e39, expE} \rangle$
			}
[
	{$\getvertices{exp}{Expression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{exp} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{es, \_e37, exp, \_e38, esE, \_e39, expE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{es, \_e37, exp, \_e38, esE, \_e39, expE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{es, \_e37, exp, \_e38, esE} \rangle$
			}
[
	{$\expandout{es}{exp}{Expression}{\_e37}{expression}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{es, \_e37, exp} \rangle$
			}
[
	{$\getvertices{es}{ExpressionStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{es} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\expandout{es}{esE}{End}{\_e38}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{es, \_e38, esE} \rangle$
			}
[
	{$\getvertices{es}{ExpressionStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{es} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{exp}{expE}{End}{\_e39}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{exp, \_e39, expE} \rangle$
			}
[
	{$\getvertices{exp}{Expression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{exp} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{FunctionDeclaration}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (fd:FunctionDeclaration)-[:body]->(b:FunctionBody)-[:statements]->(list:List),

  (fd)    -[:`_end`]->  (fdE:End),
  (list)  -[:`_end`]->  (listE:End)

MERGE
  (fd)    -[:`_normal`]-> (list)    -[:`_end`]->
  (listE) -[:`_normal`]-> (fdE)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \alldifferent{} \Big(\expandout{b}{list}{List}{\_e41}{statements}{1}{1} \Big(\expandout{fd}{b}{FunctionBody}{\_e40}{body}{1}{1} \Big(\getvertices{fd}{FunctionDeclaration}\Big)\Big) \join \expandout{fd}{fdE}{End}{\_e42}{\_end}{1}{1} \Big(\getvertices{fd}{FunctionDeclaration}\Big) \join \expandout{list}{listE}{End}{\_e43}{\_end}{1}{1} \Big(\getvertices{list}{List}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd, \_e40, b, \_e41, list, \_e42, fdE, \_e43, listE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd, \_e40, b, \_e41, list, \_e42, fdE, \_e43, listE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd, \_e40, b, \_e41, list, \_e42, fdE} \rangle$
			}
[
	{$\expandout{b}{list}{List}{\_e41}{statements}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd, \_e40, b, \_e41, list} \rangle$
			}
[
	{$\expandout{fd}{b}{FunctionBody}{\_e40}{body}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd, \_e40, b} \rangle$
			}
[
	{$\getvertices{fd}{FunctionDeclaration}$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{fd}{fdE}{End}{\_e42}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd, \_e42, fdE} \rangle$
			}
[
	{$\getvertices{fd}{FunctionDeclaration}$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{list}{listE}{End}{\_e43}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{list, \_e43, listE} \rangle$
			}
[
	{$\getvertices{list}{List}$
			\\
			\footnotesize
			$\color{gray} \langle \var{list} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd, \_e40, b, \_e41, list, \_e42, fdE, \_e43, listE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd, \_e40, b, \_e41, list, \_e42, fdE, \_e43, listE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd, \_e40, b, \_e41, list, \_e42, fdE} \rangle$
			}
[
	{$\expandout{b}{list}{List}{\_e41}{statements}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd, \_e40, b, \_e41, list} \rangle$
			}
[
	{$\expandout{fd}{b}{FunctionBody}{\_e40}{body}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd, \_e40, b} \rangle$
			}
[
	{$\getvertices{fd}{FunctionDeclaration}$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{fd}{fdE}{End}{\_e42}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd, \_e42, fdE} \rangle$
			}
[
	{$\getvertices{fd}{FunctionDeclaration}$
			\\
			\footnotesize
			$\color{gray} \langle \var{fd} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{list}{listE}{End}{\_e43}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{list, \_e43, listE} \rangle$
			}
[
	{$\getvertices{list}{List}$
			\\
			\footnotesize
			$\color{gray} \langle \var{list} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{IfStatementAlternate}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (test:Node)<-[:test]-(if:IfStatement)-[:consequent]->(consequent:Node),
  (if)-[:alternate]->(alternate:Statement),

  (alternate)   -[:`_end`]->    (alternateE:End),

  (if)          -[:`_end`]->  (ifE:End),
  (test)        -[:`_end`]->  (testE:End),
  (consequent)  -[:`_end`]->  (consequentE:End)

MERGE
  (if)          -[:`_normal`]-> (test)        -[:`_end`]->
  (testE)       -[:`_true`]->   (consequent)  -[:`_end`]->
  (consequentE) -[:`_normal`]-> (ifE)

MERGE
  (testE)       -[:`_false`]->  (alternate)   -[:`_end`]->
  (alternateE)  -[:`_normal`]-> (ifE)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \alldifferent{} \Big(\expandout{if}{consequent}{Node}{\_e45}{consequent}{1}{1} \Big(\expandin{test}{if}{IfStatement}{\_e44}{test}{1}{1} \Big(\getvertices{test}{Node}\Big)\Big) \join \expandout{if}{alternate}{Statement}{\_e46}{alternate}{1}{1} \Big(\getvertices{if}{IfStatement}\Big) \join \expandout{alternate}{alternateE}{End}{\_e47}{\_end}{1}{1} \Big(\getvertices{alternate}{Statement}\Big) \join \expandout{if}{ifE}{End}{\_e48}{\_end}{1}{1} \Big(\getvertices{if}{IfStatement}\Big) \join \expandout{test}{testE}{End}{\_e49}{\_end}{1}{1} \Big(\getvertices{test}{Node}\Big) \join \expandout{consequent}{consequentE}{End}{\_e50}{\_end}{1}{1} \Big(\getvertices{consequent}{Node}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e44, if, \_e45, consequent, \_e46, alternate, \_e47, alternateE, \_e48, ifE, \_e49, testE, \_e50, consequentE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e44, if, \_e45, consequent, \_e46, alternate, \_e47, alternateE, \_e48, ifE, \_e49, testE, \_e50, consequentE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e44, if, \_e45, consequent, \_e46, alternate, \_e47, alternateE, \_e48, ifE, \_e49, testE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e44, if, \_e45, consequent, \_e46, alternate, \_e47, alternateE, \_e48, ifE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e44, if, \_e45, consequent, \_e46, alternate, \_e47, alternateE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e44, if, \_e45, consequent, \_e46, alternate} \rangle$
			}
[
	{$\expandout{if}{consequent}{Node}{\_e45}{consequent}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e44, if, \_e45, consequent} \rangle$
			}
[
	{$\expandin{test}{if}{IfStatement}{\_e44}{test}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e44, if} \rangle$
			}
[
	{$\getvertices{test}{Node}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{if}{alternate}{Statement}{\_e46}{alternate}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{if, \_e46, alternate} \rangle$
			}
[
	{$\getvertices{if}{IfStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{if} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{alternate}{alternateE}{End}{\_e47}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{alternate, \_e47, alternateE} \rangle$
			}
[
	{$\getvertices{alternate}{Statement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{alternate} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{if}{ifE}{End}{\_e48}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{if, \_e48, ifE} \rangle$
			}
[
	{$\getvertices{if}{IfStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{if} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{test}{testE}{End}{\_e49}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e49, testE} \rangle$
			}
[
	{$\getvertices{test}{Node}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{consequent}{consequentE}{End}{\_e50}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{consequent, \_e50, consequentE} \rangle$
			}
[
	{$\getvertices{consequent}{Node}$
			\\
			\footnotesize
			$\color{gray} \langle \var{consequent} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e44, if, \_e45, consequent, \_e46, alternate, \_e47, alternateE, \_e48, ifE, \_e49, testE, \_e50, consequentE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e44, if, \_e45, consequent, \_e46, alternate, \_e47, alternateE, \_e48, ifE, \_e49, testE, \_e50, consequentE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e44, if, \_e45, consequent, \_e46, alternate, \_e47, alternateE, \_e48, ifE, \_e49, testE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e44, if, \_e45, consequent, \_e46, alternate, \_e47, alternateE, \_e48, ifE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e44, if, \_e45, consequent, \_e46, alternate, \_e47, alternateE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e44, if, \_e45, consequent, \_e46, alternate} \rangle$
			}
[
	{$\expandout{if}{consequent}{Node}{\_e45}{consequent}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e44, if, \_e45, consequent} \rangle$
			}
[
	{$\expandin{test}{if}{IfStatement}{\_e44}{test}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e44, if} \rangle$
			}
[
	{$\getvertices{test}{Node}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{if}{alternate}{Statement}{\_e46}{alternate}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{if, \_e46, alternate} \rangle$
			}
[
	{$\getvertices{if}{IfStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{if} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{alternate}{alternateE}{End}{\_e47}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{alternate, \_e47, alternateE} \rangle$
			}
[
	{$\getvertices{alternate}{Statement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{alternate} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{if}{ifE}{End}{\_e48}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{if, \_e48, ifE} \rangle$
			}
[
	{$\getvertices{if}{IfStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{if} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{test}{testE}{End}{\_e49}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test, \_e49, testE} \rangle$
			}
[
	{$\getvertices{test}{Node}$
			\\
			\footnotesize
			$\color{gray} \langle \var{test} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{consequent}{consequentE}{End}{\_e50}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{consequent, \_e50, consequentE} \rangle$
			}
[
	{$\getvertices{consequent}{Node}$
			\\
			\footnotesize
			$\color{gray} \langle \var{consequent} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{IfStatementNoAlternate}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (test:Node)<-[:test]-(if:IfStatement)-[:consequent]->(consequent:Node),

  (if)          -[:`_end`]->  (ifE:End),
  (test)        -[:`_end`]->  (testE:End),
  (consequent)  -[:`_end`]->  (consequentE:End)

WHERE
  NOT (if)-[:alternate]->(:Statement)

MERGE
  (if)	        -[:`_normal`]-> (test)       -[:`_end`]->
  (testE)       -[:`_true`]->   (consequent) -[:`_end`]->
  (consequentE)	-[:`_normal`]-> (ifE)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Infinity}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (lit:LiteralInfinityExpression),
  (ts:TypeSystem)-[:`_instance`]->(tag:Tag:`Infinity`)

MERGE
  (lit)-[:`_type`]->(tag)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \alldifferent{} \Big(\getvertices{lit}{LiteralInfinityExpression} \join \expandout{ts}{tag}{Tag \land Infinity}{\_e56}{\_instance}{1}{1} \Big(\getvertices{ts}{TypeSystem}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e56, tag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e56, tag} \rangle$
			}
[
	{$\getvertices{lit}{LiteralInfinityExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\expandout{ts}{tag}{Tag \land Infinity}{\_e56}{\_instance}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts, \_e56, tag} \rangle$
			}
[
	{$\getvertices{ts}{TypeSystem}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e56, tag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e56, tag} \rangle$
			}
[
	{$\getvertices{lit}{LiteralInfinityExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\expandout{ts}{tag}{Tag \land Infinity}{\_e56}{\_instance}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts, \_e56, tag} \rangle$
			}
[
	{$\getvertices{ts}{TypeSystem}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{ListNoItem}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (l:List),

  (l)     -[:`_end`]->  (lE:End)

WHERE
  NOT (l)-[:`0`]->()

MERGE
  (l)     -[:`_normal`]-> (lE)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{ListWithItem}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (l:List)-[:`0`]->(first),
  (l)-[:last]->(last),

  (l)     -[:`_end`]->  (lE:End),
  (last)  -[:`_end`]->  (lastE:End)

MERGE (l)     -[:`_normal`]-> (first)
MERGE (lastE) -[:`_normal`]-> (lE)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \alldifferent{} \Big(\expandout{l}{first}{}{\_e58}{\_e59}{1}{1} \Big(\getvertices{l}{List}\Big) \join \expandout{l}{last}{}{\_e60}{last}{1}{1} \Big(\getvertices{l}{List}\Big) \join \expandout{l}{lE}{End}{\_e61}{\_end}{1}{1} \Big(\getvertices{l}{List}\Big) \join \expandout{last}{lastE}{End}{\_e62}{\_end}{1}{1} \Big(\getvertices{last}{}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{l, \_e58, first, \_e60, last, \_e61, lE, \_e62, lastE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{l, \_e58, first, \_e60, last, \_e61, lE, \_e62, lastE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{l, \_e58, first, \_e60, last, \_e61, lE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{l, \_e58, first, \_e60, last} \rangle$
			}
[
	{$\expandout{l}{first}{}{\_e58}{\_e59}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{l, \_e58, first} \rangle$
			}
[
	{$\getvertices{l}{List}$
			\\
			\footnotesize
			$\color{gray} \langle \var{l} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\expandout{l}{last}{}{\_e60}{last}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{l, \_e60, last} \rangle$
			}
[
	{$\getvertices{l}{List}$
			\\
			\footnotesize
			$\color{gray} \langle \var{l} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{l}{lE}{End}{\_e61}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{l, \_e61, lE} \rangle$
			}
[
	{$\getvertices{l}{List}$
			\\
			\footnotesize
			$\color{gray} \langle \var{l} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{last}{lastE}{End}{\_e62}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{last, \_e62, lastE} \rangle$
			}
[
	{$\getvertices{last}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{last} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{l, \_e58, first, \_e60, last, \_e61, lE, \_e62, lastE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{l, \_e58, first, \_e60, last, \_e61, lE, \_e62, lastE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{l, \_e58, first, \_e60, last, \_e61, lE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{l, \_e58, first, \_e60, last} \rangle$
			}
[
	{$\expandout{l}{first}{}{\_e58}{\_e59}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{l, \_e58, first} \rangle$
			}
[
	{$\getvertices{l}{List}$
			\\
			\footnotesize
			$\color{gray} \langle \var{l} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\expandout{l}{last}{}{\_e60}{last}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{l, \_e60, last} \rangle$
			}
[
	{$\getvertices{l}{List}$
			\\
			\footnotesize
			$\color{gray} \langle \var{l} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{l}{lE}{End}{\_e61}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{l, \_e61, lE} \rangle$
			}
[
	{$\getvertices{l}{List}$
			\\
			\footnotesize
			$\color{gray} \langle \var{l} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{last}{lastE}{End}{\_e62}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{last, \_e62, lastE} \rangle$
			}
[
	{$\getvertices{last}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{last} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{LiteralX}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (le:Literal)  -[:`_end`]->  (leE:End)
MERGE (le)    -[:`_normal`]-> (leE)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \alldifferent{} \Big(\expandout{le}{leE}{End}{\_e63}{\_end}{1}{1} \Big(\getvertices{le}{Literal}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{le, \_e63, leE} \rangle$
			}
[
	{$\expandout{le}{leE}{End}{\_e63}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{le, \_e63, leE} \rangle$
			}
[
	{$\getvertices{le}{Literal}$
			\\
			\footnotesize
			$\color{gray} \langle \var{le} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{le, \_e63, leE} \rangle$
			}
[
	{$\expandout{le}{leE}{End}{\_e63}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{le, \_e63, leE} \rangle$
			}
[
	{$\getvertices{le}{Literal}$
			\\
			\footnotesize
			$\color{gray} \langle \var{le} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{LogicalOr}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (ltag:Tag)<-[:`_type`]-(left:Expression)
  <-[:left]-(exp:BinaryExpression)-[:right]->
  (right:Expression)-[:`_type`]->(rtag:Tag),

  (ts:TypeSystem)-[:`_instance`]->(btag:Tag:`Boolean`)

WHERE
  exp.operator = 'LogicalOr'

MERGE (exp)-[:`_type`]->(rtag)
MERGE (exp)-[:`_type`]->(ltag)
MERGE (exp)-[:`_type`]->(btag)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \selection{\var{exp.operator} = \literal{''LogicalOr''}} \Big(\alldifferent{} \Big(\expandout{right}{rtag}{Tag}{\_e67}{\_type}{1}{1} \Big(\expandout{exp}{right}{Expression}{\_e66}{right}{1}{1} \Big(\expandin{left}{exp}{BinaryExpression}{\_e65}{left}{1}{1} \Big(\expandin{ltag}{left}{Expression}{\_e64}{\_type}{1}{1} \Big(\getvertices{ltag}{Tag}\Big)\Big)\Big)\Big) \join \expandout{ts}{btag}{Tag \land Boolean}{\_e68}{\_instance}{1}{1} \Big(\getvertices{ts}{TypeSystem}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\selection{\var{exp.operator} = \literal{''LogicalOr''}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ltag, \_e64, left, \_e65, exp, \_e66, right, \_e67, rtag, ts, \_e68, btag} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ltag, \_e64, left, \_e65, exp, \_e66, right, \_e67, rtag, ts, \_e68, btag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{ltag, \_e64, left, \_e65, exp, \_e66, right, \_e67, rtag, ts, \_e68, btag} \rangle$
			}
[
	{$\expandout{right}{rtag}{Tag}{\_e67}{\_type}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ltag, \_e64, left, \_e65, exp, \_e66, right, \_e67, rtag} \rangle$
			}
[
	{$\expandout{exp}{right}{Expression}{\_e66}{right}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ltag, \_e64, left, \_e65, exp, \_e66, right} \rangle$
			}
[
	{$\expandin{left}{exp}{BinaryExpression}{\_e65}{left}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ltag, \_e64, left, \_e65, exp} \rangle$
			}
[
	{$\expandin{ltag}{left}{Expression}{\_e64}{\_type}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ltag, \_e64, left} \rangle$
			}
[
	{$\getvertices{ltag}{Tag}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ltag} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
[
	{$\expandout{ts}{btag}{Tag \land Boolean}{\_e68}{\_instance}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts, \_e68, btag} \rangle$
			}
[
	{$\getvertices{ts}{TypeSystem}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\selection{\var{exp.operator} = \literal{''LogicalOr''}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ltag, \_e64, left, \_e65, exp, \_e66, right, \_e67, rtag, ts, \_e68, btag} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ltag, \_e64, left, \_e65, exp, \_e66, right, \_e67, rtag, ts, \_e68, btag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{ltag, \_e64, left, \_e65, exp, \_e66, right, \_e67, rtag, ts, \_e68, btag} \rangle$
			}
[
	{$\expandout{right}{rtag}{Tag}{\_e67}{\_type}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ltag, \_e64, left, \_e65, exp, \_e66, right, \_e67, rtag} \rangle$
			}
[
	{$\expandout{exp}{right}{Expression}{\_e66}{right}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ltag, \_e64, left, \_e65, exp, \_e66, right} \rangle$
			}
[
	{$\expandin{left}{exp}{BinaryExpression}{\_e65}{left}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ltag, \_e64, left, \_e65, exp} \rangle$
			}
[
	{$\expandin{ltag}{left}{Expression}{\_e64}{\_type}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ltag, \_e64, left} \rangle$
			}
[
	{$\getvertices{ltag}{Tag}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ltag} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
[
	{$\expandout{ts}{btag}{Tag \land Boolean}{\_e68}{\_instance}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts, \_e68, btag} \rangle$
			}
[
	{$\getvertices{ts}{TypeSystem}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Null}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (lit:LiteralNullExpression),
  (ts:TypeSystem)-[:`_instance`]->(tag:Tag:`Null`)

MERGE
  (lit)-[:`_type`]->(tag)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \alldifferent{} \Big(\getvertices{lit}{LiteralNullExpression} \join \expandout{ts}{tag}{Tag \land Null}{\_e69}{\_instance}{1}{1} \Big(\getvertices{ts}{TypeSystem}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e69, tag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e69, tag} \rangle$
			}
[
	{$\getvertices{lit}{LiteralNullExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\expandout{ts}{tag}{Tag \land Null}{\_e69}{\_instance}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts, \_e69, tag} \rangle$
			}
[
	{$\getvertices{ts}{TypeSystem}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e69, tag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e69, tag} \rangle$
			}
[
	{$\getvertices{lit}{LiteralNullExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\expandout{ts}{tag}{Tag \land Null}{\_e69}{\_instance}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts, \_e69, tag} \rangle$
			}
[
	{$\getvertices{ts}{TypeSystem}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{Numeric}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (lit:LiteralNumericExpression),
  (ts:TypeSystem)-[:`_instance`]->(tag:Tag:`Number`)

MERGE
  (lit)-[:`_type`]->(tag)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \alldifferent{} \Big(\getvertices{lit}{LiteralNumericExpression} \join \expandout{ts}{tag}{Tag \land Number}{\_e70}{\_instance}{1}{1} \Big(\getvertices{ts}{TypeSystem}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e70, tag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e70, tag} \rangle$
			}
[
	{$\getvertices{lit}{LiteralNumericExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\expandout{ts}{tag}{Tag \land Number}{\_e70}{\_instance}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts, \_e70, tag} \rangle$
			}
[
	{$\getvertices{ts}{TypeSystem}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e70, tag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e70, tag} \rangle$
			}
[
	{$\getvertices{lit}{LiteralNumericExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\expandout{ts}{tag}{Tag \land Number}{\_e70}{\_instance}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts, \_e70, tag} \rangle$
			}
[
	{$\getvertices{ts}{TypeSystem}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{Read}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (v:Variable)-[:references]->(r:Reference)-[:node]->(ide:IdentifierExpression),
  (v)-[:`_type`]->(tag:Tag)

MERGE
  (ide)-[:`_type`]->(tag)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \alldifferent{} \Big(\expandout{r}{ide}{IdentifierExpression}{\_e72}{node}{1}{1} \Big(\expandout{v}{r}{Reference}{\_e71}{references}{1}{1} \Big(\getvertices{v}{Variable}\Big)\Big) \join \expandout{v}{tag}{Tag}{\_e73}{\_type}{1}{1} \Big(\getvertices{v}{Variable}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v, \_e71, r, \_e72, ide, \_e73, tag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{v, \_e71, r, \_e72, ide, \_e73, tag} \rangle$
			}
[
	{$\expandout{r}{ide}{IdentifierExpression}{\_e72}{node}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v, \_e71, r, \_e72, ide} \rangle$
			}
[
	{$\expandout{v}{r}{Reference}{\_e71}{references}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v, \_e71, r} \rangle$
			}
[
	{$\getvertices{v}{Variable}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{v}{tag}{Tag}{\_e73}{\_type}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v, \_e73, tag} \rangle$
			}
[
	{$\getvertices{v}{Variable}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v, \_e71, r, \_e72, ide, \_e73, tag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{v, \_e71, r, \_e72, ide, \_e73, tag} \rangle$
			}
[
	{$\expandout{r}{ide}{IdentifierExpression}{\_e72}{node}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v, \_e71, r, \_e72, ide} \rangle$
			}
[
	{$\expandout{v}{r}{Reference}{\_e71}{references}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v, \_e71, r} \rangle$
			}
[
	{$\getvertices{v}{Variable}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{v}{tag}{Tag}{\_e73}{\_type}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v, \_e73, tag} \rangle$
			}
[
	{$\getvertices{v}{Variable}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{RegExp}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (lit:LiteralRegExpExpression),
  (ts:TypeSystem)-[:`_instance`]->(tag:Tag:`RegExp`)

MERGE
  (lit)-[:`_type`]->(tag)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \alldifferent{} \Big(\getvertices{lit}{LiteralRegExpExpression} \join \expandout{ts}{tag}{Tag \land RegExp}{\_e74}{\_instance}{1}{1} \Big(\getvertices{ts}{TypeSystem}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e74, tag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e74, tag} \rangle$
			}
[
	{$\getvertices{lit}{LiteralRegExpExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\expandout{ts}{tag}{Tag \land RegExp}{\_e74}{\_instance}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts, \_e74, tag} \rangle$
			}
[
	{$\getvertices{ts}{TypeSystem}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e74, tag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e74, tag} \rangle$
			}
[
	{$\getvertices{lit}{LiteralRegExpExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\expandout{ts}{tag}{Tag \land RegExp}{\_e74}{\_instance}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts, \_e74, tag} \rangle$
			}
[
	{$\getvertices{ts}{TypeSystem}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{String}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (lit:LiteralStringExpression),
  (ts:TypeSystem)-[:`_instance`]->(tag:Tag:`String`)

MERGE
  (lit)-[:`_type`]->(tag)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \alldifferent{} \Big(\getvertices{lit}{LiteralStringExpression} \join \expandout{ts}{tag}{Tag \land String}{\_e75}{\_instance}{1}{1} \Big(\getvertices{ts}{TypeSystem}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e75, tag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e75, tag} \rangle$
			}
[
	{$\getvertices{lit}{LiteralStringExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\expandout{ts}{tag}{Tag \land String}{\_e75}{\_instance}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts, \_e75, tag} \rangle$
			}
[
	{$\getvertices{ts}{TypeSystem}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e75, tag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit, ts, \_e75, tag} \rangle$
			}
[
	{$\getvertices{lit}{LiteralStringExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{lit} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\expandout{ts}{tag}{Tag \land String}{\_e75}{\_instance}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts, \_e75, tag} \rangle$
			}
[
	{$\getvertices{ts}{TypeSystem}$
			\\
			\footnotesize
			$\color{gray} \langle \var{ts} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{TypeSystem}

\subsubsection*{Query specification}

\begin{lstlisting}
MERGE (ts:TypeSystem)

MERGE (ts)-[:`_instance`]->(:Tag:`Undefined`)
MERGE (ts)-[:`_instance`]->(:Tag:`Null`)
MERGE (ts)-[:`_instance`]->(:Tag:`Boolean`)
MERGE (ts)-[:`_instance`]->(:Tag:`Number`)
MERGE (ts)-[:`_instance`]->(:Tag:`String:`)
MERGE (ts)-[:`_instance`]->(:Tag:`Symbol`)
MERGE (ts)-[:`_instance`]->(:Tag:`Object`)
MERGE (ts)-[:`_instance`]->(:Tag:`Function`)
MERGE (ts)-[:`_instance`]->(:Tag:`Error`)

MERGE (ts)-[:`_instance`]->(:Tag:`Math`)
MERGE (ts)-[:`_instance`]->(:Tag:`Date`)
MERGE (ts)-[:`_instance`]->(:Tag:`RegExp`)
MERGE (ts)-[:`_instance`]->(:Tag:`Array`)
MERGE (ts)-[:`_instance`]->(:Tag:`Map`)
MERGE (ts)-[:`_instance`]->(:Tag:`Set`)
MERGE (ts)-[:`_instance`]->(:Tag:`JSON`)
MERGE (ts)-[:`_instance`]->(:Tag:`ArrayBuffer`)
MERGE (ts)-[:`_instance`]->(:Tag:`DataView`)
MERGE (ts)-[:`_instance`]->(:Tag:`Promise`)
MERGE (ts)-[:`_instance`]->(:Tag:`Proxy`)
MERGE (ts)-[:`_instance`]->(:Tag:`Reflect`)


MERGE (ts)-[:`_instance`]->(:Tag:`Infinity`)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{VariableDeclarationStatement}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (vds:VariableDeclarationStatement)-[:declaration]->(vdion:VariableDeclaration)
  -[:declarators]->(vdor:VariableDeclarator)-[:init]->(exp:Expression),

  (vds)     -[:`_end`]->  (vdsE:End),
  (vdion)   -[:`_end`]->  (vdionE:End),
  (exp)     -[:`_end`]->  (expE:End)

MERGE (vdion)   -[:`_normal`]-> (vdionE)

MERGE
  (vds)     -[:`_normal`]-> (exp)   -[:`_end`]->
  (expE)    -[:`_normal`]-> (vdion) -[:`_end`]->
  (vdionE)  -[:`_normal`]-> (vdsE)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \alldifferent{} \Big(\expandout{vdor}{exp}{Expression}{\_e78}{init}{1}{1} \Big(\expandout{vdion}{vdor}{VariableDeclarator}{\_e77}{declarators}{1}{1} \Big(\expandout{vds}{vdion}{VariableDeclaration}{\_e76}{declaration}{1}{1} \Big(\getvertices{vds}{VariableDeclarationStatement}\Big)\Big)\Big) \join \expandout{vds}{vdsE}{End}{\_e79}{\_end}{1}{1} \Big(\getvertices{vds}{VariableDeclarationStatement}\Big) \join \expandout{vdion}{vdionE}{End}{\_e80}{\_end}{1}{1} \Big(\getvertices{vdion}{VariableDeclaration}\Big) \join \expandout{exp}{expE}{End}{\_e81}{\_end}{1}{1} \Big(\getvertices{exp}{Expression}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds, \_e76, vdion, \_e77, vdor, \_e78, exp, \_e79, vdsE, \_e80, vdionE, \_e81, expE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds, \_e76, vdion, \_e77, vdor, \_e78, exp, \_e79, vdsE, \_e80, vdionE, \_e81, expE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds, \_e76, vdion, \_e77, vdor, \_e78, exp, \_e79, vdsE, \_e80, vdionE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds, \_e76, vdion, \_e77, vdor, \_e78, exp, \_e79, vdsE} \rangle$
			}
[
	{$\expandout{vdor}{exp}{Expression}{\_e78}{init}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds, \_e76, vdion, \_e77, vdor, \_e78, exp} \rangle$
			}
[
	{$\expandout{vdion}{vdor}{VariableDeclarator}{\_e77}{declarators}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds, \_e76, vdion, \_e77, vdor} \rangle$
			}
[
	{$\expandout{vds}{vdion}{VariableDeclaration}{\_e76}{declaration}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds, \_e76, vdion} \rangle$
			}
[
	{$\getvertices{vds}{VariableDeclarationStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
[
	{$\expandout{vds}{vdsE}{End}{\_e79}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds, \_e79, vdsE} \rangle$
			}
[
	{$\getvertices{vds}{VariableDeclarationStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{vdion}{vdionE}{End}{\_e80}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{vdion, \_e80, vdionE} \rangle$
			}
[
	{$\getvertices{vdion}{VariableDeclaration}$
			\\
			\footnotesize
			$\color{gray} \langle \var{vdion} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{exp}{expE}{End}{\_e81}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{exp, \_e81, expE} \rangle$
			}
[
	{$\getvertices{exp}{Expression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{exp} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds, \_e76, vdion, \_e77, vdor, \_e78, exp, \_e79, vdsE, \_e80, vdionE, \_e81, expE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds, \_e76, vdion, \_e77, vdor, \_e78, exp, \_e79, vdsE, \_e80, vdionE, \_e81, expE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds, \_e76, vdion, \_e77, vdor, \_e78, exp, \_e79, vdsE, \_e80, vdionE} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds, \_e76, vdion, \_e77, vdor, \_e78, exp, \_e79, vdsE} \rangle$
			}
[
	{$\expandout{vdor}{exp}{Expression}{\_e78}{init}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds, \_e76, vdion, \_e77, vdor, \_e78, exp} \rangle$
			}
[
	{$\expandout{vdion}{vdor}{VariableDeclarator}{\_e77}{declarators}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds, \_e76, vdion, \_e77, vdor} \rangle$
			}
[
	{$\expandout{vds}{vdion}{VariableDeclaration}{\_e76}{declaration}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds, \_e76, vdion} \rangle$
			}
[
	{$\getvertices{vds}{VariableDeclarationStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
[
	{$\expandout{vds}{vdsE}{End}{\_e79}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds, \_e79, vdsE} \rangle$
			}
[
	{$\getvertices{vds}{VariableDeclarationStatement}$
			\\
			\footnotesize
			$\color{gray} \langle \var{vds} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{vdion}{vdionE}{End}{\_e80}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{vdion, \_e80, vdionE} \rangle$
			}
[
	{$\getvertices{vdion}{VariableDeclaration}$
			\\
			\footnotesize
			$\color{gray} \langle \var{vdion} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{exp}{expE}{End}{\_e81}{\_end}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{exp, \_e81, expE} \rangle$
			}
[
	{$\getvertices{exp}{Expression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{exp} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{VariableDeclarator}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (bi:BindingIdentifier)<-[:binding]-
    (vd:VariableDeclarator)
      -[:init]->(exp:Expression),

  (exp)-[:`_type`]->(tag:Tag)

MERGE
  (bi)-[:`_type`]->(tag)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \alldifferent{} \Big(\expandout{vd}{exp}{Expression}{\_e83}{init}{1}{1} \Big(\expandin{bi}{vd}{VariableDeclarator}{\_e82}{binding}{1}{1} \Big(\getvertices{bi}{BindingIdentifier}\Big)\Big) \join \expandout{exp}{tag}{Tag}{\_e84}{\_type}{1}{1} \Big(\getvertices{exp}{Expression}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bi, \_e82, vd, \_e83, exp, \_e84, tag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{bi, \_e82, vd, \_e83, exp, \_e84, tag} \rangle$
			}
[
	{$\expandout{vd}{exp}{Expression}{\_e83}{init}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bi, \_e82, vd, \_e83, exp} \rangle$
			}
[
	{$\expandin{bi}{vd}{VariableDeclarator}{\_e82}{binding}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bi, \_e82, vd} \rangle$
			}
[
	{$\getvertices{bi}{BindingIdentifier}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bi} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{exp}{tag}{Tag}{\_e84}{\_type}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{exp, \_e84, tag} \rangle$
			}
[
	{$\getvertices{exp}{Expression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{exp} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bi, \_e82, vd, \_e83, exp, \_e84, tag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{bi, \_e82, vd, \_e83, exp, \_e84, tag} \rangle$
			}
[
	{$\expandout{vd}{exp}{Expression}{\_e83}{init}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bi, \_e82, vd, \_e83, exp} \rangle$
			}
[
	{$\expandin{bi}{vd}{VariableDeclarator}{\_e82}{binding}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bi, \_e82, vd} \rangle$
			}
[
	{$\getvertices{bi}{BindingIdentifier}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bi} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{exp}{tag}{Tag}{\_e84}{\_type}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{exp, \_e84, tag} \rangle$
			}
[
	{$\getvertices{exp}{Expression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{exp} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{Write}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
  (v:Variable)-[:references]->(r:Reference)-[:node]->(bid:BindingIdentifier),
  (bid)-[:`_type`]->(tag:Tag)

MERGE
  (v)-[:`_type`]->(tag)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \alldifferent{} \Big(\expandout{r}{bid}{BindingIdentifier}{\_e86}{node}{1}{1} \Big(\expandout{v}{r}{Reference}{\_e85}{references}{1}{1} \Big(\getvertices{v}{Variable}\Big)\Big) \join \expandout{bid}{tag}{Tag}{\_e87}{\_type}{1}{1} \Big(\getvertices{bid}{BindingIdentifier}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v, \_e85, r, \_e86, bid, \_e87, tag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{v, \_e85, r, \_e86, bid, \_e87, tag} \rangle$
			}
[
	{$\expandout{r}{bid}{BindingIdentifier}{\_e86}{node}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v, \_e85, r, \_e86, bid} \rangle$
			}
[
	{$\expandout{v}{r}{Reference}{\_e85}{references}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v, \_e85, r} \rangle$
			}
[
	{$\getvertices{v}{Variable}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{bid}{tag}{Tag}{\_e87}{\_type}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bid, \_e87, tag} \rangle$
			}
[
	{$\getvertices{bid}{BindingIdentifier}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bid} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v, \_e85, r, \_e86, bid, \_e87, tag} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{v, \_e85, r, \_e86, bid, \_e87, tag} \rangle$
			}
[
	{$\expandout{r}{bid}{BindingIdentifier}{\_e86}{node}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v, \_e85, r, \_e86, bid} \rangle$
			}
[
	{$\expandout{v}{r}{Reference}{\_e85}{references}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v, \_e85, r} \rangle$
			}
[
	{$\getvertices{v}{Variable}$
			\\
			\footnotesize
			$\color{gray} \langle \var{v} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{bid}{tag}{Tag}{\_e87}{\_type}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bid, \_e87, tag} \rangle$
			}
[
	{$\getvertices{bid}{BindingIdentifier}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bid} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{generatecalls}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
    // Match called FunctionDeclarations for every CallExpression
    (call:CallExpression)-[:callee]->(:IdentifierExpression)
    <-[:node]-(:Reference)<-[:references]-(:Variable)
    -[:declarations]->(:Declaration)-[:node]->(:BindingIdentifier)
    <-[:name]-(fd:FunctionDeclaration)
MATCH
    // List every call from a function body
    (fun:FunctionDeclaration), (call:CallExpression),
    p = shortestPath((fun)-[*]->(call))

MERGE
    // Create a calls relationship between the caller
    // FunctionDeclaration and the called FunctionDeclaration
    (fun)-[:calls]->(fd)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{getlastcommithash}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (:MetaInfo)-[:lastCommit]->(c:Commit)
RETURN c.hash as commitHash
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{c.hash}\assign \var{commitHash}} \Big(\alldifferent{} \Big(\expandout{\_e99}{c}{Commit}{\_e100}{lastCommit}{1}{1} \Big(\getvertices{\_e99}{MetaInfo}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.hash}\assign \var{commitHash}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{hash} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e99, \_e100, c} \rangle$
			}
[
	{$\expandout{\_e99}{c}{Commit}{\_e100}{lastCommit}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e99, \_e100, c} \rangle$
			}
[
	{$\getvertices{\_e99}{MetaInfo}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e99} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.hash}\assign \var{commitHash}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{hash} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e99, \_e100, c} \rangle$
			}
[
	{$\expandout{\_e99}{c}{Commit}{\_e100}{lastCommit}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e99, \_e100, c} \rangle$
			}
[
	{$\getvertices{\_e99}{MetaInfo}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e99} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{removefile}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
	( cu:CompilationUnit
		{
			path: {path}
		}
	)-[:contains]-(el)
WHERE
  // iff the provided sessionid parameter is NULL, then delete the fix graph of
  // the CompilationUnit; else delete the temporal one with the given sessionid
     ( {sessionid} IS NULL AND NOT exists(cu.sessionid) )
  OR ( cu.sessionid = {sessionid} )
DETACH DELETE
	cu, el
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{setcommithash}

\subsubsection*{Query specification}

\begin{lstlisting}
MERGE (:MetaInfo)-[:lastCommit]->(c:Commit)
SET c.hash = {commithash}
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{typing}

\subsubsection*{Query specification}

\begin{lstlisting}
/**
 * Type inferencing
 *
 * Repeat the following steps until either no change occurs in the database or a
 * given repeat limit is reached.
 *
 *  1. Find the literal values and assign type tags to them.
 *  2. Propagate the type information to the Variables in the given Scope for
 *     every VariableDeclaration with initial value. Handle the corner cases.
 *  3. Handle built-in Unary and Binary Expressions.
 *  4. Propagate type information into function calls taking care of in-function
 *     type differentiation based on input types.
 */

/**
 *  1. Find the literal values and assign type tags to them.
 *     - LiteralNumericExpression -> NumberTag
 *     - LiteralStringExpression  -> StringTag
 *     - LiteralBooleanExpression -> BooleanTag
 *     - LiteralNullExpression    -> NullTag
 */

// LiteralNumericExpression -> NumberTag
MATCH (exp:LiteralNumericExpression)
MERGE (exp)-[:type]->(tag:Tag:NumberTag)
SET tag.session = exp.session
;

// LiteralStringExpression  -> StringTag
MATCH (exp:LiteralStringExpression)
MERGE (exp)-[:type]->(tag:Tag:StringTag)
SET tag.session = exp.session
;

// LiteralBooleanExpression -> BooleanTag
MATCH (exp:LiteralBooleanExpression)
MERGE (exp)-[:type]->(tag:Tag:BooleanTag)
SET tag.session = exp.session
;

// LiteralNullExpression    -> NullTag
MATCH (exp:LiteralNullExpression)
MERGE (exp)-[:type]->(tag:Tag:NullTag)
SET tag.session = exp.session
;

/**
 *  2. Propagate the type information to Variables from their VariableDeclaration.
 */

MATCH
    //(vds:VariableDeclarationStatement)-[:declaration]->
    //(vdion:VariableDeclaration)-[declarators]->(vdor)
    (var:Variable)-[:declarations]->
    (dec:Declaration)-[:node]->
    (bi:BindingIdentifier)<-[:binding]-
    (vdor:VariableDeclarator)-[:init]->
    (exp:Expression)-[:type]->
    (type:Tag)
//MERGE
//    (var)-[:type]->(tag:Tag)
//CALL apoc.create.addLabels(tag, labels(type))
WHERE
    NOT (var)-[:type]-(:Tag)-[:from]->(type)
CALL
    apoc.refactor.cloneNodes([type]) YIELD input, output as tag, error
MERGE
    (var)-[:type]->(tag)-[:from]->(type)
//MERGE
//    (tag)-[:from]->(type)
MERGE
    (tag)-[:through]->(vdor)
;


/**
 * Find the VariableDeclarators without initial value and mark them as
 * undefined.
 */

 MATCH
     (var:Variable)-[:declarations]->
     (dec:Declaration)-[:node]->
     (bi:BindingIdentifier)<-[:binding]-
     (vdor:VariableDeclarator)
 WHERE
     NOT (vdor)-[:init]->(:Expression)
 MERGE
     (var)-[:type]->(tag:Tag:UndefinedTag)
 SET
     tag.session = var.session
 MERGE
     (tag)-[:through]->(vdor)
 ;

/**
 * Find ArrayExpressions and tag them.
 */
 // TODO

/**
 * Find ObjectExpressions and tag them.
 */
 // TODO


/**
 *  3. Handle built-in Unary and Binary Expressions.
 */

/**
 * Propagate the Variable type information to the appropriate
 * IdentifierExpression.
 */

MATCH
    (type:Tag)<-[:type]-
    (var:Variable)-[:references]->
    (ref:Reference)-[:node]->
    (exp:Expression)
WHERE
    NOT (exp)-[:type]-(:Tag)-[:from]->(type)
CALL
    apoc.refactor.cloneNodes([type]) YIELD input, output as tag, error
MERGE
    (exp)-[:type]->(tag)-[:from]->(type)
;

/**
 * PLUS binary operator.
 */
MATCH
    (ltag:Tag)<-[:type]-(left:Expression)
    <-[:left]-(exp:BinaryExpression)-[:right]->
    (right:Expression)-[:type]->(rtag:Tag)
WHERE
        exp.operator = 'Plus'
    AND ltag :NumberTag
    AND rtag :NumberTag
MERGE
    (exp)-[:type]->(tag:Tag:NumberTag)
MERGE
    (ltag)<-[:from]-(tag)-[:from]->(rtag)
SET
    tag.session = ltag.session
;
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \alldifferent{} \Big(\getvertices{exp}{LiteralNumericExpression}\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{exp} \rangle$
			}
[
	{$\getvertices{exp}{LiteralNumericExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{exp} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{exp} \rangle$
			}
[
	{$\getvertices{exp}{LiteralNumericExpression}$
			\\
			\footnotesize
			$\color{gray} \langle \var{exp} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
;
\end{forest}
\subsection{unusedfunctions}

\subsubsection*{Query specification}

\begin{lstlisting}
/**
 * Get not used FunctionDeclarations
 */
MATCH
    // Find the exported FunctionDeclaration that may be an entrance point
    p = (main)-[:items]->(:ExportDeclaration)-[:declaration]->(fd:FunctionDeclaration)

MATCH
    // Find every FunctionDeclaration that should be available through the
    // entrance points
    q = (dead:FunctionDeclaration)-[:location]->(span:SourceSpan),
        (start:SourceLocation)<-[:start]-(span)-[:end]->(end:SourceLocation)

WHERE
    // List the ones that are not available (Kleene closure) from the
    // entrance nodes (thus are not the entrance nodes "<>").
        ( NOT (fd)-[:calls*]->(dead) )
    AND ( dead <> fd )
    AND ( main:Script OR main:Module )
    AND ( ALL (
                x in (nodes(p) + nodes(q))
                WHERE NOT exists(x.session) OR x.session = {sessionid}
          ) )

RETURN DISTINCT
    ID(dead) as id, start.line, start.column, end.line, end.column, dead.session
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
