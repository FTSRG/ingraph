\chapter{Train Benchmark}
\label{chp:trainbenchmark}

\section{Queries}

\subsection{ActiveRoute}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (inactiveRoute:Route)-[:follows]->(swP:SwitchPosition)-[:target]->(sw:Switch)
WHERE swP.position <> sw.currentPosition
WITH collect(inactiveRoute) AS inactiveRoutes

MATCH (activeRoute:Route)
WHERE NOT activeRoute IN inactiveRoutes

RETURN activeRoute
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
\subsection{ConnectedSegments}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH
(sensor:Sensor)<-[:monitoredBy]-(segment1:Segment),
(segment1:Segment)-[:connectsTo]->
(segment2:Segment)-[:connectsTo]->
(segment3:Segment)-[:connectsTo]->
(segment4:Segment)-[:connectsTo]->
(segment5:Segment)-[:connectsTo]->(segment6:Segment),
(segment2:Segment)-[:monitoredBy]->(sensor:Sensor),
(segment3:Segment)-[:monitoredBy]->(sensor:Sensor),
(segment4:Segment)-[:monitoredBy]->(sensor:Sensor),
(segment5:Segment)-[:monitoredBy]->(sensor:Sensor),
(segment6:Segment)-[:monitoredBy]->(sensor:Sensor)
RETURN sensor, segment1, segment2, segment3, segment4, segment5, segment6
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{sensor},~\var{segment1},~\var{segment2},~\var{segment3},~\var{segment4},~\var{segment5},~\var{segment6}} \Big(\alldifferent{} \Big(\expandin{sensor}{segment1}{Segment}{\_e333}{monitoredBy}{1}{1} \Big(\getvertices{sensor}{Sensor}
\Big)
 \join \expandout{segment5}{segment6}{Segment}{\_e338}{connectsTo}{1}{1} \Big(\expandout{segment4}{segment5}{Segment}{\_e337}{connectsTo}{1}{1} \Big(\expandout{segment3}{segment4}{Segment}{\_e336}{connectsTo}{1}{1} \Big(\expandout{segment2}{segment3}{Segment}{\_e335}{connectsTo}{1}{1} \Big(\expandout{segment1}{segment2}{Segment}{\_e334}{connectsTo}{1}{1} \Big(\getvertices{segment1}{Segment}
\Big)
\Big)
\Big)
\Big)
\Big)
 \join \expandout{segment2}{sensor}{Sensor}{\_e339}{monitoredBy}{1}{1} \Big(\getvertices{segment2}{Segment}
\Big)
 \join \expandout{segment3}{sensor}{Sensor}{\_e340}{monitoredBy}{1}{1} \Big(\getvertices{segment3}{Segment}
\Big)
 \join \expandout{segment4}{sensor}{Sensor}{\_e341}{monitoredBy}{1}{1} \Big(\getvertices{segment4}{Segment}
\Big)
 \join \expandout{segment5}{sensor}{Sensor}{\_e342}{monitoredBy}{1}{1} \Big(\getvertices{segment5}{Segment}
\Big)
 \join \expandout{segment6}{sensor}{Sensor}{\_e343}{monitoredBy}{1}{1} \Big(\getvertices{segment6}{Segment}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{sensor},~\var{segment1},~\var{segment2},~\var{segment3},~\var{segment4},~\var{segment5},~\var{segment6}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{sensor, segment1, segment2, segment3, segment4, segment5, segment6} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{sensor, \_e333, segment1, \_e334, segment2, \_e335, segment3, \_e336, segment4, \_e337, segment5, \_e338, segment6, \_e339, \_e340, \_e341, \_e342, \_e343} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{sensor, \_e333, segment1, \_e334, segment2, \_e335, segment3, \_e336, segment4, \_e337, segment5, \_e338, segment6, \_e339, \_e340, \_e341, \_e342, \_e343} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{sensor, \_e333, segment1, \_e334, segment2, \_e335, segment3, \_e336, segment4, \_e337, segment5, \_e338, segment6, \_e339, \_e340, \_e341, \_e342} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{sensor, \_e333, segment1, \_e334, segment2, \_e335, segment3, \_e336, segment4, \_e337, segment5, \_e338, segment6, \_e339, \_e340, \_e341} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{sensor, \_e333, segment1, \_e334, segment2, \_e335, segment3, \_e336, segment4, \_e337, segment5, \_e338, segment6, \_e339, \_e340} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{sensor, \_e333, segment1, \_e334, segment2, \_e335, segment3, \_e336, segment4, \_e337, segment5, \_e338, segment6, \_e339} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{sensor, \_e333, segment1, \_e334, segment2, \_e335, segment3, \_e336, segment4, \_e337, segment5, \_e338, segment6} \rangle$
			}
[
	{$\expandin{sensor}{segment1}{Segment}{\_e333}{monitoredBy}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{sensor, \_e333, segment1} \rangle$
			}
[
	{$\getvertices{sensor}{Sensor}$
			\\
			\footnotesize
			$\color{gray} \langle \var{sensor} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\expandout{segment5}{segment6}{Segment}{\_e338}{connectsTo}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment1, \_e334, segment2, \_e335, segment3, \_e336, segment4, \_e337, segment5, \_e338, segment6} \rangle$
			}
[
	{$\expandout{segment4}{segment5}{Segment}{\_e337}{connectsTo}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment1, \_e334, segment2, \_e335, segment3, \_e336, segment4, \_e337, segment5} \rangle$
			}
[
	{$\expandout{segment3}{segment4}{Segment}{\_e336}{connectsTo}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment1, \_e334, segment2, \_e335, segment3, \_e336, segment4} \rangle$
			}
[
	{$\expandout{segment2}{segment3}{Segment}{\_e335}{connectsTo}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment1, \_e334, segment2, \_e335, segment3} \rangle$
			}
[
	{$\expandout{segment1}{segment2}{Segment}{\_e334}{connectsTo}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment1, \_e334, segment2} \rangle$
			}
[
	{$\getvertices{segment1}{Segment}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment1} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
]
[
	{$\expandout{segment2}{sensor}{Sensor}{\_e339}{monitoredBy}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment2, \_e339, sensor} \rangle$
			}
[
	{$\getvertices{segment2}{Segment}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment2} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{segment3}{sensor}{Sensor}{\_e340}{monitoredBy}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment3, \_e340, sensor} \rangle$
			}
[
	{$\getvertices{segment3}{Segment}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment3} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{segment4}{sensor}{Sensor}{\_e341}{monitoredBy}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment4, \_e341, sensor} \rangle$
			}
[
	{$\getvertices{segment4}{Segment}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment4} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{segment5}{sensor}{Sensor}{\_e342}{monitoredBy}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment5, \_e342, sensor} \rangle$
			}
[
	{$\getvertices{segment5}{Segment}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment5} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{segment6}{sensor}{Sensor}{\_e343}{monitoredBy}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment6, \_e343, sensor} \rangle$
			}
[
	{$\getvertices{segment6}{Segment}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment6} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{sensor},~\var{segment1},~\var{segment2},~\var{segment3},~\var{segment4},~\var{segment5},~\var{segment6}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{sensor, segment1, segment2, segment3, segment4, segment5, segment6} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{sensor, \_e333, segment1, \_e334, segment2, \_e335, segment3, \_e336, segment4, \_e337, segment5, \_e338, segment6, \_e339, \_e340, \_e341, \_e342, \_e343} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{sensor, \_e333, segment1, \_e334, segment2, \_e335, segment3, \_e336, segment4, \_e337, segment5, \_e338, segment6, \_e339, \_e340, \_e341, \_e342, \_e343} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{sensor, \_e333, segment1, \_e334, segment2, \_e335, segment3, \_e336, segment4, \_e337, segment5, \_e338, segment6, \_e339, \_e340, \_e341, \_e342} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{sensor, \_e333, segment1, \_e334, segment2, \_e335, segment3, \_e336, segment4, \_e337, segment5, \_e338, segment6, \_e339, \_e340, \_e341} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{sensor, \_e333, segment1, \_e334, segment2, \_e335, segment3, \_e336, segment4, \_e337, segment5, \_e338, segment6, \_e339, \_e340} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{sensor, \_e333, segment1, \_e334, segment2, \_e335, segment3, \_e336, segment4, \_e337, segment5, \_e338, segment6, \_e339} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{sensor, \_e333, segment1, \_e334, segment2, \_e335, segment3, \_e336, segment4, \_e337, segment5, \_e338, segment6} \rangle$
			}
[
	{$\expandin{sensor}{segment1}{Segment}{\_e333}{monitoredBy}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{sensor, \_e333, segment1} \rangle$
			}
[
	{$\getvertices{sensor}{Sensor}$
			\\
			\footnotesize
			$\color{gray} \langle \var{sensor} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\expandout{segment5}{segment6}{Segment}{\_e338}{connectsTo}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment1, \_e334, segment2, \_e335, segment3, \_e336, segment4, \_e337, segment5, \_e338, segment6} \rangle$
			}
[
	{$\expandout{segment4}{segment5}{Segment}{\_e337}{connectsTo}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment1, \_e334, segment2, \_e335, segment3, \_e336, segment4, \_e337, segment5} \rangle$
			}
[
	{$\expandout{segment3}{segment4}{Segment}{\_e336}{connectsTo}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment1, \_e334, segment2, \_e335, segment3, \_e336, segment4} \rangle$
			}
[
	{$\expandout{segment2}{segment3}{Segment}{\_e335}{connectsTo}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment1, \_e334, segment2, \_e335, segment3} \rangle$
			}
[
	{$\expandout{segment1}{segment2}{Segment}{\_e334}{connectsTo}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment1, \_e334, segment2} \rangle$
			}
[
	{$\getvertices{segment1}{Segment}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment1} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
]
[
	{$\expandout{segment2}{sensor}{Sensor}{\_e339}{monitoredBy}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment2, \_e339, sensor} \rangle$
			}
[
	{$\getvertices{segment2}{Segment}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment2} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{segment3}{sensor}{Sensor}{\_e340}{monitoredBy}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment3, \_e340, sensor} \rangle$
			}
[
	{$\getvertices{segment3}{Segment}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment3} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{segment4}{sensor}{Sensor}{\_e341}{monitoredBy}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment4, \_e341, sensor} \rangle$
			}
[
	{$\getvertices{segment4}{Segment}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment4} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{segment5}{sensor}{Sensor}{\_e342}{monitoredBy}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment5, \_e342, sensor} \rangle$
			}
[
	{$\getvertices{segment5}{Segment}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment5} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{segment6}{sensor}{Sensor}{\_e343}{monitoredBy}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment6, \_e343, sensor} \rangle$
			}
[
	{$\getvertices{segment6}{Segment}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment6} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}
\subsection{PosLength}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (segment:Segment)
WHERE segment.length <= 0
RETURN DISTINCT segment, segment.length AS length
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\duplicateelimination \Big(\projection{\var{segment},~\var{segment.length}\assign \var{length}} \Big(\selection{\var{segment.length} \leq \literal{0}} \Big(\alldifferent{} \Big(\getvertices{segment}{Segment}
\Big)
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\duplicateelimination$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment, length} \rangle$
			}
[
	{$\projection{\var{segment},~\var{segment.length}\assign \var{length}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment, length} \rangle$
			}
[
	{$\selection{\var{segment.length} \leq \literal{0}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment} \rangle$
			}
[
	{$\getvertices{segment}{Segment}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\duplicateelimination$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment, length} \rangle$
			}
[
	{$\projection{\var{segment},~\var{segment.length}\assign \var{length}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment, length} \rangle$
			}
[
	{$\selection{\var{segment.length} \leq \literal{0}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment} \rangle$
			}
[
	{$\getvertices{segment}{Segment}$
			\\
			\footnotesize
			$\color{gray} \langle \var{segment} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}
\subsection{RouteSensor}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (route:Route)-[:follows]->(swP:SwitchPosition)-[:target]->(sw:Switch)-[:monitoredBy]->(sensor:Sensor)
WHERE NOT ((route)-[g:gathers]->(sensor))
RETURN DISTINCT route, sensor, swP, sw
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\duplicateelimination \Big(\projection{\var{route},~\var{sensor},~\var{swP},~\var{sw}} \Big(\selection{\neg \left( \var{route} IS NOT NULL \land \var{g} IS NOT NULL \land \var{sensor} IS NOT NULL \right)} \Big(\alldifferent{} \Big(\expandout{sw}{sensor}{Sensor}{\_e346}{monitoredBy}{1}{1} \Big(\expandout{swP}{sw}{Switch}{\_e345}{target}{1}{1} \Big(\expandout{route}{swP}{SwitchPosition}{\_e344}{follows}{1}{1} \Big(\getvertices{route}{Route}
\Big)
\Big)
\Big)
\Big)
 \leftouterjoin \expandout{route}{sensor}{Sensor}{g}{gathers}{1}{1} \Big(\getvertices{route}{Route}
\Big)
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\duplicateelimination$
			\\
			\footnotesize
			$\color{gray} \langle \var{route, sensor, swP, sw} \rangle$
			}
[
	{$\projection{\var{route},~\var{sensor},~\var{swP},~\var{sw}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{route, sensor, swP, sw} \rangle$
			}
[
	{$\selection{\neg \left( \var{route} IS NOT NULL \land \var{g} IS NOT NULL \land \var{sensor} IS NOT NULL \right)}$
			\\
			\footnotesize
			$\color{gray} \langle \var{route, \_e344, swP, \_e345, sw, \_e346, sensor, g} \rangle$
			}
[
	{$\leftouterjoin$
			\\
			\footnotesize
			$\color{gray} \langle \var{route, \_e344, swP, \_e345, sw, \_e346, sensor, g} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{route, \_e344, swP, \_e345, sw, \_e346, sensor} \rangle$
			}
[
	{$\expandout{sw}{sensor}{Sensor}{\_e346}{monitoredBy}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{route, \_e344, swP, \_e345, sw, \_e346, sensor} \rangle$
			}
[
	{$\expandout{swP}{sw}{Switch}{\_e345}{target}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{route, \_e344, swP, \_e345, sw} \rangle$
			}
[
	{$\expandout{route}{swP}{SwitchPosition}{\_e344}{follows}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{route, \_e344, swP} \rangle$
			}
[
	{$\getvertices{route}{Route}$
			\\
			\footnotesize
			$\color{gray} \langle \var{route} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
[
	{$\expandout{route}{sensor}{Sensor}{g}{gathers}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{route, g, sensor} \rangle$
			}
[
	{$\getvertices{route}{Route}$
			\\
			\footnotesize
			$\color{gray} \langle \var{route} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\duplicateelimination$
			\\
			\footnotesize
			$\color{gray} \langle \var{route, sensor, swP, sw} \rangle$
			}
[
	{$\projection{\var{route},~\var{sensor},~\var{swP},~\var{sw}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{route, sensor, swP, sw} \rangle$
			}
[
	{$\selection{\neg \left( \var{route} IS NOT NULL \land \var{g} IS NOT NULL \land \var{sensor} IS NOT NULL \right)}$
			\\
			\footnotesize
			$\color{gray} \langle \var{route, \_e344, swP, \_e345, sw, \_e346, sensor, g} \rangle$
			}
[
	{$\leftouterjoin$
			\\
			\footnotesize
			$\color{gray} \langle \var{route, \_e344, swP, \_e345, sw, \_e346, sensor, g} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{route, \_e344, swP, \_e345, sw, \_e346, sensor} \rangle$
			}
[
	{$\expandout{sw}{sensor}{Sensor}{\_e346}{monitoredBy}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{route, \_e344, swP, \_e345, sw, \_e346, sensor} \rangle$
			}
[
	{$\expandout{swP}{sw}{Switch}{\_e345}{target}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{route, \_e344, swP, \_e345, sw} \rangle$
			}
[
	{$\expandout{route}{swP}{SwitchPosition}{\_e344}{follows}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{route, \_e344, swP} \rangle$
			}
[
	{$\getvertices{route}{Route}$
			\\
			\footnotesize
			$\color{gray} \langle \var{route} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
[
	{$\expandout{route}{sensor}{Sensor}{g}{gathers}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{route, g, sensor} \rangle$
			}
[
	{$\getvertices{route}{Route}$
			\\
			\footnotesize
			$\color{gray} \langle \var{route} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
}
\subsection{RouteSensorPositive}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (route:Route)-[:follows]->(swP:SwitchPosition)-[:target]->(sw:Switch)-[:monitoredBy]->(sensor:Sensor)
RETURN DISTINCT route, sensor, swP, sw
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\duplicateelimination \Big(\projection{\var{route},~\var{sensor},~\var{swP},~\var{sw}} \Big(\alldifferent{} \Big(\expandout{sw}{sensor}{Sensor}{\_e349}{monitoredBy}{1}{1} \Big(\expandout{swP}{sw}{Switch}{\_e348}{target}{1}{1} \Big(\expandout{route}{swP}{SwitchPosition}{\_e347}{follows}{1}{1} \Big(\getvertices{route}{Route}
\Big)
\Big)
\Big)
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\duplicateelimination$
			\\
			\footnotesize
			$\color{gray} \langle \var{route, sensor, swP, sw} \rangle$
			}
[
	{$\projection{\var{route},~\var{sensor},~\var{swP},~\var{sw}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{route, sensor, swP, sw} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{route, \_e347, swP, \_e348, sw, \_e349, sensor} \rangle$
			}
[
	{$\expandout{sw}{sensor}{Sensor}{\_e349}{monitoredBy}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{route, \_e347, swP, \_e348, sw, \_e349, sensor} \rangle$
			}
[
	{$\expandout{swP}{sw}{Switch}{\_e348}{target}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{route, \_e347, swP, \_e348, sw} \rangle$
			}
[
	{$\expandout{route}{swP}{SwitchPosition}{\_e347}{follows}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{route, \_e347, swP} \rangle$
			}
[
	{$\getvertices{route}{Route}$
			\\
			\footnotesize
			$\color{gray} \langle \var{route} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\duplicateelimination$
			\\
			\footnotesize
			$\color{gray} \langle \var{route, sensor, swP, sw} \rangle$
			}
[
	{$\projection{\var{route},~\var{sensor},~\var{swP},~\var{sw}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{route, sensor, swP, sw} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{route, \_e347, swP, \_e348, sw, \_e349, sensor} \rangle$
			}
[
	{$\expandout{sw}{sensor}{Sensor}{\_e349}{monitoredBy}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{route, \_e347, swP, \_e348, sw, \_e349, sensor} \rangle$
			}
[
	{$\expandout{swP}{sw}{Switch}{\_e348}{target}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{route, \_e347, swP, \_e348, sw} \rangle$
			}
[
	{$\expandout{route}{swP}{SwitchPosition}{\_e347}{follows}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{route, \_e347, swP} \rangle$
			}
[
	{$\getvertices{route}{Route}$
			\\
			\footnotesize
			$\color{gray} \langle \var{route} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
]
;
\end{forest}
}
\subsection{SemaphoreNeighbor}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (semaphore:Semaphore)<-[:exit]-(route1:Route)-[:gathers]->(sensor1:Sensor)<-[:monitoredBy]-(te1)-[:connectsTo]->(te2)-[:monitoredBy]->(sensor2:Sensor)<-[:gathers]-(route2:Route)
WHERE NOT ((semaphore)<-[:entry]-(route2))
      AND route1 != route2
RETURN DISTINCT semaphore, route1, route2, sensor1, sensor2, te1, te2
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\duplicateelimination \Big(\projection{\var{semaphore},~\var{route1},~\var{route2},~\var{sensor1},~\var{sensor2},~\var{te1},~\var{te2}} \Big(\selection{\neg \left( \var{semaphore} IS NOT NULL \land \var{\_e356} IS NOT NULL \land \var{route2} IS NOT NULL \right) \land \var{route1} \neq \var{route2}} \Big(\alldifferent{} \Big(\expandin{sensor2}{route2}{Route}{\_e355}{gathers}{1}{1} \Big(\expandout{te2}{sensor2}{Sensor}{\_e354}{monitoredBy}{1}{1} \Big(\expandout{te1}{te2}{}{\_e353}{connectsTo}{1}{1} \Big(\expandin{sensor1}{te1}{}{\_e352}{monitoredBy}{1}{1} \Big(\expandout{route1}{sensor1}{Sensor}{\_e351}{gathers}{1}{1} \Big(\expandin{semaphore}{route1}{Route}{\_e350}{exit}{1}{1} \Big(\getvertices{semaphore}{Semaphore}
\Big)
\Big)
\Big)
\Big)
\Big)
\Big)
\Big)
 \leftouterjoin \expandin{semaphore}{route2}{Route}{\_e356}{entry}{1}{1} \Big(\getvertices{semaphore}{Semaphore}
\Big)
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\duplicateelimination$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, route1, route2, sensor1, sensor2, te1, te2} \rangle$
			}
[
	{$\projection{\var{semaphore},~\var{route1},~\var{route2},~\var{sensor1},~\var{sensor2},~\var{te1},~\var{te2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, route1, route2, sensor1, sensor2, te1, te2} \rangle$
			}
[
	{$\selection{\neg \left( \var{semaphore} IS NOT NULL \land \var{\_e356} IS NOT NULL \land \var{route2} IS NOT NULL \right) \land \var{route1} \neq \var{route2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, \_e350, route1, \_e351, sensor1, \_e352, te1, \_e353, te2, \_e354, sensor2, \_e355, route2, \_e356} \rangle$
			}
[
	{$\leftouterjoin$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, \_e350, route1, \_e351, sensor1, \_e352, te1, \_e353, te2, \_e354, sensor2, \_e355, route2, \_e356} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, \_e350, route1, \_e351, sensor1, \_e352, te1, \_e353, te2, \_e354, sensor2, \_e355, route2} \rangle$
			}
[
	{$\expandin{sensor2}{route2}{Route}{\_e355}{gathers}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, \_e350, route1, \_e351, sensor1, \_e352, te1, \_e353, te2, \_e354, sensor2, \_e355, route2} \rangle$
			}
[
	{$\expandout{te2}{sensor2}{Sensor}{\_e354}{monitoredBy}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, \_e350, route1, \_e351, sensor1, \_e352, te1, \_e353, te2, \_e354, sensor2} \rangle$
			}
[
	{$\expandout{te1}{te2}{}{\_e353}{connectsTo}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, \_e350, route1, \_e351, sensor1, \_e352, te1, \_e353, te2} \rangle$
			}
[
	{$\expandin{sensor1}{te1}{}{\_e352}{monitoredBy}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, \_e350, route1, \_e351, sensor1, \_e352, te1} \rangle$
			}
[
	{$\expandout{route1}{sensor1}{Sensor}{\_e351}{gathers}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, \_e350, route1, \_e351, sensor1} \rangle$
			}
[
	{$\expandin{semaphore}{route1}{Route}{\_e350}{exit}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, \_e350, route1} \rangle$
			}
[
	{$\getvertices{semaphore}{Semaphore}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
]
]
[
	{$\expandin{semaphore}{route2}{Route}{\_e356}{entry}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, \_e356, route2} \rangle$
			}
[
	{$\getvertices{semaphore}{Semaphore}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\duplicateelimination$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, route1, route2, sensor1, sensor2, te1, te2} \rangle$
			}
[
	{$\projection{\var{semaphore},~\var{route1},~\var{route2},~\var{sensor1},~\var{sensor2},~\var{te1},~\var{te2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, route1, route2, sensor1, sensor2, te1, te2} \rangle$
			}
[
	{$\selection{\neg \left( \var{semaphore} IS NOT NULL \land \var{\_e356} IS NOT NULL \land \var{route2} IS NOT NULL \right) \land \var{route1} \neq \var{route2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, \_e350, route1, \_e351, sensor1, \_e352, te1, \_e353, te2, \_e354, sensor2, \_e355, route2, \_e356} \rangle$
			}
[
	{$\leftouterjoin$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, \_e350, route1, \_e351, sensor1, \_e352, te1, \_e353, te2, \_e354, sensor2, \_e355, route2, \_e356} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, \_e350, route1, \_e351, sensor1, \_e352, te1, \_e353, te2, \_e354, sensor2, \_e355, route2} \rangle$
			}
[
	{$\expandin{sensor2}{route2}{Route}{\_e355}{gathers}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, \_e350, route1, \_e351, sensor1, \_e352, te1, \_e353, te2, \_e354, sensor2, \_e355, route2} \rangle$
			}
[
	{$\expandout{te2}{sensor2}{Sensor}{\_e354}{monitoredBy}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, \_e350, route1, \_e351, sensor1, \_e352, te1, \_e353, te2, \_e354, sensor2} \rangle$
			}
[
	{$\expandout{te1}{te2}{}{\_e353}{connectsTo}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, \_e350, route1, \_e351, sensor1, \_e352, te1, \_e353, te2} \rangle$
			}
[
	{$\expandin{sensor1}{te1}{}{\_e352}{monitoredBy}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, \_e350, route1, \_e351, sensor1, \_e352, te1} \rangle$
			}
[
	{$\expandout{route1}{sensor1}{Sensor}{\_e351}{gathers}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, \_e350, route1, \_e351, sensor1} \rangle$
			}
[
	{$\expandin{semaphore}{route1}{Route}{\_e350}{exit}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, \_e350, route1} \rangle$
			}
[
	{$\getvertices{semaphore}{Semaphore}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
]
]
[
	{$\expandin{semaphore}{route2}{Route}{\_e356}{entry}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, \_e356, route2} \rangle$
			}
[
	{$\getvertices{semaphore}{Semaphore}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
}
\subsection{SwitchMonitored}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (sw:Switch)
WHERE NOT ((sw)-[:monitoredBy]->(:Sensor))
RETURN DISTINCT sw
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\duplicateelimination \Big(\projection{\var{sw}} \Big(\selection{\neg \left( \var{sw} IS NOT NULL \land \var{\_e357} IS NOT NULL \land \var{\_e358} IS NOT NULL \right)} \Big(\alldifferent{} \Big(\getvertices{sw}{Switch}
\Big)
 \leftouterjoin \expandout{sw}{\_e358}{Sensor}{\_e357}{monitoredBy}{1}{1} \Big(\getvertices{sw}{Switch}
\Big)
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\duplicateelimination$
			\\
			\footnotesize
			$\color{gray} \langle \var{sw} \rangle$
			}
[
	{$\projection{\var{sw}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{sw} \rangle$
			}
[
	{$\selection{\neg \left( \var{sw} IS NOT NULL \land \var{\_e357} IS NOT NULL \land \var{\_e358} IS NOT NULL \right)}$
			\\
			\footnotesize
			$\color{gray} \langle \var{sw, \_e357, \_e358} \rangle$
			}
[
	{$\leftouterjoin$
			\\
			\footnotesize
			$\color{gray} \langle \var{sw, \_e357, \_e358} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{sw} \rangle$
			}
[
	{$\getvertices{sw}{Switch}$
			\\
			\footnotesize
			$\color{gray} \langle \var{sw} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\expandout{sw}{\_e358}{Sensor}{\_e357}{monitoredBy}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{sw, \_e357, \_e358} \rangle$
			}
[
	{$\getvertices{sw}{Switch}$
			\\
			\footnotesize
			$\color{gray} \langle \var{sw} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\duplicateelimination$
			\\
			\footnotesize
			$\color{gray} \langle \var{sw} \rangle$
			}
[
	{$\projection{\var{sw}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{sw} \rangle$
			}
[
	{$\selection{\neg \left( \var{sw} IS NOT NULL \land \var{\_e357} IS NOT NULL \land \var{\_e358} IS NOT NULL \right)}$
			\\
			\footnotesize
			$\color{gray} \langle \var{sw, \_e357, \_e358} \rangle$
			}
[
	{$\leftouterjoin$
			\\
			\footnotesize
			$\color{gray} \langle \var{sw, \_e357, \_e358} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{sw} \rangle$
			}
[
	{$\getvertices{sw}{Switch}$
			\\
			\footnotesize
			$\color{gray} \langle \var{sw} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\expandout{sw}{\_e358}{Sensor}{\_e357}{monitoredBy}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{sw, \_e357, \_e358} \rangle$
			}
[
	{$\getvertices{sw}{Switch}$
			\\
			\footnotesize
			$\color{gray} \langle \var{sw} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
}
\subsection{SwitchSet}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (semaphore:Semaphore)<-[:entry]-(route:Route)-[:follows]->(swP:SwitchPosition)-[:target]->(sw:Switch)
WHERE semaphore.signal = "GO"
  AND sw.currentPosition != swP.position
RETURN DISTINCT semaphore, route, swP, sw, sw.currentPosition AS currentPosition, swP.position AS position
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\duplicateelimination \Big(\projection{\var{semaphore},~\var{route},~\var{swP},~\var{sw},~\var{sw.currentPosition}\assign \var{currentPosition},~\var{swP.position}\assign \var{position}} \Big(\selection{\var{semaphore.signal} = \literal{'GO'} \land \var{sw.currentPosition} \neq \var{swP.position}} \Big(\alldifferent{} \Big(\expandout{swP}{sw}{Switch}{\_e361}{target}{1}{1} \Big(\expandout{route}{swP}{SwitchPosition}{\_e360}{follows}{1}{1} \Big(\expandin{semaphore}{route}{Route}{\_e359}{entry}{1}{1} \Big(\getvertices{semaphore}{Semaphore}
\Big)
\Big)
\Big)
\Big)
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\duplicateelimination$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, route, swP, sw, currentPosition, position} \rangle$
			}
[
	{$\projection{\var{semaphore},~\var{route},~\var{swP},~\var{sw},~\var{sw.currentPosition}\assign \var{currentPosition},~\var{swP.position}\assign \var{position}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, route, swP, sw, currentPosition, position} \rangle$
			}
[
	{$\selection{\var{semaphore.signal} = \literal{'GO'} \land \var{sw.currentPosition} \neq \var{swP.position}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, \_e359, route, \_e360, swP, \_e361, sw} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, \_e359, route, \_e360, swP, \_e361, sw} \rangle$
			}
[
	{$\expandout{swP}{sw}{Switch}{\_e361}{target}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, \_e359, route, \_e360, swP, \_e361, sw} \rangle$
			}
[
	{$\expandout{route}{swP}{SwitchPosition}{\_e360}{follows}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, \_e359, route, \_e360, swP} \rangle$
			}
[
	{$\expandin{semaphore}{route}{Route}{\_e359}{entry}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, \_e359, route} \rangle$
			}
[
	{$\getvertices{semaphore}{Semaphore}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\duplicateelimination$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, route, swP, sw, currentPosition, position} \rangle$
			}
[
	{$\projection{\var{semaphore},~\var{route},~\var{swP},~\var{sw},~\var{sw.currentPosition}\assign \var{currentPosition},~\var{swP.position}\assign \var{position}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, route, swP, sw, currentPosition, position} \rangle$
			}
[
	{$\selection{\var{semaphore.signal} = \literal{'GO'} \land \var{sw.currentPosition} \neq \var{swP.position}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, \_e359, route, \_e360, swP, \_e361, sw} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, \_e359, route, \_e360, swP, \_e361, sw} \rangle$
			}
[
	{$\expandout{swP}{sw}{Switch}{\_e361}{target}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, \_e359, route, \_e360, swP, \_e361, sw} \rangle$
			}
[
	{$\expandout{route}{swP}{SwitchPosition}{\_e360}{follows}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, \_e359, route, \_e360, swP} \rangle$
			}
[
	{$\expandin{semaphore}{route}{Route}{\_e359}{entry}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore, \_e359, route} \rangle$
			}
[
	{$\getvertices{semaphore}{Semaphore}$
			\\
			\footnotesize
			$\color{gray} \langle \var{semaphore} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
]
]
;
\end{forest}
}
