\chapter{TCK Acceptance Tests}
\label{chp:tck}

\section{AggregationAcceptance}

\subsection{Support multiple divisions in aggregate function}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN count(n) / 60 / 60 AS count
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Support column renaming for aggregates as well}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()
RETURN count(*) AS columnName
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Aggregates inside normal functions}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
RETURN size(collect(a))
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handle aggregates inside non-aggregate expressions}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a {name: 'Andres'})<-[:FATHER]-(child)
RETURN {foo: a.name='Andres', kids: collect(child.name)}
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Count nodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:L)-[rel]->(b)
RETURN a, count(*)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Sort on aggregate function and normal property}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n.division, count(*)
ORDER BY count(*) DESC, n.division ASC
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Aggregate on property}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n.x, count(*)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Count non-null values}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n.y, count(n.x)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Sum non-null values}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n.y, sum(n.x)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handle aggregation on functions}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p=(a:L)-[*]->(b)
RETURN b, avg(length(p))
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Distinct on unbound node}

\subsubsection*{Query specification}

\begin{lstlisting}
OPTIONAL MATCH (a)
RETURN count(DISTINCT a)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Distinct on null}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
RETURN count(DISTINCT a.foo)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Collect distinct nulls}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND [null, null] AS x
RETURN collect(DISTINCT x) AS c
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Collect distinct values mixed with nulls}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND [null, 1, null] AS x
RETURN collect(DISTINCT x) AS c
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Aggregate on list values}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
RETURN DISTINCT a.color, count(*)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Aggregates with arithmetics}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()
RETURN count(*) * 10 AS c
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Aggregates ordered by arithmetics}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A), (b:X)
RETURN count(a) * 10 + count(b) * 5 AS x
ORDER BY x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Multiple aggregates on same variable}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN count(n), collect(n)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Simple counting of nodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()
RETURN count(*)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Aggregation of named paths}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (a)-[*]->(b)
RETURN collect(nodes(p)) AS paths, length(p) AS l
ORDER BY l
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Aggregation with `min()`}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (a:T {name: 'a'})-[:R*]->(other:T)
WHERE other <> a
WITH a, other, min(length(p)) AS len
RETURN a.name AS name, collect(other.name) AS others, len
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handle subexpression in aggregation also occurring as standalone expression with nested aggregation in a literal map}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A), (b:B)
RETURN coalesce(a.prop, b.prop) AS foo,
  b.prop AS bar,
  {y: count(b)} AS baz
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{No overflow during summation}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND range(1000000, 2000000) AS i
WITH i
LIMIT 3000
RETURN sum(i)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Counting with loops}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[r]-()
RETURN count(r)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`max()` should aggregate strings}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND ['a', 'b', 'B', null, 'abc', 'abc1'] AS i
RETURN max(i)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`min()` should aggregate strings}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND ['a', 'b', 'B', null, 'abc', 'abc1'] AS i
RETURN min(i)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\section{ColumnNameAcceptance}

\subsection{Keeping used expression 1}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN cOuNt( * )
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Keeping used expression 2}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (n)-->(b)
RETURN nOdEs( p )
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Keeping used expression 3}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (n)-->(b)
RETURN coUnt( dIstInct p )
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Keeping used expression 4}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (n)-->(b)
RETURN aVg(    n.aGe     )
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\section{ComparisonOperatorAcceptance}

\subsection{Handling numerical ranges 1}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WHERE 1 < n.value < 3
RETURN n.value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handling numerical ranges 2}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WHERE 1 < n.value <= 3
RETURN n.value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handling numerical ranges 3}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WHERE 1 <= n.value < 3
RETURN n.value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handling numerical ranges 4}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WHERE 1 <= n.value <= 3
RETURN n.value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handling string ranges 1}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WHERE 'a' < n.value < 'c'
RETURN n.value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handling string ranges 2}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WHERE 'a' < n.value <= 'c'
RETURN n.value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handling string ranges 3}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WHERE 'a' <= n.value < 'c'
RETURN n.value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handling string ranges 4}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WHERE 'a' <= n.value <= 'c'
RETURN n.value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handling empty range}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WHERE 10 < n.value <= 3
RETURN n.value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handling long chains of operators}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)-->(m)
WHERE n.prop1 < m.prop1 = n.prop2 <> m.prop2
RETURN labels(m)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\section{Create}

\section{CreateAcceptance}

\section{DeleteAcceptance}

\section{EqualsAcceptance}

\subsection{Number-typed integer comparison}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH collect([0, 0.0]) AS numbers
UNWIND numbers AS arr
WITH arr[0] AS expected
MATCH (n) WHERE toInteger(n.id) = expected
RETURN n
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Number-typed float comparison}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH collect([0.5, 0]) AS numbers
UNWIND numbers AS arr
WITH arr[0] AS expected
MATCH (n) WHERE toInteger(n.id) = expected
RETURN n
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Any-typed string comparison}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH collect(['0', 0]) AS things
UNWIND things AS arr
WITH arr[0] AS expected
MATCH (n) WHERE toInteger(n.id) = expected
RETURN n
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Comparing nodes to nodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WITH a
MATCH (b)
WHERE a = b
RETURN count(b)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Comparing relationships to relationships}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[a]->()
WITH a
MATCH ()-[b]->()
WHERE a = b
RETURN count(b)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\section{ExpressionAcceptance}

\subsection{Execute n[0]}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN [1, 2, 3][0] AS value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Execute n['name'] in read queries}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n {name: 'Apa'})
RETURN n['nam' + 'e'] AS value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{n}} \Big(\alldifferent{} \Big(\getvertices{n}{}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{Use dynamic property lookup based on parameters when there is no type information}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH $expr AS expr, $idx AS idx
RETURN expr[idx] AS value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Use dynamic property lookup based on parameters when there is rhs type information}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH $expr AS expr, $idx AS idx
RETURN expr[toString(idx)] AS value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Use collection lookup based on parameters when there is no type information}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH $expr AS expr, $idx AS idx
RETURN expr[idx] AS value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Use collection lookup based on parameters when there is lhs type information}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH ['Apa'] AS expr
RETURN expr[$idx] AS value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Use collection lookup based on parameters when there is rhs type information}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH $expr AS expr, $idx AS idx
RETURN expr[toInteger(idx)] AS value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\section{FunctionsAcceptance}

\subsection{Run coalesce}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
RETURN coalesce(a.title, a.name)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Functions should return null if they get path containing unbound}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH null AS a
OPTIONAL MATCH p = (a)-[r]->()
RETURN length(nodes(p)), type(r), nodes(p), relationships(p)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`split()`}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND split('one1two', '1') AS item
RETURN count(item) AS item
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`properties()` on a node}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (p:Person)
RETURN properties(p) AS m
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`properties()` on a relationship}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[r:R]->()
RETURN properties(r) AS m
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`properties()` on a map}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN properties({name: 'Popeye', level: 9001}) AS m
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`properties()` on null}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN properties(null)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`reverse()`}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN reverse('raksO')
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`exists()` with dynamic property lookup}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n:Person)
WHERE exists(n['prop'])
RETURN n
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`percentileDisc()` failing in more involved query}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n:S)
WITH n, size([(n)-->() | 1]) AS deg
WHERE deg > 2
WITH deg
LIMIT 100
RETURN percentileDisc(0.90, deg), deg
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \alldifferent{} \Big(\getvertices{n}{S}\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{S}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{S}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
;
\end{forest}
\subsection{`type()`}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[r]->()
RETURN type(r)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`type()` on two relationships}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[r1]->()-[r2]->()
RETURN type(r1), type(r2)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`type()` on null relationship}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
OPTIONAL MATCH (a)-[r:NOT_THERE]->()
RETURN type(r)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`type()` on mixed null and non-null relationships}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
OPTIONAL MATCH (a)-[r:T]->()
RETURN type(r)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`type()` handling Any type}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-[r]->()
WITH [r, 1] AS list
RETURN type(list[0])
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`labels()` should accept type Any}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WITH [a, 1] AS list
RETURN labels(list[0]) AS l
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`labels()` should accept type Any}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WITH [a, 1] AS list
RETURN labels(list[1]) AS l
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`exists()` is case insensitive}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n:X)
RETURN n, EXIsTS(n.prop) AS b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\section{ValueHashJoinAcceptance}

\subsection{Find friends of others}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A), (b:B)
WHERE a.id = b.id
RETURN a, b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{a},~\var{b}} \Big(\selection{\var{a.id} = \var{b.id}} \Big(\alldifferent{} \Big(\getvertices{a}{A} \join \getvertices{b}{B}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\selection{\var{a.id} = \var{b.id}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\getvertices{b}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\selection{\var{a.id} = \var{b.id}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\getvertices{b}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Should only join when matching}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A), (b:B)
WHERE a.id = b.id
RETURN a, b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{a},~\var{b}} \Big(\selection{\var{a.id} = \var{b.id}} \Big(\alldifferent{} \Big(\getvertices{a}{A} \join \getvertices{b}{B}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\selection{\var{a.id} = \var{b.id}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\getvertices{b}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\selection{\var{a.id} = \var{b.id}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\getvertices{b}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\section{KeysAcceptance}

\subsection{Using `keys()` on a single node, non-empty result}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
UNWIND keys(n) AS x
RETURN DISTINCT x AS theProps
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Using `keys()` on multiple nodes, non-empty result}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
UNWIND keys(n) AS x
RETURN DISTINCT x AS theProps
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Using `keys()` on a single node, empty result}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
UNWIND keys(n) AS x
RETURN DISTINCT x AS theProps
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Using `keys()` on an optionally matched node}

\subsubsection*{Query specification}

\begin{lstlisting}
OPTIONAL MATCH (n)
UNWIND keys(n) AS x
RETURN DISTINCT x AS theProps
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Using `keys()` on a relationship, non-empty result}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[r:KNOWS]-()
UNWIND keys(r) AS x
RETURN DISTINCT x AS theProps
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Using `keys()` on a relationship, empty result}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[r:KNOWS]-()
UNWIND keys(r) AS x
RETURN DISTINCT x AS theProps
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Using `keys()` on an optionally matched relationship}

\subsubsection*{Query specification}

\begin{lstlisting}
OPTIONAL MATCH ()-[r:KNOWS]-()
UNWIND keys(r) AS x
RETURN DISTINCT x AS theProps
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Using `keys()` on a literal map}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN keys({name: 'Alice', age: 38, address: {city: 'London', residential: true}}) AS k
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Using `keys()` on a parameter map}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN keys($param) AS k
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\section{LabelsAcceptance}

\subsection{Using `labels()` in return clauses}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN labels(n)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\section{LargeCreateQuery}

\section{LargeIntegerEquality}

\subsection{Does not lose precision}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (p:Label)
RETURN p.id
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{p.id}} \Big(\alldifferent{} \Big(\getvertices{p}{Label}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{p.id}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{p}{Label}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{p.id}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{p}{Label}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{Handling inlined equality of large integer}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (p:Label {id: 4611686018427387905})
RETURN p.id
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{p.id}} \Big(\alldifferent{} \Big(\getvertices{p}{Label}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{p.id}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{p}{Label}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{p.id}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{p}{Label}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{Handling explicit equality of large integer}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (p:Label)
WHERE p.id = 4611686018427387905
RETURN p.id
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handling inlined equality of large integer, non-equal values}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (p:Label {id : 4611686018427387900})
RETURN p.id
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{p.id}} \Big(\alldifferent{} \Big(\getvertices{p}{Label}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{p.id}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{p}{Label}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{p.id}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{p}{Label}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{Handling explicit equality of large integer, non-equal values}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (p:Label)
WHERE p.id = 4611686018427387900
RETURN p.id
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\section{ListComprehension}

\subsection{Returning a list comprehension}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (n)-->()
RETURN [x IN collect(p) | head(nodes(x))] AS p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Using a list comprehension in a WITH}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (n:A)-->()
WITH [x IN collect(p) | head(nodes(x))] AS p, count(n) AS c
RETURN p, c
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Using a list comprehension in a WHERE}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)-->(b)
WHERE n.prop IN [x IN labels(b) | lower(x)]
RETURN b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\section{Literals}

\subsection{Return an integer}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN 1 AS literal
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Return a float}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN 1.0 AS literal
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Return a float in exponent form}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN -1e-9 AS literal
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Return a boolean}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN true AS literal
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Return a single-quoted string}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN '' AS literal
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Return a double-quoted string}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN "" AS literal
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Return null}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN null AS literal
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Return an empty list}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN [] AS literal
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Return a nonempty list}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN [0, 1, 2] AS literal
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Return an empty map}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN {} AS literal
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Return a nonempty map}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN {k1: 0, k2: 'string'} AS literal
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\section{MatchAcceptance}

\subsection{Path query should return results in written order}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (a:Label1)<--(:Label2)
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Longer path query should return results in written order}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (a:Label1)<--(:Label2)--()
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Use multiple MATCH clauses to do a Cartesian product}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n), (m)
RETURN n.value AS n, m.value AS m
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{n.value},~\var{m.value}} \Big(\alldifferent{} \Big(\getvertices{n}{} \join \getvertices{m}{}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n.value},~\var{m.value}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\getvertices{m}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n.value},~\var{m.value}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\getvertices{m}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{Use params in pattern matching predicates}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-[r]->(b)
WHERE r.foo = $param
RETURN b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Filter out based on node prop name}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[rel:X]-(a)
WHERE a.name = 'Andres'
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{a}} \Big(\selection{\var{a.name} = \literal{''Andres''}} \Big(\alldifferent{} \Big(\expandboth{\_e91}{a}{}{rel}{X}{}{} \Big(\getvertices{\_e91}{}\Big)\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\selection{\var{a.name} = \literal{''Andres''}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandboth{\_e92}{a}{}{rel}{X}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{\_e92}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\selection{\var{a.name} = \literal{''Andres''}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandboth{\_e93}{a}{}{rel}{X}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{\_e93}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Honour the column name for RETURN items}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WITH a.name AS a
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{a}} \Big(\alldifferent{} \Big(\getvertices{a}{}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{Filter based on rel prop name}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (node)-[r:KNOWS]->(a)
WHERE r.name = 'monkey'
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{a}} \Big(\selection{\var{r.name} = \literal{''monkey''}} \Big(\alldifferent{} \Big(\expandout{node}{a}{}{r}{KNOWS}{}{} \Big(\getvertices{node}{}\Big)\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\selection{\var{r.name} = \literal{''monkey''}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{node}{a}{}{r}{KNOWS}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{node}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\selection{\var{r.name} = \literal{''monkey''}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{node}{a}{}{r}{KNOWS}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{node}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Cope with shadowed variables}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WITH n.name AS n
RETURN n
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{n}} \Big(\alldifferent{} \Big(\getvertices{n}{}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{Get neighbours}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n1)-[rel:KNOWS]->(n2)
RETURN n1, n2
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{n1},~\var{n2}} \Big(\alldifferent{} \Big(\expandout{n1}{n2}{}{rel}{KNOWS}{}{} \Big(\getvertices{n1}{}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n1},~\var{n2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{n1}{n2}{}{rel}{KNOWS}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n1},~\var{n2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{n1}{n2}{}{rel}{KNOWS}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{Get two related nodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[rel:KNOWS]->(x)
RETURN x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{x}} \Big(\alldifferent{} \Big(\expandout{\_e94}{x}{}{rel}{KNOWS}{}{} \Big(\getvertices{\_e94}{}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{x}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e95}{x}{}{rel}{KNOWS}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{\_e95}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{x}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e96}{x}{}{rel}{KNOWS}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{\_e96}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{Get related to related to}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)-->(a)-->(b)
RETURN b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handle comparison between node properties}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)-[rel]->(x)
WHERE n.animal = x.animal
RETURN n, x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{n},~\var{x}} \Big(\selection{\var{n.animal} = \var{x.animal}} \Big(\alldifferent{} \Big(\expandout{n}{x}{}{rel}{}{}{} \Big(\getvertices{n}{}\Big)\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n},~\var{x}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\selection{\var{n.animal} = \var{x.animal}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{n}{x}{}{rel}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n},~\var{x}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\selection{\var{n.animal} = \var{x.animal}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{n}{x}{}{rel}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Return two subgraphs with bound undirected relationship}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-[r {name: 'r'}]-(b)
RETURN a, b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{a},~\var{b}} \Big(\alldifferent{} \Big(\expandboth{a}{b}{}{r}{}{}{} \Big(\getvertices{a}{}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandboth{a}{b}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandboth{a}{b}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{Return two subgraphs with bound undirected relationship and optional relationship}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-[r {name: 'r1'}]-(b)
OPTIONAL MATCH (b)-[r2]-(c)
WHERE r <> r2
RETURN a, b, c
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{a},~\var{b},~\var{c}} \Big(\alldifferent{} \Big(\expandboth{a}{b}{}{r}{}{}{} \Big(\getvertices{a}{}\Big)\Big) \join \selection{\var{r} \neq \var{r2}} \Big(\alldifferent{} \Big(\expandboth{b}{c}{}{r2}{}{}{} \Big(\getvertices{b}{}\Big)\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b},~\var{c}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandboth{a}{b}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\selection{\var{r} \neq \var{r2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandboth{b}{c}{}{r2}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{b}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b},~\var{c}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandboth{a}{b}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\selection{\var{r} \neq \var{r2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandboth{b}{c}{}{r2}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{b}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
\subsection{Rel type function works as expected}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n {name: 'A'})-[r]->(x)
WHERE type(r) = 'KNOWS'
RETURN x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Walk alternative relationships}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)-[r]->(x)
WHERE type(r) = 'KNOWS' OR type(r) = 'HATES'
RETURN r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handle OR in the WHERE clause}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WHERE n.p1 = 12 OR n.p2 = 13
RETURN n
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{n}} \Big(\selection{\var{n.p1} = \literal{12} \lor \var{n.p2} = \literal{13}} \Big(\alldifferent{} \Big(\getvertices{n}{}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\selection{\var{n.p1} = \literal{12} \lor \var{n.p2} = \literal{13}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\selection{\var{n.p1} = \literal{12} \lor \var{n.p2} = \literal{13}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{Return a simple path}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (a {name: 'A'})-->(b)
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Return a three node path}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (a {name: 'A'})-[rel1]->(b)-[rel2]->(c)
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Do not return anything because path length does not match}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (n)-->(x)
WHERE length(p) = 10
RETURN x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Pass the path length test}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (n)-->(x)
WHERE length(p) = 1
RETURN x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Return relationships by fetching them from the path - starting from the end}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (a)-[:REL*2..2]->(b:End)
RETURN relationships(p)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Return relationships by fetching them from the path}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (a:Start)-[:REL*2..2]->(b)
RETURN relationships(p)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Return relationships by collecting them as a list - wrong way}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-[r:REL*2..2]->(b:End)
RETURN r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{r}} \Big(\alldifferent{} \Big(\expandout{a}{b}{End}{r}{REL}{}{} \Big(\getvertices{a}{}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{b}{End}{r}{REL}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{b}{End}{r}{REL}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{Return relationships by collecting them as a list - undirected}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-[r:REL*2..2]-(b:End)
RETURN r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{r}} \Big(\alldifferent{} \Big(\expandboth{a}{b}{End}{r}{REL}{}{} \Big(\getvertices{a}{}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandboth{a}{b}{End}{r}{REL}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandboth{a}{b}{End}{r}{REL}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{Return relationships by collecting them as a list}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:Start)-[r:REL*2..2]-(b)
RETURN r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{r}} \Big(\alldifferent{} \Big(\expandboth{a}{b}{}{r}{REL}{}{} \Big(\getvertices{a}{Start}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandboth{a}{b}{}{r}{REL}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{Start}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandboth{a}{b}{}{r}{REL}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{Start}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{Return a var length path}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (n {name: 'A'})-[:KNOWS*1..2]->(x)
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Return a var length path of length zero}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (a)-[*0..1]->(b)
RETURN a, b, length(p) AS l
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Return a named var length path of length zero}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (a {name: 'A'})-[:KNOWS*0..1]->(b)-[:FRIEND*0..1]->(c)
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Accept skip zero}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WHERE 1 = 0
RETURN n SKIP 0
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{n}} \Big(\selection{\literal{1} = \literal{0}} \Big(\alldifferent{} \Big(\getvertices{n}{}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\selection{\literal{1} = \literal{0}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\selection{\literal{1} = \literal{0}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\section{MatchAcceptance2}

\subsection{Do not return non-existent nodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{n}} \Big(\alldifferent{} \Big(\getvertices{n}{}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{Do not return non-existent relationships}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[r]->()
RETURN r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{r}} \Big(\alldifferent{} \Big(\expandout{\_e97}{\_e98}{}{r}{}{}{} \Big(\getvertices{\_e97}{}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e99}{\_e100}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{\_e99}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e101}{\_e102}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{\_e101}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{Do not fail when evaluating predicates with illegal operations if the AND'ed predicate evaluates to false}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (:Root {name: 'x'})-->(i:TextNode)
WHERE i.id > 'te'
RETURN i
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Do not fail when evaluating predicates with illegal operations if the OR'd predicate evaluates to true}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (:Root {name: 'x'})-->(i)
WHERE exists(i.id) OR i.id > 'te'
RETURN i
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Aggregation with named paths}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = ()-[*]->()
WITH count(*) AS count, p AS p
WITH nodes(p) AS nodes
RETURN *
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Zero-length variable length pattern in the middle of the pattern}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a {name: 'A'})-[:CONTAINS*0..1]->(b)-[:FRIEND*0..1]->(c)
RETURN a, b, c
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{a},~\var{b},~\var{c}} \Big(\alldifferent{} \Big(\expandout{b}{c}{}{\_e110}{FRIEND}{}{} \Big(\expandout{a}{b}{}{\_e109}{CONTAINS}{}{} \Big(\getvertices{a}{}\Big)\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b},~\var{c}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{b}{c}{}{\_e112}{FRIEND}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{b}{}{\_e111}{CONTAINS}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b},~\var{c}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{b}{c}{}{\_e114}{FRIEND}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{b}{}{\_e113}{CONTAINS}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Simple variable length pattern}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a {name: 'A'})-[*]->(x)
RETURN x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{x}} \Big(\alldifferent{} \Big(\expandout{a}{x}{}{\_e115}{}{}{} \Big(\getvertices{a}{}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{x}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{x}{}{\_e116}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{x}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{x}{}{\_e117}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{Variable length relationship without lower bound}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = ({name: 'A'})-[:KNOWS*..2]->()
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Variable length relationship without bounds}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = ({name: 'A'})-[:KNOWS*..]->()
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Returning bound nodes that are not part of the pattern}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a {name: 'A'}), (c {name: 'C'})
MATCH (a)-->(b)
RETURN a, b, c
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Two bound nodes pointing to the same node}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a {name: 'A'}), (b {name: 'B'})
MATCH (a)-->(x)<-->(b)
RETURN x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Three bound nodes pointing to the same node}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a {name: 'A'}), (b {name: 'B'}), (c {name: 'C'})
MATCH (a)-->(x), (b)-->(x), (c)-->(x)
RETURN x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Three bound nodes pointing to the same node with extra connections}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a {name: 'a'}), (b {name: 'b'}), (c {name: 'c'})
MATCH (a)-->(x), (b)-->(x), (c)-->(x)
RETURN x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{MATCH with OPTIONAL MATCH in longer pattern}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a {name: 'A'})
OPTIONAL MATCH (a)-[:KNOWS]->()-[:KNOWS]->(foo)
RETURN foo
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{foo}} \Big(\alldifferent{} \Big(\getvertices{a}{}\Big) \join \alldifferent{} \Big(\expandout{\_e118}{foo}{}{\_e120}{KNOWS}{}{} \Big(\expandout{a}{\_e118}{}{\_e119}{KNOWS}{}{} \Big(\getvertices{a}{}\Big)\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{foo}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e121}{foo}{}{\_e123}{KNOWS}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{\_e121}{}{\_e122}{KNOWS}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{foo}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e124}{foo}{}{\_e126}{KNOWS}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{\_e124}{}{\_e125}{KNOWS}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
\subsection{Optionally matching named paths}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a {name: 'A'}), (x)
WHERE x.name IN ['B', 'C']
OPTIONAL MATCH p = (a)-->(x)
RETURN x, p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Optionally matching named paths with single and variable length patterns}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a {name: 'A'})
OPTIONAL MATCH p = (a)-->(b)-[*]->(c)
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Optionally matching named paths with variable length patterns}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a {name: 'A'}), (x)
WHERE x.name IN ['B', 'C']
OPTIONAL MATCH p = (a)-[r*]->(x)
RETURN r, x, p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Matching variable length patterns from a bound node}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[r*2]->()
RETURN r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{r}} \Big(\alldifferent{} \Big(\getvertices{a}{A}\Big) \join \alldifferent{} \Big(\expandout{a}{\_e127}{}{r}{}{}{} \Big(\getvertices{a}{A}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{\_e128}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{\_e129}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Excluding connected nodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A), (other:B)
OPTIONAL MATCH (a)-[r]->(other)
WITH other WHERE r IS NULL
RETURN other
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{other}} \Big(\alldifferent{} \Big(\getvertices{a}{A} \join \getvertices{other}{B}\Big) \join \alldifferent{} \Big(\expandout{a}{other}{B}{r}{}{}{} \Big(\getvertices{a}{A}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{other}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\getvertices{other}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{other}{B}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{other}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\getvertices{other}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{other}{B}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Do not fail when predicates on optionally matched and missed nodes are invalid}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)-->(x0)
OPTIONAL MATCH (x0)-->(x1)
WHERE x1.foo = 'bar'
RETURN x0.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{MATCH and OPTIONAL MATCH on same pattern}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-->(b)
WHERE b:B
OPTIONAL MATCH (a)-->(c)
WHERE c:C
RETURN a.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Matching using an undirected pattern}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-[:ADMIN]-(b)
WHERE a:A
RETURN a.id, b.id
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Matching all nodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{n}} \Big(\alldifferent{} \Big(\getvertices{n}{}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{Comparing nodes for equality}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a), (b)
WHERE a <> b
RETURN a, b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{a},~\var{b}} \Big(\selection{\var{a} \neq \var{b}} \Big(\alldifferent{} \Big(\getvertices{a}{} \join \getvertices{b}{}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\selection{\var{a} \neq \var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\getvertices{b}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\selection{\var{a} \neq \var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\getvertices{b}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Matching using self-referencing pattern returns no result}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-->(b), (b)-->(b)
RETURN b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Variable length relationship in OPTIONAL MATCH}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A), (b:B)
OPTIONAL MATCH (a)-[r*]-(b)
WHERE r IS NULL
  AND a <> b
RETURN b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Matching using relationship predicate with multiples of the same type}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-[:T|:T]->(b)
RETURN b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{b}} \Big(\alldifferent{} \Big(\expandout{a}{b}{}{\_e133}{T}{}{} \Big(\getvertices{a}{}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{b}{}{\_e134}{T}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{b}{}{\_e135}{T}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{ORDER BY with LIMIT}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-->(n)-->(m)
RETURN n.x, count(*)
  ORDER BY n.x
  LIMIT 1000
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Simple node property predicate}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WHERE n.foo = 'bar'
RETURN n
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{n}} \Big(\selection{\var{n.foo} = \literal{''bar''}} \Big(\alldifferent{} \Big(\getvertices{n}{}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\selection{\var{n.foo} = \literal{''bar''}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\selection{\var{n.foo} = \literal{''bar''}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{Handling direction of named paths}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (b)<--(a)
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Simple OPTIONAL MATCH on empty graph}

\subsubsection*{Query specification}

\begin{lstlisting}
OPTIONAL MATCH (n)
RETURN n
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{n}} \Big(\alldifferent{} \Big(\getvertices{n}{}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{OPTIONAL MATCH with previously bound nodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
OPTIONAL MATCH (n)-[:NOT_EXIST]->(x)
RETURN n, x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{n},~\var{x}} \Big(\alldifferent{} \Big(\getvertices{n}{}\Big) \join \alldifferent{} \Big(\expandout{n}{x}{}{\_e136}{NOT\_EXIST}{}{} \Big(\getvertices{n}{}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n},~\var{x}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{n}{x}{}{\_e137}{NOT\_EXIST}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n},~\var{x}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{n}{x}{}{\_e138}{NOT\_EXIST}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{`collect()` filtering nulls}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
OPTIONAL MATCH (n)-[:NOT_EXIST]->(x)
RETURN n, collect(x)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Multiple anonymous nodes in a pattern}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)<--()<--(b)-->()-->(c)
WHERE a:A
RETURN c
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Matching a relationship pattern using a label predicate}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-->(b:Foo)
RETURN b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Matching a relationship pattern using a label predicate on both sides}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (:A)-[r]->(:B)
RETURN r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{r}} \Big(\alldifferent{} \Big(\expandout{\_e145}{\_e146}{B}{r}{}{}{} \Big(\getvertices{\_e145}{A}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e147}{\_e148}{B}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{\_e147}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e149}{\_e150}{B}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{\_e149}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{Matching nodes using multiple labels}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A:B:C)
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{a}} \Big(\alldifferent{} \Big(\getvertices{a}{A:B:C}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A:B:C}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A:B:C}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{Returning label predicate expression}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN (n:Foo)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Matching with many predicates and larger pattern}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (advertiser)-[:ADV_HAS_PRODUCT]->(out)-[:AP_HAS_VALUE]->(red)<-[:AA_HAS_VALUE]-(a)
WHERE advertiser.id = $1
  AND a.id = $2
  AND red.name = 'red'
  AND out.name = 'product1'
RETURN out.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Returning label predicate expression}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN (n:Foo)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Matching using a simple pattern with label predicate}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n:Person)-->()
WHERE n.name = 'Bob'
RETURN n
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Matching disconnected patterns}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-->(b)
MATCH (c)-->(d)
RETURN a, b, c, d
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Non-optional matches should not return nulls}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)--(b)--(c)--(d)--(a), (b)--(d)
WHERE a.id = 1
  AND c.id = 2
RETURN d
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handling cyclic patterns}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-[:A]->()-[:B]->(a)
RETURN a.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{a.name}} \Big(\alldifferent{} \Big(\expandout{\_e163}{a}{}{\_e165}{B}{}{} \Big(\expandout{a}{\_e163}{}{\_e164}{A}{}{} \Big(\getvertices{a}{}\Big)\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e166}{a}{}{\_e168}{B}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{\_e166}{}{\_e167}{A}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e169}{a}{}{\_e171}{B}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{\_e169}{}{\_e170}{A}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Handling cyclic patterns when separated into two parts}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-[:A]->(b), (b)-[:B]->(a)
RETURN a.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{a.name}} \Big(\alldifferent{} \Big(\expandout{a}{b}{}{\_e172}{A}{}{} \Big(\getvertices{a}{}\Big) \join \expandout{b}{a}{}{\_e173}{B}{}{} \Big(\getvertices{b}{}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{b}{}{\_e174}{A}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\expandout{b}{a}{}{\_e175}{B}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{b}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{b}{}{\_e176}{A}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\expandout{b}{a}{}{\_e177}{B}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{b}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Handling fixed-length variable length pattern}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-[r*1..1]->(b)
RETURN r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{r}} \Big(\alldifferent{} \Big(\expandout{a}{b}{}{r}{}{}{} \Big(\getvertices{a}{}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{b}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{b}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{Matching from null nodes should return no results owing to finding no matches}

\subsubsection*{Query specification}

\begin{lstlisting}
OPTIONAL MATCH (a)
WITH a
MATCH (a)-->(b)
RETURN b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Matching from null nodes should return no results owing to matches being filtered out}

\subsubsection*{Query specification}

\begin{lstlisting}
OPTIONAL MATCH (a:Label)
WITH a
MATCH (a)-->(b)
RETURN b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Optionally matching from null nodes should return null}

\subsubsection*{Query specification}

\begin{lstlisting}
OPTIONAL MATCH (a)
WITH a
OPTIONAL MATCH (a)-->(b)
RETURN b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{OPTIONAL MATCH returns null}

\subsubsection*{Query specification}

\begin{lstlisting}
OPTIONAL MATCH (a)
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{a}} \Big(\alldifferent{} \Big(\getvertices{a}{}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{Zero-length named path}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (a)
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Variable-length named path}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = ()-[*0..]->()
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Matching with aggregation}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n.prop AS n, count(n) AS count
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Matching using a relationship that is already bound}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[r1]->()
WITH r1 AS r2
MATCH ()-[r2]->()
RETURN r2 AS rel
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{r2}} \Big(\alldifferent{} \Big(\expandout{\_e178}{\_e179}{}{r1}{}{}{} \Big(\getvertices{\_e178}{}\Big)\Big) \join \alldifferent{} \Big(\expandout{\_e180}{\_e181}{}{r2}{}{}{} \Big(\getvertices{\_e180}{}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{r2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e182}{\_e183}{}{r1}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{\_e182}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e184}{\_e185}{}{r2}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{\_e184}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{r2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e186}{\_e187}{}{r1}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{\_e186}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e188}{\_e189}{}{r2}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{\_e188}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Matching using a relationship that is already bound, in conjunction with aggregation}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[r1]->()
WITH r1 AS r2, count(*) AS c
  ORDER BY c
MATCH ()-[r2]->()
RETURN r2 AS rel
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{r2}} \Big(\alldifferent{} \Big(\expandout{\_e190}{\_e191}{}{r1}{}{}{} \Big(\getvertices{\_e190}{}\Big)\Big) \join \alldifferent{} \Big(\expandout{\_e192}{\_e193}{}{r2}{}{}{} \Big(\getvertices{\_e192}{}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{r2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e194}{\_e195}{}{r1}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{\_e194}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e196}{\_e197}{}{r2}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{\_e196}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{r2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e198}{\_e199}{}{r1}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{\_e198}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e200}{\_e201}{}{r2}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{\_e200}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Matching using a relationship that is already bound, in conjunction with aggregation and ORDER BY}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-[r]->(b)
WITH a, r, b, count(*) AS c
  ORDER BY c
MATCH (a)-[r]->(b)
RETURN r AS rel
  ORDER BY rel.id
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{r}} \Big(\alldifferent{} \Big(\expandout{a}{b}{}{r}{}{}{} \Big(\getvertices{a}{}\Big)\Big) \join \alldifferent{} \Big(\expandout{a}{b}{}{r}{}{}{} \Big(\getvertices{a}{}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{b}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{b}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{b}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{b}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Matching with LIMIT and optionally matching using a relationship that is already bound}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[r]->()
WITH r
  LIMIT 1
OPTIONAL MATCH (a2)-[r]->(b2)
RETURN a2, r, b2
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{a2},~\var{r},~\var{b2}} \Big(\alldifferent{} \Big(\expandout{\_e202}{\_e203}{}{r}{}{}{} \Big(\getvertices{\_e202}{}\Big)\Big) \join \alldifferent{} \Big(\expandout{a2}{b2}{}{r}{}{}{} \Big(\getvertices{a2}{}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a2},~\var{r},~\var{b2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e204}{\_e205}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{\_e204}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a2}{b2}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a2}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a2},~\var{r},~\var{b2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e206}{\_e207}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{\_e206}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a2}{b2}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a2}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Matching with LIMIT and optionally matching using a relationship and node that are both already bound}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a1)-[r]->()
WITH r, a1
  LIMIT 1
OPTIONAL MATCH (a1)-[r]->(b2)
RETURN a1, r, b2
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{a1},~\var{r},~\var{b2}} \Big(\alldifferent{} \Big(\expandout{a1}{\_e208}{}{r}{}{}{} \Big(\getvertices{a1}{}\Big)\Big) \join \alldifferent{} \Big(\expandout{a1}{b2}{}{r}{}{}{} \Big(\getvertices{a1}{}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a1},~\var{r},~\var{b2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a1}{\_e209}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a1}{b2}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a1},~\var{r},~\var{b2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a1}{\_e210}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a1}{b2}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Matching with LIMIT, then matching again using a relationship and node that are both already bound along with an additional predicate}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a1)-[r]->()
WITH r, a1
  LIMIT 1
MATCH (a1:X)-[r]->(b2)
RETURN a1, r, b2
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{a1},~\var{r},~\var{b2}} \Big(\alldifferent{} \Big(\expandout{a1}{\_e211}{}{r}{}{}{} \Big(\getvertices{a1}{X}\Big)\Big) \join \alldifferent{} \Big(\expandout{a1}{b2}{}{r}{}{}{} \Big(\getvertices{a1}{X}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a1},~\var{r},~\var{b2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a1}{\_e212}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a1}{X}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a1}{b2}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a1}{X}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a1},~\var{r},~\var{b2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a1}{\_e213}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a1}{X}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a1}{b2}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a1}{X}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Matching with LIMIT and predicates, then matching again using a relationship and node that are both already bound along with a duplicate predicate}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a1:X:Y)-[r]->()
WITH r, a1
  LIMIT 1
MATCH (a1:Y)-[r]->(b2)
RETURN a1, r, b2
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{a1},~\var{r},~\var{b2}} \Big(\alldifferent{} \Big(\expandout{a1}{\_e214}{}{r}{}{}{} \Big(\getvertices{a1}{X:Y}\Big)\Big) \join \alldifferent{} \Big(\expandout{a1}{b2}{}{r}{}{}{} \Big(\getvertices{a1}{X:Y}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a1},~\var{r},~\var{b2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a1}{\_e215}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a1}{X:Y}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a1}{b2}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a1}{X:Y}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a1},~\var{r},~\var{b2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a1}{\_e216}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a1}{X:Y}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a1}{b2}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a1}{X:Y}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Matching twice with conflicting relationship types on same relationship}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a1)-[r:T]->()
WITH r, a1
  LIMIT 1
MATCH (a1)-[r:Y]->(b2)
RETURN a1, r, b2
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{a1},~\var{r},~\var{b2}} \Big(\alldifferent{} \Big(\expandout{a1}{\_e217}{}{r}{T \lor Y}{}{} \Big(\getvertices{a1}{}\Big)\Big) \join \alldifferent{} \Big(\expandout{a1}{b2}{}{r}{T \lor Y}{}{} \Big(\getvertices{a1}{}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a1},~\var{r},~\var{b2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a1}{\_e218}{}{r}{T \lor Y}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a1}{b2}{}{r}{T \lor Y}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a1},~\var{r},~\var{b2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a1}{\_e219}{}{r}{T \lor Y}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a1}{b2}{}{r}{T \lor Y}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Matching twice with duplicate relationship types on same relationship}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a1)-[r:T]->() WITH r, a1
LIMIT 1
MATCH (a1)-[r:T]->(b2)
RETURN a1, r, b2
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{a1},~\var{r},~\var{b2}} \Big(\alldifferent{} \Big(\expandout{a1}{\_e220}{}{r}{T}{}{} \Big(\getvertices{a1}{}\Big)\Big) \join \alldifferent{} \Big(\expandout{a1}{b2}{}{r}{T}{}{} \Big(\getvertices{a1}{}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a1},~\var{r},~\var{b2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a1}{\_e221}{}{r}{T}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a1}{b2}{}{r}{T}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a1},~\var{r},~\var{b2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a1}{\_e222}{}{r}{T}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a1}{b2}{}{r}{T}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Matching relationships into a list and matching variable length using the list}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[r1]->()-[r2]->()
WITH [r1, r2] AS rs
  LIMIT 1
MATCH (first)-[rs*]->(second)
RETURN first, second
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{first},~\var{second}} \Big(\alldifferent{} \Big(\expandout{\_e224}{\_e225}{}{r2}{}{}{} \Big(\expandout{\_e223}{\_e224}{}{r1}{}{}{} \Big(\getvertices{\_e223}{}\Big)\Big)\Big) \join \alldifferent{} \Big(\expandout{first}{second}{}{rs}{}{}{} \Big(\getvertices{first}{}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{first},~\var{second}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e227}{\_e228}{}{r2}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e226}{\_e227}{}{r1}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{\_e226}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{first}{second}{}{rs}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{first}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{first},~\var{second}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e230}{\_e231}{}{r2}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e229}{\_e230}{}{r1}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{\_e229}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{first}{second}{}{rs}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{first}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Matching relationships into a list and matching variable length using the list, with bound nodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-[r1]->()-[r2]->(b)
WITH [r1, r2] AS rs, a AS first, b AS second
  LIMIT 1
MATCH (first)-[rs*]->(second)
RETURN first, second
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{first},~\var{second}} \Big(\alldifferent{} \Big(\expandout{\_e232}{b}{}{r2}{}{}{} \Big(\expandout{a}{\_e232}{}{r1}{}{}{} \Big(\getvertices{a}{}\Big)\Big)\Big) \join \alldifferent{} \Big(\expandout{first}{second}{}{rs}{}{}{} \Big(\getvertices{first}{}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{first},~\var{second}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e233}{b}{}{r2}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{\_e233}{}{r1}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{first}{second}{}{rs}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{first}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{first},~\var{second}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e234}{b}{}{r2}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{\_e234}{}{r1}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{first}{second}{}{rs}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{first}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Matching relationships into a list and matching variable length using the list, with bound nodes, wrong direction}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-[r1]->()-[r2]->(b)
WITH [r1, r2] AS rs, a AS second, b AS first
  LIMIT 1
MATCH (first)-[rs*]->(second)
RETURN first, second
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{first},~\var{second}} \Big(\alldifferent{} \Big(\expandout{\_e235}{b}{}{r2}{}{}{} \Big(\expandout{a}{\_e235}{}{r1}{}{}{} \Big(\getvertices{a}{}\Big)\Big)\Big) \join \alldifferent{} \Big(\expandout{first}{second}{}{rs}{}{}{} \Big(\getvertices{first}{}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{first},~\var{second}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e236}{b}{}{r2}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{\_e236}{}{r1}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{first}{second}{}{rs}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{first}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{first},~\var{second}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e237}{b}{}{r2}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{\_e237}{}{r1}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{first}{second}{}{rs}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{first}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Matching and optionally matching with bound nodes in reverse direction}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a1)-[r]->()
WITH r, a1
  LIMIT 1
OPTIONAL MATCH (a1)<-[r]-(b2)
RETURN a1, r, b2
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{a1},~\var{r},~\var{b2}} \Big(\alldifferent{} \Big(\expandout{a1}{\_e238}{}{r}{}{}{} \Big(\getvertices{a1}{}\Big)\Big) \join \alldifferent{} \Big(\expandin{a1}{b2}{}{r}{}{}{} \Big(\getvertices{a1}{}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a1},~\var{r},~\var{b2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a1}{\_e239}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandin{a1}{b2}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a1},~\var{r},~\var{b2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a1}{\_e240}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandin{a1}{b2}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Matching and optionally matching with unbound nodes and equality predicate in reverse direction}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a1)-[r]->()
WITH r, a1
  LIMIT 1
OPTIONAL MATCH (a2)<-[r]-(b2)
WHERE a1 = a2
RETURN a1, r, b2, a2
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{a1},~\var{r},~\var{b2},~\var{a2}} \Big(\alldifferent{} \Big(\expandout{a1}{\_e241}{}{r}{}{}{} \Big(\getvertices{a1}{}\Big)\Big) \join \selection{\var{a1} = \var{a2}} \Big(\alldifferent{} \Big(\expandin{a2}{b2}{}{r}{}{}{} \Big(\getvertices{a2}{}\Big)\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a1},~\var{r},~\var{b2},~\var{a2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a1}{\_e242}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\selection{\var{a1} = \var{a2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandin{a2}{b2}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a2}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a1},~\var{r},~\var{b2},~\var{a2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a1}{\_e243}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\selection{\var{a1} = \var{a2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandin{a2}{b2}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a2}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
\subsection{Matching and returning ordered results, with LIMIT}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (foo)
RETURN foo.bar AS x
  ORDER BY x DESC
  LIMIT 4
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{foo.bar}} \Big(\alldifferent{} \Big(\getvertices{foo}{}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{foo.bar}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{foo}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{foo.bar}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{foo}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{Counting an empty graph}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
RETURN count(a) > 0
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Matching variable length pattern with property predicate}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:Artist)-[:WORKED_WITH* {year: 1988}]->(b:Artist)
RETURN *
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{} \Big(\alldifferent{} \Big(\expandout{a}{b}{Artist}{\_e244}{WORKED\_WITH}{}{} \Big(\getvertices{a}{Artist}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{b}{Artist}{\_e245}{WORKED\_WITH}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{Artist}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{b}{Artist}{\_e246}{WORKED\_WITH}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{Artist}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{Variable length pattern checking labels on endnodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a), (b)
WHERE a.id = 0
  AND (a)-[:T]->(b:Label)
  OR (a)-[:T*]->(b:MissingLabel)
RETURN DISTINCT b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \duplicateelimination \Big(\projection{\var{b}} \Big(\selection{\var{a.id} = \literal{0} \land \var{a} IS NOT NULL \land \var{_e247} IS NOT NULL \land \var{b} IS NOT NULL \lor \var{a} IS NOT NULL \land \var{_e248} IS NOT NULL \land \var{b} IS NOT NULL} \Big(\alldifferent{} \Big(\getvertices{a}{} \join \getvertices{b}{Label:MissingLabel}\Big) \leftouterjoin \expandout{a}{b}{Label \land MissingLabel}{\_e247}{T}{}{} \Big(\getvertices{a}{}\Big) \leftouterjoin \expandout{a}{b}{Label \land MissingLabel}{\_e248}{T}{}{} \Big(\getvertices{a}{}\Big)\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\duplicateelimination$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\projection{\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\selection{\var{a.id} = \literal{0} \land \var{a} IS NOT NULL \land \var{_e249} IS NOT NULL \land \var{b} IS NOT NULL \lor \var{a} IS NOT NULL \land \var{_e250} IS NOT NULL \land \var{b} IS NOT NULL}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\leftouterjoin$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\leftouterjoin$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\getvertices{b}{Label:MissingLabel}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{a}{b}{Label \land MissingLabel}{\_e249}{T}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{a}{b}{Label \land MissingLabel}{\_e250}{T}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\duplicateelimination$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\projection{\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\selection{\var{a.id} = \literal{0} \land \var{a} IS NOT NULL \land \var{_e251} IS NOT NULL \land \var{b} IS NOT NULL \lor \var{a} IS NOT NULL \land \var{_e252} IS NOT NULL \land \var{b} IS NOT NULL}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\leftouterjoin$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\leftouterjoin$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\getvertices{b}{Label:MissingLabel}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{a}{b}{Label \land MissingLabel}{\_e251}{T}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\expandout{a}{b}{Label \land MissingLabel}{\_e252}{T}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
\subsection{Variable length pattern with label predicate on both sides}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:Blue)-[r*]->(b:Green)
RETURN count(r)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Undirected named path}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (n:Movie)--(m)
RETURN p
  LIMIT 1
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Named path with WITH}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (a)
WITH p
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Named path with alternating directed/undirected relationships}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (n)-->(m)--(o)
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Named path with multiple alternating directed/undirected relationships}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH path = (n)-->(m)--(o)--(p)
RETURN path
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Named path with undirected fixed variable length pattern}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH topRoute = (:Start)<-[:CONNECTED_TO]-()-[:CONNECTED_TO*3..3]-(:End)
RETURN topRoute
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Returning a node property value}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
RETURN a.prop
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{a.prop}} \Big(\alldifferent{} \Big(\getvertices{a}{}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a.prop}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a.prop}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{Returning a relationship property value}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[r]->()
RETURN r.prop
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{r.prop}} \Big(\alldifferent{} \Big(\expandout{\_e253}{\_e254}{}{r}{}{}{} \Big(\getvertices{\_e253}{}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{r.prop}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e255}{\_e256}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{\_e255}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{r.prop}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e257}{\_e258}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{\_e257}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{Projecting nodes and relationships}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-[r]->()
RETURN a AS foo, r AS bar
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{a},~\var{r}} \Big(\alldifferent{} \Big(\expandout{a}{\_e259}{}{r}{}{}{} \Big(\getvertices{a}{}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{\_e260}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{\_e261}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{Missing node property should become null}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
RETURN a.bar
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{a.bar}} \Big(\alldifferent{} \Big(\getvertices{a}{}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a.bar}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a.bar}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{Missing relationship property should become null}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[r]->()
RETURN r.bar
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{r.bar}} \Big(\alldifferent{} \Big(\expandout{\_e262}{\_e263}{}{r}{}{}{} \Big(\getvertices{\_e262}{}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{r.bar}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e264}{\_e265}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{\_e264}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{r.bar}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e266}{\_e267}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{\_e266}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{Returning multiple node property values}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
RETURN a.name, a.age, a.seasons
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{a.name},~\var{a.age},~\var{a.seasons}} \Big(\alldifferent{} \Big(\getvertices{a}{}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a.name},~\var{a.age},~\var{a.seasons}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a.name},~\var{a.age},~\var{a.seasons}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{Adding a property and a literal in projection}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
RETURN a.prop + 1 AS foo
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Adding list properties in projection}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
RETURN a.prop2 + a.prop1 AS foo
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Variable length relationship variables are lists of relationships}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[r*0..1]-()
RETURN last(r) AS l
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Variable length patterns and nulls}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
OPTIONAL MATCH (a)-[:FOO]->(b:B)
OPTIONAL MATCH (b)<-[:BAR*]-(c:B)
RETURN a, b, c
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{a},~\var{b},~\var{c}} \Big(\alldifferent{} \Big(\getvertices{a}{A}\Big) \join \alldifferent{} \Big(\expandout{a}{b}{B}{\_e274}{FOO}{}{} \Big(\getvertices{a}{A}\Big)\Big) \join \alldifferent{} \Big(\expandin{b}{c}{B}{\_e275}{BAR}{}{} \Big(\getvertices{b}{B}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b},~\var{c}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{b}{B}{\_e276}{FOO}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandin{b}{c}{B}{\_e277}{BAR}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{b}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b},~\var{c}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{b}{B}{\_e278}{FOO}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandin{b}{c}{B}{\_e279}{BAR}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{b}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Projecting a list of nodes and relationships}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)-[r]->(m)
RETURN [n, r, m] AS r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Projecting a map of nodes and relationships}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)-[r]->(m)
RETURN {node1: n, rel: r, node2: m} AS m
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Respecting direction when matching existing path}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = ({prop: 'a'})-->({prop: 'b'})
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Respecting direction when matching non-existent path}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = ({prop: 'a'})<--({prop: 'b'})
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Respecting direction when matching non-existent path with multiple directions}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (n)-->(k)<--(n)
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Matching path with both directions should respect other directions}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (n)<-->(k)<--(n)
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Matching path with multiple bidirectional relationships}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p=(n)<-->(k)<-->(n)
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Matching nodes with many labels}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n:A:B:C:D:E:F:G:H:I:J:K:L:M)-[:T]->(m:Z:Y:X:W:V:U)
RETURN n, m
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{n},~\var{m}} \Big(\alldifferent{} \Big(\expandout{n}{m}{Z \land Y \land X \land W \land V \land U}{\_e280}{T}{}{} \Big(\getvertices{n}{A:B:C:D:E:F:G:H:I:J:K:L:M}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n},~\var{m}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{n}{m}{Z \land Y \land X \land W \land V \land U}{\_e281}{T}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{A:B:C:D:E:F:G:H:I:J:K:L:M}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n},~\var{m}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{n}{m}{Z \land Y \land X \land W \land V \land U}{\_e282}{T}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{A:B:C:D:E:F:G:H:I:J:K:L:M}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{Matching longer variable length paths}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n {prop: 'start'})-[:T*]->(m {prop: 'end'})
RETURN m
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{m}} \Big(\alldifferent{} \Big(\expandout{n}{m}{}{\_e283}{T}{}{} \Big(\getvertices{n}{}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{m}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{n}{m}{}{\_e284}{T}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{m}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{n}{m}{}{\_e285}{T}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{Matching a self-loop}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[r]-()
RETURN type(r) AS r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\section{MergeIntoAcceptance}

\section{MergeNodeAcceptance}

\section{MergeRelationshipAcceptance}

\section{MiscellaneousErrorAcceptance}

\section{NullAcceptance}

\section{OptionalMatch}

\subsection{Satisfies the open world assumption, relationships between same nodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (p:Player)-[:PLAYS_FOR]->(team:Team)
OPTIONAL MATCH (p)-[s:SUPPORTS]->(team)
RETURN count(*) AS matches, s IS NULL AS optMatch
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Satisfies the open world assumption, single relationship}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (p:Player)-[:PLAYS_FOR]->(team:Team)
OPTIONAL MATCH (p)-[s:SUPPORTS]->(team)
RETURN count(*) AS matches, s IS NULL AS optMatch
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Satisfies the open world assumption, relationships between different nodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (p:Player)-[:PLAYS_FOR]->(team:Team)
OPTIONAL MATCH (p)-[s:SUPPORTS]->(team)
RETURN count(*) AS matches, s IS NULL AS optMatch
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\section{OptionalMatchAcceptance}

\subsection{Return null when no matches due to inline label predicate}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n:Single)
OPTIONAL MATCH (n)-[r]-(m:NonExistent)
RETURN r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{r}} \Big(\alldifferent{} \Big(\getvertices{n}{Single}\Big) \join \alldifferent{} \Big(\expandboth{n}{m}{NonExistent}{r}{}{}{} \Big(\getvertices{n}{Single}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandboth{n}{m}{NonExistent}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandboth{n}{m}{NonExistent}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Return null when no matches due to label predicate in WHERE}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n:Single)
OPTIONAL MATCH (n)-[r]-(m)
WHERE m:NonExistent
RETURN r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Respect predicates on the OPTIONAL MATCH}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n:Single)
OPTIONAL MATCH (n)-[r]-(m)
WHERE m.prop = 42
RETURN m
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{m}} \Big(\alldifferent{} \Big(\getvertices{n}{Single}\Big) \join \selection{\var{m.prop} = \literal{42}} \Big(\alldifferent{} \Big(\expandboth{n}{m}{}{r}{}{}{} \Big(\getvertices{n}{Single}\Big)\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{m}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\selection{\var{m.prop} = \literal{42}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandboth{n}{m}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{m}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\selection{\var{m.prop} = \literal{42}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandboth{n}{m}{}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
\subsection{Returning label predicate on null node}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n:Single)
OPTIONAL MATCH (n)-[r:TYPE]-(m)
RETURN m:TYPE
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{m}} \Big(\alldifferent{} \Big(\getvertices{n}{Single}\Big) \join \alldifferent{} \Big(\expandboth{n}{m}{}{r}{TYPE}{}{} \Big(\getvertices{n}{Single}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{m}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandboth{n}{m}{}{r}{TYPE}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{m}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandboth{n}{m}{}{r}{TYPE}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{MATCH after OPTIONAL MATCH}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:Single)
OPTIONAL MATCH (a)-->(b:NonExistent)
OPTIONAL MATCH (a)-->(c:NonExistent)
WITH coalesce(b, c) AS x
MATCH (x)-->(d)
RETURN d
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{WITH after OPTIONAL MATCH}

\subsubsection*{Query specification}

\begin{lstlisting}
OPTIONAL MATCH (a:A)
WITH a AS a
MATCH (b:B)
RETURN a, b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{a},~\var{b}} \Big(\alldifferent{} \Big(\getvertices{a}{A}\Big) \join \alldifferent{} \Big(\getvertices{b}{B}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{b}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{b}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{Named paths in optional matches}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
OPTIONAL MATCH p = (a)-[:X]->(b)
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{OPTIONAL MATCH and bound nodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A), (b:C)
OPTIONAL MATCH (x)-->(b)
RETURN x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{OPTIONAL MATCH with labels on the optional end node}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:X)
OPTIONAL MATCH (a)-->(b:Y)
RETURN b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Named paths inside optional matches with node predicates}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A), (b:B)
OPTIONAL MATCH p = (a)-[:X]->(b)
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Variable length optional relationships}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:Single)
OPTIONAL MATCH (a)-[*]->(b)
RETURN b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{b}} \Big(\alldifferent{} \Big(\getvertices{a}{Single}\Big) \join \alldifferent{} \Big(\expandout{a}{b}{}{\_e301}{}{}{} \Big(\getvertices{a}{Single}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{b}{}{\_e302}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{b}{}{\_e303}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Variable length optional relationships with length predicates}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:Single)
OPTIONAL MATCH (a)-[*3..]-(b)
RETURN b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{b}} \Big(\alldifferent{} \Big(\getvertices{a}{Single}\Big) \join \alldifferent{} \Big(\expandboth{a}{b}{}{\_e304}{}{}{} \Big(\getvertices{a}{Single}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandboth{a}{b}{}{\_e305}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandboth{a}{b}{}{\_e306}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Optionally matching self-loops}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:B)
OPTIONAL MATCH (a)-[r]-(a)
RETURN r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{r}} \Big(\alldifferent{} \Big(\getvertices{a}{B}\Big) \join \alldifferent{} \Big(\expandboth{a}{a}{B}{r}{}{}{} \Big(\getvertices{a}{B}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandboth{a}{a}{B}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandboth{a}{a}{B}{r}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Optionally matching self-loops without matches}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE NOT (a:B)
OPTIONAL MATCH (a)-[r]->(a)
RETURN r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Variable length optional relationships with bound nodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:Single), (x:C)
OPTIONAL MATCH (a)-[*]->(x)
RETURN x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{x}} \Big(\alldifferent{} \Big(\getvertices{a}{Single} \join \getvertices{x}{C}\Big) \join \alldifferent{} \Big(\expandout{a}{x}{C}{\_e307}{}{}{} \Big(\getvertices{a}{Single}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{x}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\getvertices{x}{C}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{x}{C}{\_e308}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{x}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\getvertices{x}{C}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{x}{C}{\_e309}{}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Variable length optional relationships with bound nodes, no matches}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A), (b:B)
OPTIONAL MATCH p = (a)-[*]->(b)
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Longer pattern with bound nodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:Single), (c:C)
OPTIONAL MATCH (a)-->(b)-->(c)
RETURN b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Longer pattern with bound nodes without matches}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A), (c:C)
OPTIONAL MATCH (a)-->(b)-->(c)
RETURN b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handling correlated optional matches; first does not match implies second does not match}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A), (b:B)
OPTIONAL MATCH (a)-->(x)
OPTIONAL MATCH (x)-[r]->(b)
RETURN x, r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handling optional matches between optionally matched entities}

\subsubsection*{Query specification}

\begin{lstlisting}
OPTIONAL MATCH (a:NotThere)
WITH a
MATCH (b:B)
WITH a, b
OPTIONAL MATCH (b)-[r:NOR_THIS]->(a)
RETURN a, b, r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{a},~\var{b},~\var{r}} \Big(\alldifferent{} \Big(\getvertices{a}{NotThere}\Big) \join \alldifferent{} \Big(\getvertices{b}{B}\Big) \join \alldifferent{} \Big(\expandout{b}{a}{NotThere}{r}{NOR\_THIS}{}{} \Big(\getvertices{b}{B}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b},~\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{NotThere}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{b}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{b}{a}{NotThere}{r}{NOR\_THIS}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{b}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b},~\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{NotThere}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{b}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{b}{a}{NotThere}{r}{NOR\_THIS}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{b}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Handling optional matches between nulls}

\subsubsection*{Query specification}

\begin{lstlisting}
OPTIONAL MATCH (a:NotThere)
OPTIONAL MATCH (b:NotThere)
WITH a, b
OPTIONAL MATCH (b)-[r:NOR_THIS]->(a)
RETURN a, b, r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{a},~\var{b},~\var{r}} \Big(\alldifferent{} \Big(\getvertices{a}{NotThere}\Big) \join \alldifferent{} \Big(\getvertices{b}{NotThere}\Big) \join \alldifferent{} \Big(\expandout{b}{a}{NotThere}{r}{NOR\_THIS}{}{} \Big(\getvertices{b}{NotThere}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b},~\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{NotThere}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{b}{NotThere}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{b}{a}{NotThere}{r}{NOR\_THIS}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{b}{NotThere}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b},~\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{NotThere}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{b}{NotThere}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{b}{a}{NotThere}{r}{NOR\_THIS}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{b}{NotThere}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{OPTIONAL MATCH and `collect()`}

\subsubsection*{Query specification}

\begin{lstlisting}
OPTIONAL MATCH (f:DoesExist)
OPTIONAL MATCH (n:DoesNotExist)
RETURN collect(DISTINCT n.property) AS a, collect(DISTINCT f.property) AS b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\section{OrderByAcceptance}

\subsection{ORDER BY should return results in ascending order}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n.prop AS prop
ORDER BY n.prop
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{n.prop}} \Big(\alldifferent{} \Big(\getvertices{n}{}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n.prop}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n.prop}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{ORDER BY DESC should return results in descending order}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n.prop AS prop
ORDER BY n.prop DESC
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{n.prop}} \Big(\alldifferent{} \Big(\getvertices{n}{}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n.prop}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n.prop}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{ORDER BY of a column introduced in RETURN should return salient results in ascending order}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH [0, 1] AS prows, [[2], [3, 4]] AS qrows
UNWIND prows AS p
UNWIND qrows[p] AS q
WITH p, count(q) AS rng
RETURN p
ORDER BY rng
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Renaming columns before ORDER BY should return results in ascending order}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n.prop AS n
ORDER BY n + 2
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{n.prop}} \Big(\alldifferent{} \Big(\getvertices{n}{}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n.prop}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n.prop}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{Handle projections with ORDER BY - GH\#4937}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (c:Crew {name: 'Neo'})
WITH c, 0 AS relevance
RETURN c.rank AS rank
ORDER BY relevance, c.rank
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{c.rank}} \Big(\alldifferent{} \Big(\getvertices{c}{Crew}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.rank}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{c}{Crew}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.rank}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{c}{Crew}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{ORDER BY should order booleans in the expected order}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND [true, false] AS bools
RETURN bools
ORDER BY bools
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{ORDER BY DESC should order booleans in the expected order}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND [true, false] AS bools
RETURN bools
ORDER BY bools DESC
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{ORDER BY should order strings in the expected order}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND ['.*', '', ' ', 'one'] AS strings
RETURN strings
ORDER BY strings
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{ORDER BY DESC should order strings in the expected order}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND ['.*', '', ' ', 'one'] AS strings
RETURN strings
ORDER BY strings DESC
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{ORDER BY should order ints in the expected order}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND [1, 3, 2] AS ints
RETURN ints
ORDER BY ints
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{ORDER BY DESC should order ints in the expected order}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND [1, 3, 2] AS ints
RETURN ints
ORDER BY ints DESC
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{ORDER BY should order floats in the expected order}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND [1.5, 1.3, 999.99] AS floats
RETURN floats
ORDER BY floats
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{ORDER BY DESC should order floats in the expected order}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND [1.5, 1.3, 999.99] AS floats
RETURN floats
ORDER BY floats DESC
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handle ORDER BY with LIMIT 1}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (p:Person)
RETURN p.name AS name
ORDER BY p.name
LIMIT 1
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{p.name}} \Big(\alldifferent{} \Big(\getvertices{p}{Person}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{p.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{p}{Person}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{p.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{p}{Person}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{ORDER BY with LIMIT 0 should not generate errors}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (p:Person)
RETURN p.name AS name
ORDER BY p.name
LIMIT 0
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{p.name}} \Big(\alldifferent{} \Big(\getvertices{p}{Person}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{p.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{p}{Person}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{p.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{p}{Person}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{ORDER BY with negative parameter for LIMIT should not generate errors}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (p:Person)
RETURN p.name AS name
ORDER BY p.name
LIMIT $limit
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{p.name}} \Big(\alldifferent{} \Big(\getvertices{p}{Person}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{p.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{p}{Person}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{p.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{p}{Person}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\section{PatternComprehension}

\subsection{Pattern comprehension and ORDER BY}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (liker)
RETURN [p = (liker)--() | p] AS isNew
  ORDER BY liker.time
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Returning a pattern comprehension}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN [p = (n)-->() | p] AS ps
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Returning a pattern comprehension with label predicate}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n:A)
RETURN [p = (n)-->(:B) | p]
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Returning a pattern comprehension with bound nodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A), (b:B)
RETURN [p = (a)-[*]->(b) | p] AS paths
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Using a pattern comprehension in a WITH}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)-->(b)
WITH [p = (n)-->() | p] AS ps, count(b) AS c
RETURN ps, c
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Using a variable-length pattern comprehension in a WITH}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A), (b:B)
WITH [p = (a)-[*]->(b) | p] AS paths, count(a) AS c
RETURN paths, c
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Using pattern comprehension in RETURN}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n:A)
RETURN [p = (n)-[:HAS]->() | p] AS ps
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Aggregating on pattern comprehension}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n:A)
RETURN count([p = (n)-[:HAS]->() | p]) AS c
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Using pattern comprehension to test existence}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n:X)
RETURN n, size([(n)--() | 1]) > 0 AS b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Pattern comprehension inside list comprehension}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (n:X)-->(b)
RETURN n, [x IN nodes(p) | size([(x)-->(:Y) | 1])] AS list
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Get node degree via size of pattern comprehension}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:X)
RETURN size([(a)-->() | 1]) AS length
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Get node degree via size of pattern comprehension that specifies a relationship type}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:X)
RETURN size([(a)-[:T]->() | 1]) AS length
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Get node degree via size of pattern comprehension that specifies multiple relationship types}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:X)
RETURN size([(a)-[:T|OTHER]->() | 1]) AS length
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Introducing new node variable in pattern comprehension}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN [(n)-[:T]->(b) | b.prop] AS list
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Introducing new relationship variable in pattern comprehension}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN [(n)-[r:T]->() | r.prop] AS list
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\section{RemoveAcceptance}

\section{ReturnAcceptanceTest}

\subsection{Allow addition}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a.id = 1337
RETURN a.version + 5
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Limit to two hits}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n
LIMIT 2
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{n}} \Big(\alldifferent{} \Big(\getvertices{n}{}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{Start the result from the second row}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n
ORDER BY n.name ASC
SKIP 2
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{n}} \Big(\alldifferent{} \Big(\getvertices{n}{}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{Start the result from the second row by param}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n
ORDER BY n.name ASC
SKIP $skipAmount
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{n}} \Big(\alldifferent{} \Big(\getvertices{n}{}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{Get rows in the middle}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n
ORDER BY n.name ASC
SKIP 2
LIMIT 2
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{n}} \Big(\alldifferent{} \Big(\getvertices{n}{}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{Get rows in the middle by param}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n
ORDER BY n.name ASC
SKIP $s
LIMIT $l
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{n}} \Big(\alldifferent{} \Big(\getvertices{n}{}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{Sort on aggregated function}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n.division, max(n.age)
  ORDER BY max(n.age)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Support sort and distinct}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
RETURN DISTINCT a
  ORDER BY a.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \duplicateelimination \Big(\projection{\var{a}} \Big(\alldifferent{} \Big(\getvertices{a}{}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\duplicateelimination$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\projection{\var{a}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\duplicateelimination$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\projection{\var{a}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{Support column renaming}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
RETURN a AS ColumnName
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{a}} \Big(\alldifferent{} \Big(\getvertices{a}{}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{Support ordering by a property after being distinct-ified}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-->(b)
RETURN DISTINCT b
  ORDER BY b.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Arithmetic precedence test}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN 12 / 4 * 3 - 2 * 4
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Arithmetic precedence with parenthesis test}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN 12 / 4 * (3 - 2 * 4)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Count star should count everything in scope}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
RETURN a, count(*)
ORDER BY count(*)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Absolute function}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN abs(-1)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Return collection size}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN size([1, 2, 3]) AS n
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\section{ReturnAcceptance2}

\subsection{Accept valid Unicode literal}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN '\u01FF' AS a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{LIMIT 0 should return an empty result}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n
  LIMIT 0
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{n}} \Big(\alldifferent{} \Big(\getvertices{n}{}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{Ordering with aggregation}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n.name, count(*) AS foo
  ORDER BY n.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{DISTINCT on nullable values}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN DISTINCT n.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \duplicateelimination \Big(\projection{\var{n.name}} \Big(\alldifferent{} \Big(\getvertices{n}{}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\duplicateelimination$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\projection{\var{n.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\duplicateelimination$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\projection{\var{n.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{Return all variables}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (a:Start)-->(b)
RETURN *
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`sqrt()` returning float values}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN sqrt(12.96)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Arithmetic expressions inside aggregation}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (me)-[r1:ATE]->()<-[r2:ATE]-(you)
WHERE me.name = 'Michael'
WITH me, count(DISTINCT r1) AS H1, count(DISTINCT r2) AS H2, you
MATCH (me)-[r1:ATE]->()<-[r2:ATE]-(you)
RETURN me, you, sum((1 - abs(r1.times / H1 - r2.times / H2)) * (r1.times + r2.times) / (H1 + H2)) AS sum
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Matching and disregarding output, then matching again}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-->()
WITH 1 AS x
MATCH ()-[r1]->()<--()
RETURN sum(r1.times)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Returning a list property}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{n}} \Big(\alldifferent{} \Big(\getvertices{n}{}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{Returning a projected map}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN {a: 1, b: 'foo'}
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Returning an expression}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
RETURN exists(a.id), a IS NOT NULL
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Concatenating and returning the size of literal lists}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN size([[], []] + [[]]) AS l
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Limiting amount of rows when there are fewer left than the LIMIT argument}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
RETURN a.count
  ORDER BY a.count
  SKIP 10
  LIMIT 10
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`substring()` with default second argument}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN substring('0123456789', 1) AS s
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Returning all variables with ordering}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN *
  ORDER BY n.id
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{} \Big(\alldifferent{} \Big(\getvertices{n}{}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{Using aliased DISTINCT expression in ORDER BY}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN DISTINCT n.id AS id
  ORDER BY id DESC
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \duplicateelimination \Big(\projection{\var{n.id}} \Big(\alldifferent{} \Big(\getvertices{n}{}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\duplicateelimination$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\projection{\var{n.id}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\duplicateelimination$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\projection{\var{n.id}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{Returned columns do not change from using ORDER BY}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN DISTINCT n
  ORDER BY n.id
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \duplicateelimination \Big(\projection{\var{n}} \Big(\alldifferent{} \Big(\getvertices{n}{}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\duplicateelimination$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\duplicateelimination$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{Arithmetic expressions should propagate null values}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN 1 + (2 - (3 * (4 / (5 ^ (6 % null))))) AS a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Indexing into nested literal lists}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN [[1]][0][0]
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Aliasing expressions}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
RETURN a.id AS a, a.id
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{a.id},~\var{a.id}} \Big(\alldifferent{} \Big(\getvertices{a}{}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a.id},~\var{a.id}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a.id},~\var{a.id}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{Projecting an arithmetic expression with aggregation}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
RETURN a, count(a) + 3
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Aggregating by a list property has a correct definition of equality}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WITH a.a AS a, count(*) AS count
RETURN count
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Reusing variable names}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (person:Person)<--(message)<-[like]-(:Person)
WITH like.creationDate AS likeTime, person AS person
  ORDER BY likeTime, message.id
WITH head(collect({likeTime: likeTime})) AS latestLike, person AS person
RETURN latestLike.likeTime AS likeTime
  ORDER BY likeTime
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Concatenating lists of same type}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN [1, 10, 100] + [4, 5] AS foo
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Appending lists of same type}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN [false, true] + false AS foo
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{DISTINCT inside aggregation should work with lists in maps}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN count(DISTINCT {foo: n.list}) AS count
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handling DISTINCT with lists in maps}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WITH DISTINCT {foo: n.list} AS map
RETURN count(*)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{DISTINCT inside aggregation should work with nested lists in maps}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN count(DISTINCT {foo: [[n.list, n.list], [n.list, n.list]]}) AS count
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{DISTINCT inside aggregation should work with nested lists of maps in maps}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN count(DISTINCT {foo: [{bar: n.list}, {baz: {apa: n.list}}]}) AS count
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\section{SemanticErrorAcceptance}

\subsection{Handling property access on the Any type}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH [{prop: 0}, 1] AS list
RETURN (list[0]).prop
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Bad arguments for `range()`}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN range(2, 8, 0)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\section{SetAcceptance}

\section{SkipLimitAcceptanceTest}

\subsection{SKIP with an expression that does not depend on variables}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WITH n SKIP toInteger(rand()*9)
WITH count(*) AS count
RETURN count > 0 AS nonEmpty
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{LIMIT with an expression that does not depend on variables}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WITH n LIMIT toInteger(ceil(1.7))
RETURN count(*) AS count
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\section{StartingPointAcceptance}

\subsection{Find all nodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{n}} \Big(\alldifferent{} \Big(\getvertices{n}{}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{Find labelled nodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n:Animal)
RETURN n
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{n}} \Big(\alldifferent{} \Big(\getvertices{n}{Animal}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{Animal}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{Animal}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{Find nodes by property}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WHERE n.prop = 2
RETURN n
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{n}} \Big(\selection{\var{n.prop} = \literal{2}} \Big(\alldifferent{} \Big(\getvertices{n}{}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\selection{\var{n.prop} = \literal{2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\selection{\var{n.prop} = \literal{2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\section{StartsWithAcceptance}

\subsection{Finding exact matches}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a.name STARTS WITH 'ABCDEF'
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Finding beginning of string}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a.name STARTS WITH 'ABC'
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Finding end of string 1}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a.name ENDS WITH 'DEF'
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Finding end of string 2}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a.name ENDS WITH 'AB'
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Finding middle of string}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a.name STARTS WITH 'a'
  AND a.name ENDS WITH 'f'
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Finding the empty string}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a.name STARTS WITH ''
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Finding when the middle is known}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a.name CONTAINS 'CD'
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Finding strings starting with whitespace}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a.name STARTS WITH ' '
RETURN a.name AS name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Finding strings starting with newline}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a.name STARTS WITH '\n'
RETURN a.name AS name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Finding strings ending with newline}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a.name ENDS WITH '\n'
RETURN a.name AS name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Finding strings ending with whitespace}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a.name ENDS WITH ' '
RETURN a.name AS name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Finding strings containing whitespace}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a.name CONTAINS ' '
RETURN a.name AS name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Finding strings containing newline}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a.name CONTAINS '\n'
RETURN a.name AS name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{No string starts with null}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a.name STARTS WITH null
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{No string does not start with null}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE NOT a.name STARTS WITH null
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{No string ends with null}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a.name ENDS WITH null
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{No string does not end with null}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE NOT a.name ENDS WITH null
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{No string contains null}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a.name CONTAINS null
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{No string does not contain null}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE NOT a.name CONTAINS null
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Combining string operators}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a.name STARTS WITH 'A'
  AND a.name CONTAINS 'C'
  AND a.name ENDS WITH 'EF'
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{NOT with CONTAINS}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE NOT a.name CONTAINS 'b'
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\section{SyntaxErrorAcceptance}

\section{TernaryLogicAcceptanceTest}

\subsection{The inverse of a null is a null}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN NOT null AS value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{A literal null IS null}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN null IS NULL AS value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{A literal null is not IS NOT null}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN null IS NOT NULL AS value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{It is unknown - i.e. null - if a null is equal to a null}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN null = null AS value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{It is unknown - i.e. null - if a null is not equal to a null}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN null <> null AS value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\section{TriadicSelection}

\subsection{Handling triadic friend of a friend}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-[:KNOWS]->(b)-->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handling triadic friend of a friend that is not a friend}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-[:KNOWS]->(b)-->(c)
OPTIONAL MATCH (a)-[r:KNOWS]->(c)
WITH c WHERE r IS NULL
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handling triadic friend of a friend that is not a friend with different relationship type}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-[:KNOWS]->(b)-->(c)
OPTIONAL MATCH (a)-[r:FOLLOWS]->(c)
WITH c WHERE r IS NULL
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handling triadic friend of a friend that is not a friend with superset of relationship type}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-[:KNOWS]->(b)-->(c)
OPTIONAL MATCH (a)-[r]->(c)
WITH c WHERE r IS NULL
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handling triadic friend of a friend that is not a friend with implicit subset of relationship type}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-->(b)-->(c)
OPTIONAL MATCH (a)-[r:KNOWS]->(c)
WITH c WHERE r IS NULL
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handling triadic friend of a friend that is not a friend with explicit subset of relationship type}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-[:KNOWS|FOLLOWS]->(b)-->(c)
OPTIONAL MATCH (a)-[r:KNOWS]->(c)
WITH c WHERE r IS NULL
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handling triadic friend of a friend that is not a friend with same labels}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-[:KNOWS]->(b:X)-->(c:X)
OPTIONAL MATCH (a)-[r:KNOWS]->(c)
WITH c WHERE r IS NULL
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handling triadic friend of a friend that is not a friend with different labels}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-[:KNOWS]->(b:X)-->(c:Y)
OPTIONAL MATCH (a)-[r:KNOWS]->(c)
WITH c WHERE r IS NULL
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handling triadic friend of a friend that is not a friend with implicit subset of labels}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-[:KNOWS]->(b)-->(c:X)
OPTIONAL MATCH (a)-[r:KNOWS]->(c)
WITH c WHERE r IS NULL
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handling triadic friend of a friend that is not a friend with implicit superset of labels}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-[:KNOWS]->(b:X)-->(c)
OPTIONAL MATCH (a)-[r:KNOWS]->(c)
WITH c WHERE r IS NULL
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handling triadic friend of a friend that is a friend}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-[:KNOWS]->(b)-->(c)
OPTIONAL MATCH (a)-[r:KNOWS]->(c)
WITH c WHERE r IS NOT NULL
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handling triadic friend of a friend that is a friend with different relationship type}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-[:KNOWS]->(b)-->(c)
OPTIONAL MATCH (a)-[r:FOLLOWS]->(c)
WITH c WHERE r IS NOT NULL
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handling triadic friend of a friend that is a friend with superset of relationship type}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-[:KNOWS]->(b)-->(c)
OPTIONAL MATCH (a)-[r]->(c)
WITH c WHERE r IS NOT NULL
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handling triadic friend of a friend that is a friend with implicit subset of relationship type}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-->(b)-->(c)
OPTIONAL MATCH (a)-[r:KNOWS]->(c)
WITH c WHERE r IS NOT NULL
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handling triadic friend of a friend that is a friend with explicit subset of relationship type}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-[:KNOWS|FOLLOWS]->(b)-->(c)
OPTIONAL MATCH (a)-[r:KNOWS]->(c)
WITH c WHERE r IS NOT NULL
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handling triadic friend of a friend that is a friend with same labels}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-[:KNOWS]->(b:X)-->(c:X)
OPTIONAL MATCH (a)-[r:KNOWS]->(c)
WITH c WHERE r IS NOT NULL
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handling triadic friend of a friend that is a friend with different labels}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-[:KNOWS]->(b:X)-->(c:Y)
OPTIONAL MATCH (a)-[r:KNOWS]->(c)
WITH c WHERE r IS NOT NULL
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handling triadic friend of a friend that is a friend with implicit subset of labels}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-[:KNOWS]->(b)-->(c:X)
OPTIONAL MATCH (a)-[r:KNOWS]->(c)
WITH c WHERE r IS NOT NULL
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handling triadic friend of a friend that is a friend with implicit superset of labels}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-[:KNOWS]->(b:X)-->(c)
OPTIONAL MATCH (a)-[r:KNOWS]->(c)
WITH c WHERE r IS NOT NULL
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\section{TypeConversionFunctions}

\subsection{`toBoolean()` on valid literal string}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN toBoolean('true') AS b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`toBoolean()` on booleans}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND [true, false] AS b
RETURN toBoolean(b) AS b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`toBoolean()` on variables with valid string values}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND ['true', 'false'] AS s
RETURN toBoolean(s) AS b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`toBoolean()` on invalid strings}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND [null, '', ' tru ', 'f alse'] AS things
RETURN toBoolean(things) AS b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`toInteger()`}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (p:Person { age: '42' })
WITH *
MATCH (n)
RETURN toInteger(n.age) AS age
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`toInteger()` on float}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH 82.9 AS weight
RETURN toInteger(weight)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`toInteger()` returning null on non-numerical string}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH 'foo' AS foo_string, '' AS empty_string
RETURN toInteger(foo_string) AS foo, toInteger(empty_string) AS empty
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`toInteger()` handling mixed number types}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH [2, 2.9] AS numbers
RETURN [n IN numbers | toInteger(n)] AS int_numbers
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`toInteger()` handling Any type}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH [2, 2.9, '1.7'] AS things
RETURN [n IN things | toInteger(n)] AS int_numbers
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`toInteger()` on a list of strings}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH ['2', '2.9', 'foo'] AS numbers
RETURN [n IN numbers | toInteger(n)] AS int_numbers
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`toFloat()`}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (m:Movie { rating: 4 })
WITH *
MATCH (n)
RETURN toFloat(n.rating) AS float
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`toFloat()` on mixed number types}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH [3.4, 3] AS numbers
RETURN [n IN numbers | toFloat(n)] AS float_numbers
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`toFloat()` returning null on non-numerical string}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH 'foo' AS foo_string, '' AS empty_string
RETURN toFloat(foo_string) AS foo, toFloat(empty_string) AS empty
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`toFloat()` handling Any type}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH [3.4, 3, '5'] AS numbers
RETURN [n IN numbers | toFloat(n)] AS float_numbers
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`toFloat()` on a list of strings}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH ['1', '2', 'foo'] AS numbers
RETURN [n IN numbers | toFloat(n)] AS float_numbers
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`toString()`}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (m:Movie { rating: 4 })
WITH *
MATCH (n)
RETURN toString(n.rating)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`toString()` handling boolean properties}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (m:Movie)
RETURN toString(m.watched)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`toString()` handling inlined boolean}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN toString(1 < 0) AS bool
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`toString()` handling boolean literal}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN toString(true) AS bool
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`toString()` should work on Any type}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN [x IN [1, 2.3, true, 'apa'] | toString(x) ] AS list
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{`toString()` on a list of integers}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH [1, 2, 3] AS numbers
RETURN [n IN numbers | toString(n)] AS string_numbers
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\section{UnionAcceptance}

\subsection{Should be able to create text output from union queries}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
RETURN a AS a
UNION
MATCH (b:B)
RETURN b AS a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{a}} \Big(\alldifferent{} \Big(\getvertices{a}{A}\Big)\Big) \union \projection{\var{b}} \Big(\alldifferent{} \Big(\getvertices{b}{B}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\union$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\projection{\var{a}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\projection{\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{b}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\union$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\projection{\var{a}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\projection{\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{b}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{Two elements, both unique, not distinct}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN 1 AS x
UNION ALL
RETURN 2 AS x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Two elements, both unique, distinct}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN 1 AS x
UNION
RETURN 2 AS x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Three elements, two unique, distinct}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN 2 AS x
UNION
RETURN 1 AS x
UNION
RETURN 2 AS x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Three elements, two unique, not distinct}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN 2 AS x
UNION ALL
RETURN 1 AS x
UNION ALL
RETURN 2 AS x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\section{UnwindAcceptance}

\subsection{Unwinding a list}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND [1, 2, 3] AS x
RETURN x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Unwinding a range}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND range(1, 3) AS x
RETURN x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Unwinding a concatenation of lists}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH [1, 2, 3] AS first, [4, 5, 6] AS second
UNWIND (first + second) AS x
RETURN x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Unwinding a collected unwound expression}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND RANGE(1, 2) AS row
WITH collect(row) AS rows
UNWIND rows AS x
RETURN x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Unwinding a collected expression}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (row)
WITH collect(row) AS rows
UNWIND rows AS node
RETURN node.id
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Double unwinding a list of lists}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH [[1, 2, 3], [4, 5, 6]] AS lol
UNWIND lol AS x
UNWIND x AS y
RETURN y
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Unwinding the empty list}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND [] AS empty
RETURN empty
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Unwinding null}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND null AS nil
RETURN nil
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Unwinding list with duplicates}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND [1, 1, 2, 2, 3, 3, 4, 4, 5, 5] AS duplicate
RETURN duplicate
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Unwind does not prune context}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH [1, 2, 3] AS list
UNWIND list AS x
RETURN *
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
]
;
\end{forest}
\subsection{Unwind does not remove variables from scope}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:S)-[:X]->(b1)
WITH a, collect(b1) AS bees
UNWIND bees AS b2
MATCH (a)-[:Y]->(b2)
RETURN a, b2
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{a},~\var{b2}} \Big(\alldifferent{} \Big(\expandout{a}{b1}{}{\_e373}{X}{}{} \Big(\getvertices{a}{S}\Big)\Big) \join \alldifferent{} \Big(\expandout{a}{b2}{}{\_e374}{Y}{}{} \Big(\getvertices{a}{S}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{b1}{}{\_e375}{X}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{S}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{b2}{}{\_e376}{Y}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{S}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{b1}{}{\_e377}{X}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{S}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{b2}{}{\_e378}{Y}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{S}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Multiple unwinds after each other}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH [1, 2] AS xs, [3, 4] AS ys, [5, 6] AS zs
UNWIND xs AS x
UNWIND ys AS y
UNWIND zs AS z
RETURN *
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
]
;
\end{forest}
\section{VarLengthAcceptance}

\subsection{Handling unbounded variable length match}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}\Big) \join \alldifferent{} \Big(\expandout{a}{c}{}{\_e379}{LIKES}{}{} \Big(\getvertices{a}{A}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e380}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e381}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Handling explicitly unbounded variable length match}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*..]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}\Big) \join \alldifferent{} \Big(\expandout{a}{c}{}{\_e382}{LIKES}{}{} \Big(\getvertices{a}{A}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e383}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e384}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Handling single bounded variable length match 1}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*0]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}\Big) \join \alldifferent{} \Big(\expandout{a}{c}{}{\_e385}{LIKES}{}{} \Big(\getvertices{a}{A}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e386}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e387}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Handling single bounded variable length match 2}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*1]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}\Big) \join \alldifferent{} \Big(\expandout{a}{c}{}{\_e388}{LIKES}{}{} \Big(\getvertices{a}{A}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e389}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e390}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Handling single bounded variable length match 3}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*2]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}\Big) \join \alldifferent{} \Big(\expandout{a}{c}{}{\_e391}{LIKES}{}{} \Big(\getvertices{a}{A}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e392}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e393}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Handling upper and lower bounded variable length match 1}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*0..2]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}\Big) \join \alldifferent{} \Big(\expandout{a}{c}{}{\_e394}{LIKES}{}{} \Big(\getvertices{a}{A}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e395}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e396}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Handling upper and lower bounded variable length match 2}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*1..2]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}\Big) \join \alldifferent{} \Big(\expandout{a}{c}{}{\_e397}{LIKES}{}{} \Big(\getvertices{a}{A}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e398}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e399}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Handling symmetrically bounded variable length match, bounds are zero}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*0..0]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}\Big) \join \alldifferent{} \Big(\expandout{a}{c}{}{\_e400}{LIKES}{}{} \Big(\getvertices{a}{A}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e401}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e402}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Handling symmetrically bounded variable length match, bounds are one}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*1..1]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}\Big) \join \alldifferent{} \Big(\expandout{a}{c}{}{\_e403}{LIKES}{}{} \Big(\getvertices{a}{A}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e404}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e405}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Handling symmetrically bounded variable length match, bounds are two}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*2..2]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}\Big) \join \alldifferent{} \Big(\expandout{a}{c}{}{\_e406}{LIKES}{}{} \Big(\getvertices{a}{A}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e407}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e408}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Handling upper and lower bounded variable length match, empty interval 1}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*2..1]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}\Big) \join \alldifferent{} \Big(\expandout{a}{c}{}{\_e409}{LIKES}{}{} \Big(\getvertices{a}{A}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e410}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e411}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Handling upper and lower bounded variable length match, empty interval 2}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*1..0]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}\Big) \join \alldifferent{} \Big(\expandout{a}{c}{}{\_e412}{LIKES}{}{} \Big(\getvertices{a}{A}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e413}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e414}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Handling upper bounded variable length match, empty interval}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*..0]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}\Big) \join \alldifferent{} \Big(\expandout{a}{c}{}{\_e415}{LIKES}{}{} \Big(\getvertices{a}{A}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e416}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e417}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Handling upper bounded variable length match 1}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*..1]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}\Big) \join \alldifferent{} \Big(\expandout{a}{c}{}{\_e418}{LIKES}{}{} \Big(\getvertices{a}{A}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e419}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e420}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Handling upper bounded variable length match 2}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*..2]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}\Big) \join \alldifferent{} \Big(\expandout{a}{c}{}{\_e421}{LIKES}{}{} \Big(\getvertices{a}{A}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e422}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e423}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Handling lower bounded variable length match 1}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*0..]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}\Big) \join \alldifferent{} \Big(\expandout{a}{c}{}{\_e424}{LIKES}{}{} \Big(\getvertices{a}{A}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e425}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e426}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Handling lower bounded variable length match 2}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*1..]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}\Big) \join \alldifferent{} \Big(\expandout{a}{c}{}{\_e427}{LIKES}{}{} \Big(\getvertices{a}{A}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e428}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e429}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Handling lower bounded variable length match 3}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*2..]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}\Big) \join \alldifferent{} \Big(\expandout{a}{c}{}{\_e430}{LIKES}{}{} \Big(\getvertices{a}{A}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e431}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e432}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Handling a variable length relationship and a standard relationship in chain, zero length 1}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*0]->()-[:LIKES]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}\Big) \join \alldifferent{} \Big(\expandout{\_e433}{c}{}{\_e435}{LIKES}{}{} \Big(\expandout{a}{\_e433}{}{\_e434}{LIKES}{}{} \Big(\getvertices{a}{A}\Big)\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e436}{c}{}{\_e438}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{\_e436}{}{\_e437}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e439}{c}{}{\_e441}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{\_e439}{}{\_e440}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
\subsection{Handling a variable length relationship and a standard relationship in chain, zero length 2}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES]->()-[:LIKES*0]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}\Big) \join \alldifferent{} \Big(\expandout{\_e442}{c}{}{\_e444}{LIKES}{}{} \Big(\expandout{a}{\_e442}{}{\_e443}{LIKES}{}{} \Big(\getvertices{a}{A}\Big)\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e445}{c}{}{\_e447}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{\_e445}{}{\_e446}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e448}{c}{}{\_e450}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{\_e448}{}{\_e449}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
\subsection{Handling a variable length relationship and a standard relationship in chain, single length 1}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*1]->()-[:LIKES]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}\Big) \join \alldifferent{} \Big(\expandout{\_e451}{c}{}{\_e453}{LIKES}{}{} \Big(\expandout{a}{\_e451}{}{\_e452}{LIKES}{}{} \Big(\getvertices{a}{A}\Big)\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e454}{c}{}{\_e456}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{\_e454}{}{\_e455}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e457}{c}{}{\_e459}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{\_e457}{}{\_e458}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
\subsection{Handling a variable length relationship and a standard relationship in chain, single length 2}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES]->()-[:LIKES*1]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}\Big) \join \alldifferent{} \Big(\expandout{\_e460}{c}{}{\_e462}{LIKES}{}{} \Big(\expandout{a}{\_e460}{}{\_e461}{LIKES}{}{} \Big(\getvertices{a}{A}\Big)\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e463}{c}{}{\_e465}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{\_e463}{}{\_e464}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e466}{c}{}{\_e468}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{\_e466}{}{\_e467}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
\subsection{Handling a variable length relationship and a standard relationship in chain, longer 1}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*2]->()-[:LIKES]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}\Big) \join \alldifferent{} \Big(\expandout{\_e469}{c}{}{\_e471}{LIKES}{}{} \Big(\expandout{a}{\_e469}{}{\_e470}{LIKES}{}{} \Big(\getvertices{a}{A}\Big)\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e472}{c}{}{\_e474}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{\_e472}{}{\_e473}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e475}{c}{}{\_e477}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{\_e475}{}{\_e476}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
\subsection{Handling a variable length relationship and a standard relationship in chain, longer 2}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES]->()-[:LIKES*2]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}\Big) \join \alldifferent{} \Big(\expandout{\_e478}{c}{}{\_e480}{LIKES}{}{} \Big(\expandout{a}{\_e478}{}{\_e479}{LIKES}{}{} \Big(\getvertices{a}{A}\Big)\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e481}{c}{}{\_e483}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{\_e481}{}{\_e482}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e484}{c}{}{\_e486}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{\_e484}{}{\_e485}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
\subsection{Handling a variable length relationship and a standard relationship in chain, longer 3}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES]->()-[:LIKES*3]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}\Big) \join \alldifferent{} \Big(\expandout{\_e487}{c}{}{\_e489}{LIKES}{}{} \Big(\expandout{a}{\_e487}{}{\_e488}{LIKES}{}{} \Big(\getvertices{a}{A}\Big)\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e490}{c}{}{\_e492}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{\_e490}{}{\_e491}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e493}{c}{}{\_e495}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{\_e493}{}{\_e494}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
\subsection{Handling mixed relationship patterns and directions 1}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)<-[:LIKES]-()-[:LIKES*3]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}\Big) \join \alldifferent{} \Big(\expandout{\_e496}{c}{}{\_e498}{LIKES}{}{} \Big(\expandin{a}{\_e496}{}{\_e497}{LIKES}{}{} \Big(\getvertices{a}{A}\Big)\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e499}{c}{}{\_e501}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandin{a}{\_e499}{}{\_e500}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e502}{c}{}{\_e504}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandin{a}{\_e502}{}{\_e503}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
\subsection{Handling mixed relationship patterns and directions 2}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES]->()<-[:LIKES*3]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}\Big) \join \alldifferent{} \Big(\expandboth{\_e505}{c}{}{\_e507}{LIKES}{}{} \Big(\expandout{a}{\_e505}{}{\_e506}{LIKES}{}{} \Big(\getvertices{a}{A}\Big)\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandboth{\_e508}{c}{}{\_e510}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{\_e508}{}{\_e509}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandboth{\_e511}{c}{}{\_e513}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{\_e511}{}{\_e512}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
\subsection{Handling mixed relationship patterns 1}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (p)-[:LIKES*1]->()-[:LIKES]->()-[r:LIKES*2]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}\Big) \join \alldifferent{} \Big(\expandout{\_e516}{c}{}{r}{LIKES}{}{} \Big(\expandout{\_e514}{\_e516}{}{\_e517}{LIKES}{}{} \Big(\expandout{p}{\_e514}{}{\_e515}{LIKES}{}{} \Big(\getvertices{p}{}\Big)\Big)\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e520}{c}{}{r}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e518}{\_e520}{}{\_e521}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{p}{\_e518}{}{\_e519}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{p}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e524}{c}{}{r}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e522}{\_e524}{}{\_e525}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{p}{\_e522}{}{\_e523}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{p}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
]
;
\end{forest}
\subsection{Handling mixed relationship patterns 2}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (p)-[:LIKES]->()-[:LIKES*2]->()-[r:LIKES]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}\Big) \join \alldifferent{} \Big(\expandout{\_e528}{c}{}{r}{LIKES}{}{} \Big(\expandout{\_e526}{\_e528}{}{\_e529}{LIKES}{}{} \Big(\expandout{p}{\_e526}{}{\_e527}{LIKES}{}{} \Big(\getvertices{p}{}\Big)\Big)\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e532}{c}{}{r}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e530}{\_e532}{}{\_e533}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{p}{\_e530}{}{\_e531}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{p}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e536}{c}{}{r}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{\_e534}{\_e536}{}{\_e537}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{p}{\_e534}{}{\_e535}{LIKES}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{p}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
]
;
\end{forest}
\section{VarLengthAcceptance2}

\subsection{Handling relationships that are already bound in variable length paths}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[r:EDGE]-()
MATCH p = (n)-[*0..1]-()-[r]-()-[*0..1]-(m)
RETURN count(p) AS c
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\section{WhereAcceptance}

\subsection{NOT and false}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WHERE NOT(n.name = 'apa' AND false)
RETURN n
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\section{WithAcceptance}

\subsection{Passing on pattern nodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
WITH a
MATCH (a)-->(b)
RETURN *
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{ORDER BY and LIMIT can be used}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
WITH a
ORDER BY a.name
LIMIT 1
MATCH (a)-->(b)
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{No dependencies between the query parts}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WITH a
MATCH (b)
RETURN a, b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{a},~\var{b}} \Big(\alldifferent{} \Big(\getvertices{a}{}\Big) \join \alldifferent{} \Big(\getvertices{b}{}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{b}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{b}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
\subsection{Aliasing}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:Begin)
WITH a.prop AS property
MATCH (b:End)
WHERE property = b.prop
RETURN b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handle dependencies across WITH}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:Begin)
WITH a.prop AS property
  LIMIT 1
MATCH (b)
WHERE b.id = property
RETURN b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Handle dependencies across WITH with SKIP}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WITH a.prop AS property, a.key AS idToUse
  ORDER BY property
  SKIP 1
MATCH (b)
WHERE b.id = idToUse
RETURN DISTINCT b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{WHERE after WITH should filter results}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WITH a
WHERE a.name = 'B'
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{a}} \Big(\alldifferent{} \Big(\getvertices{a}{}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{WHERE after WITH can filter on top of an aggregation}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-->()
WITH a, count(*) AS relCount
WHERE relCount > 1
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{ORDER BY on an aggregating key}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WITH a.bar AS bars, count(*) AS relCount
ORDER BY a.bar
RETURN *
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{} \Big(\alldifferent{} \Big(\getvertices{a}{}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{ORDER BY a DISTINCT column}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WITH DISTINCT a.bar AS bars
ORDER BY a.bar
RETURN *
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{} \Big(\alldifferent{} \Big(\getvertices{a}{}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{WHERE on a DISTINCT column}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WITH DISTINCT a.bar AS bars
WHERE a.bar = 'B'
RETURN *
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{} \Big(\alldifferent{} \Big(\getvertices{a}{}\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
\subsection{A simple pattern with one bound endpoint}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-[r:REL]->(b:B)
WITH a AS b, b AS tmp, r AS r
WITH b AS a, r
LIMIT 1
MATCH (a)-[r]->(b)
RETURN a, r, b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \projection{\var{a},~\var{r},~\var{b}} \Big(\alldifferent{} \Big(\expandout{a}{b}{B}{r}{REL}{}{} \Big(\getvertices{a}{A}\Big)\Big) \join \alldifferent{} \Big(\expandout{a}{b}{B}{r}{REL}{}{} \Big(\getvertices{a}{A}\Big)\Big)\Big)
 &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{r},~\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{b}{B}{r}{REL}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{b}{B}{r}{REL}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}

\subsubsection*{Relational algebra tree for incremental queries}

\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{r},~\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{b}{B}{r}{REL}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\expandout{a}{b}{B}{r}{REL}{}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
\subsection{Null handling}

\subsubsection*{Query specification}

\begin{lstlisting}
OPTIONAL MATCH (a:Start)
WITH a
MATCH (a)-->(b)
RETURN *
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Nested maps}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH {foo: {bar: 'baz'}} AS nestedMap
RETURN nestedMap.foo.bar
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Connected components succeeding WITH}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n:A)
WITH n
LIMIT 1
MATCH (m:B), (n)-->(x:X)
RETURN *
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Single WITH using a predicate and aggregation}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WITH n
WHERE n.prop = 42
RETURN count(*)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
\subsection{Multiple WITHs using a predicate and aggregation}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (david {name: 'David'})--(otherPerson)-->()
WITH otherPerson, count(*) AS foaf
WHERE foaf > 1
WITH otherPerson
WHERE otherPerson.name <> 'NotOther'
RETURN count(*)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{flalign*}
& \text{Cannot convert to expression.} &
\end{flalign*}

\subsubsection*{Relational algebra tree}

\text{Cannot visualize tree.}

\subsubsection*{Relational algebra tree for incremental queries}

Cannot visualize incremental tree.
