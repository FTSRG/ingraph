\chapter{TCK Acceptance Tests}
\label{chp:tck}

\section{AggregationAcceptance}


\subsection{Support multiple divisions in aggregate function}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN count(n) / 60 / 60 AS count
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Support column renaming for aggregates as well}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()
RETURN count(*) AS columnName
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Aggregates inside normal functions}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
RETURN size(collect(a))
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handle aggregates inside non-aggregate expressions}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a {name: 'Andres'})<-[:FATHER]-(child)
RETURN {foo: a.name='Andres', kids: collect(child.name)}
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Count nodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:L)-[rel]->(b)
RETURN a, count(*)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Sort on aggregate function and normal property}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n.division, count(*)
ORDER BY count(*) DESC, n.division ASC
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Aggregate on property}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n.x, count(*)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Count non-null values}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n.y, count(n.x)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Sum non-null values}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n.y, sum(n.x)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handle aggregation on functions}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p=(a:L)-[*]->(b)
RETURN b, avg(length(p))
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Distinct on unbound node}

\subsubsection*{Query specification}

\begin{lstlisting}
OPTIONAL MATCH (a)
RETURN count(DISTINCT a)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Distinct on null}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
RETURN count(DISTINCT a.foo)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Collect distinct nulls}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND [null, null] AS x
RETURN collect(DISTINCT x) AS c
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Collect distinct values mixed with nulls}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND [null, 1, null] AS x
RETURN collect(DISTINCT x) AS c
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Aggregate on list values}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
RETURN DISTINCT a.color, count(*)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Aggregates with arithmetics}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()
RETURN count(*) * 10 AS c
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Aggregates ordered by arithmetics}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A), (b:X)
RETURN count(a) * 10 + count(b) * 5 AS x
ORDER BY x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Multiple aggregates on same variable}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN count(n), collect(n)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Simple counting of nodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()
RETURN count(*)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Aggregation of named paths}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (a)-[*]->(b)
RETURN collect(nodes(p)) AS paths, length(p) AS l
ORDER BY l
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Aggregation with `min()`}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (a:T {name: 'a'})-[:R*]->(other:T)
WHERE other <> a
WITH a, other, min(length(p)) AS len
RETURN a.name AS name, collect(other.name) AS others, len
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handle subexpression in aggregation also occurring as standalone expression with nested aggregation in a literal map}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A), (b:B)
RETURN coalesce(a.prop, b.prop) AS foo,
  b.prop AS bar,
  {y: count(b)} AS baz
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{No overflow during summation}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND range(1000000, 2000000) AS i
WITH i
LIMIT 3000
RETURN sum(i)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Counting with loops}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[r]-()
RETURN count(r)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`max()` should aggregate strings}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND ['a', 'b', 'B', null, 'abc', 'abc1'] AS i
RETURN max(i)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`min()` should aggregate strings}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND ['a', 'b', 'B', null, 'abc', 'abc1'] AS i
RETURN min(i)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
\section{ColumnNameAcceptance}


\subsection{Keeping used expression 1}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN cOuNt( * )
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Keeping used expression 2}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (n)-->(b)
RETURN nOdEs( p )
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Keeping used expression 3}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (n)-->(b)
RETURN coUnt( dIstInct p )
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Keeping used expression 4}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (n)-->(b)
RETURN aVg(    n.aGe     )
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
\section{Comparability}


\subsection{Comparing nodes to properties}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a = a.val
RETURN count(a)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
\section{ComparisonOperatorAcceptance}


\subsection{Handling numerical ranges 1}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WHERE 1 < n.value < 3
RETURN n.value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling numerical ranges 2}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WHERE 1 < n.value <= 3
RETURN n.value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling numerical ranges 3}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WHERE 1 <= n.value < 3
RETURN n.value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling numerical ranges 4}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WHERE 1 <= n.value <= 3
RETURN n.value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling string ranges 1}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WHERE 'a' < n.value < 'c'
RETURN n.value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling string ranges 2}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WHERE 'a' < n.value <= 'c'
RETURN n.value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling string ranges 3}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WHERE 'a' <= n.value < 'c'
RETURN n.value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling string ranges 4}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WHERE 'a' <= n.value <= 'c'
RETURN n.value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling empty range}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WHERE 10 < n.value <= 3
RETURN n.value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling long chains of operators}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)-->(m)
WHERE n.prop1 < m.prop1 = n.prop2 <> m.prop2
RETURN labels(m)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
\section{Create}

\section{CreateAcceptance}

\section{DeleteAcceptance}

\section{EqualsAcceptance}


\subsection{Number-typed integer comparison}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH collect([0, 0.0]) AS numbers
UNWIND numbers AS arr
WITH arr[0] AS expected
MATCH (n) WHERE toInteger(n.id) = expected
RETURN n
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Number-typed float comparison}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH collect([0.5, 0]) AS numbers
UNWIND numbers AS arr
WITH arr[0] AS expected
MATCH (n) WHERE toInteger(n.id) = expected
RETURN n
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Any-typed string comparison}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH collect(['0', 0]) AS things
UNWIND things AS arr
WITH arr[0] AS expected
MATCH (n) WHERE toInteger(n.id) = expected
RETURN n
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Comparing nodes to nodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WITH a
MATCH (b)
WHERE a = b
RETURN count(b)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Comparing relationships to relationships}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[a]->()
WITH a
MATCH ()-[b]->()
WHERE a = b
RETURN count(b)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
\section{ExpressionAcceptance}


\subsection{IN should work with nested list subscripting}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH [[1, 2, 3]] AS list
RETURN 3 IN list[0] AS r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{IN should work with nested literal list subscripting}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN 3 IN [[1, 2, 3]][0] AS r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{IN should work with list slices}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH [1, 2, 3] AS list
RETURN 3 IN list[0..1] AS r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{IN should work with literal list slices}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN 3 IN [1, 2, 3][0..1] AS r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Execute n[0]}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN [1, 2, 3][0] AS value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Execute n['name'] in read queries}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n {name: 'Apa'})
RETURN n['nam' + 'e'] AS value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Use dynamic property lookup based on parameters when there is no type information}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH $expr AS expr, $idx AS idx
RETURN expr[idx] AS value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Use dynamic property lookup based on parameters when there is rhs type information}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH $expr AS expr, $idx AS idx
RETURN expr[toString(idx)] AS value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Use collection lookup based on parameters when there is no type information}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH $expr AS expr, $idx AS idx
RETURN expr[idx] AS value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Use collection lookup based on parameters when there is lhs type information}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH ['Apa'] AS expr
RETURN expr[$idx] AS value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Use collection lookup based on parameters when there is rhs type information}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH $expr AS expr, $idx AS idx
RETURN expr[toInteger(idx)] AS value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
\section{FunctionsAcceptance}


\subsection{Run coalesce}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
RETURN coalesce(a.title, a.name)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Functions should return null if they get path containing unbound}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH null AS a
OPTIONAL MATCH p = (a)-[r]->()
RETURN length(nodes(p)), type(r), nodes(p), relationships(p)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`split()`}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND split('one1two', '1') AS item
RETURN count(item) AS item
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`properties()` on a node}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (p:Person)
RETURN properties(p) AS m
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`properties()` on a relationship}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[r:R]->()
RETURN properties(r) AS m
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`properties()` on a map}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN properties({name: 'Popeye', level: 9001}) AS m
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`properties()` on null}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN properties(null)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`reverse()`}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN reverse('raksO')
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`exists()` with dynamic property lookup}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n:Person)
WHERE exists(n['prop'])
RETURN n
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`percentileDisc()` failing in more involved query}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n:S)
WITH n, size([(n)-->() | 1]) AS deg
WHERE deg > 2
WITH deg
LIMIT 100
RETURN percentileDisc(0.90, deg), deg
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`type()`}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[r]->()
RETURN type(r)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`type()` on two relationships}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[r1]->()-[r2]->()
RETURN type(r1), type(r2)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`type()` on null relationship}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
OPTIONAL MATCH (a)-[r:NOT_THERE]->()
RETURN type(r)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`type()` on mixed null and non-null relationships}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
OPTIONAL MATCH (a)-[r:T]->()
RETURN type(r)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`type()` handling Any type}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-[r]->()
WITH [r, 1] AS list
RETURN type(list[0])
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`labels()` should accept type Any}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WITH [a, 1] AS list
RETURN labels(list[0]) AS l
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`labels()` should accept type Any}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WITH [a, 1] AS list
RETURN labels(list[1]) AS l
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`exists()` is case insensitive}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n:X)
RETURN n, EXIsTS(n.prop) AS b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
\section{ValueHashJoinAcceptance}


\subsection{Find friends of others}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A), (b:B)
WHERE a.id = b.id
RETURN a, b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{a},~\var{b}} \Big(\selection{\var{a.id} = \var{b.id}} \Big(\alldifferent{} \Big(\getvertices{a}{A}
 \join \getvertices{b}{B}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\selection{\var{a.id} = \var{b.id}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\getvertices{b}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\selection{\var{a.id} = \var{b.id}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\getvertices{b}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Should only join when matching}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A), (b:B)
WHERE a.id = b.id
RETURN a, b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{a},~\var{b}} \Big(\selection{\var{a.id} = \var{b.id}} \Big(\alldifferent{} \Big(\getvertices{a}{A}
 \join \getvertices{b}{B}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\selection{\var{a.id} = \var{b.id}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\getvertices{b}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\selection{\var{a.id} = \var{b.id}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\getvertices{b}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}
\section{KeysAcceptance}


\subsection{Using `keys()` on a single node, non-empty result}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
UNWIND keys(n) AS x
RETURN DISTINCT x AS theProps
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Using `keys()` on multiple nodes, non-empty result}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
UNWIND keys(n) AS x
RETURN DISTINCT x AS theProps
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Using `keys()` on a single node, empty result}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
UNWIND keys(n) AS x
RETURN DISTINCT x AS theProps
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Using `keys()` on an optionally matched node}

\subsubsection*{Query specification}

\begin{lstlisting}
OPTIONAL MATCH (n)
UNWIND keys(n) AS x
RETURN DISTINCT x AS theProps
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Using `keys()` on a relationship, non-empty result}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[r:KNOWS]-()
UNWIND keys(r) AS x
RETURN DISTINCT x AS theProps
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Using `keys()` on a relationship, empty result}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[r:KNOWS]-()
UNWIND keys(r) AS x
RETURN DISTINCT x AS theProps
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Using `keys()` on an optionally matched relationship}

\subsubsection*{Query specification}

\begin{lstlisting}
OPTIONAL MATCH ()-[r:KNOWS]-()
UNWIND keys(r) AS x
RETURN DISTINCT x AS theProps
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Using `keys()` on a literal map}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN keys({name: 'Alice', age: 38, address: {city: 'London', residential: true}}) AS k
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Using `keys()` on a parameter map}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN keys($param) AS k
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
\section{LabelsAcceptance}


\subsection{Using `labels()` in return clauses}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN labels(n)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
\section{LargeCreateQuery}

\section{LargeIntegerEquality}


\subsection{Does not lose precision}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (p:Label)
RETURN p.id
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{p.id}} \Big(\alldifferent{} \Big(\getvertices{p}{Label}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{p.id}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{id} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{p} \rangle$
			}
[
	{$\getvertices{p}{Label}$
			\\
			\footnotesize
			$\color{gray} \langle \var{p} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{p.id}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{id} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{p} \rangle$
			}
[
	{$\getvertices{p}{Label}$
			\\
			\footnotesize
			$\color{gray} \langle \var{p} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsection{Handling inlined equality of large integer}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (p:Label {id: 4611686018427387905})
RETURN p.id
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{p.id}} \Big(\alldifferent{} \Big(\getvertices{p}{Label}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{p.id}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{id} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{p} \rangle$
			}
[
	{$\getvertices{p}{Label}$
			\\
			\footnotesize
			$\color{gray} \langle \var{p} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{p.id}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{id} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{p} \rangle$
			}
[
	{$\getvertices{p}{Label}$
			\\
			\footnotesize
			$\color{gray} \langle \var{p} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsection{Handling explicit equality of large integer}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (p:Label)
WHERE p.id = 4611686018427387905
RETURN p.id
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling inlined equality of large integer, non-equal values}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (p:Label {id : 4611686018427387900})
RETURN p.id
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{p.id}} \Big(\alldifferent{} \Big(\getvertices{p}{Label}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{p.id}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{id} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{p} \rangle$
			}
[
	{$\getvertices{p}{Label}$
			\\
			\footnotesize
			$\color{gray} \langle \var{p} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{p.id}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{id} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{p} \rangle$
			}
[
	{$\getvertices{p}{Label}$
			\\
			\footnotesize
			$\color{gray} \langle \var{p} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsection{Handling explicit equality of large integer, non-equal values}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (p:Label)
WHERE p.id = 4611686018427387900
RETURN p.id
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
\section{ListComprehension}


\subsection{Returning a list comprehension}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (n)-->()
RETURN [x IN collect(p) | head(nodes(x))] AS p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Using a list comprehension in a WITH}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (n:A)-->()
WITH [x IN collect(p) | head(nodes(x))] AS p, count(n) AS c
RETURN p, c
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Using a list comprehension in a WHERE}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)-->(b)
WHERE n.prop IN [x IN labels(b) | lower(x)]
RETURN b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
\section{Literals}


\subsection{Return an integer}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN 1 AS literal
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Return a float}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN 1.0 AS literal
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Return a float in exponent form}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN -1e-9 AS literal
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Return a boolean}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN true AS literal
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Return a single-quoted string}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN '' AS literal
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Return a double-quoted string}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN "" AS literal
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Return null}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN null AS literal
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Return an empty list}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN [] AS literal
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Return a nonempty list}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN [0, 1, 2] AS literal
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Return an empty map}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN {} AS literal
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Return a nonempty map}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN {k1: 0, k2: 'string'} AS literal
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
\section{MatchAcceptance}


\subsection{Path query should return results in written order}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (a:Label1)<--(:Label2)
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Longer path query should return results in written order}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (a:Label1)<--(:Label2)--()
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Use multiple MATCH clauses to do a Cartesian product}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n), (m)
RETURN n.value AS n, m.value AS m
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{n.value}\assign \var{n},~\var{m.value}\assign \var{m}} \Big(\alldifferent{} \Big(\getvertices{n}{}
 \join \getvertices{m}{}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{n.value}\assign \var{n},~\var{m.value}\assign \var{m}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{value, value} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, m} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, m} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\getvertices{m}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{m} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{n.value}\assign \var{n},~\var{m.value}\assign \var{m}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{value, value} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, m} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, m} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\getvertices{m}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{m} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsection{Use params in pattern matching predicates}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-[r]->(b)
WHERE r.foo = $param
RETURN b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Filter out based on node prop name}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[rel:X]-(a)
WHERE a.name = 'Andres'
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{a}} \Big(\selection{\var{a.name} = \literal{''Andres''}} \Big(\alldifferent{} \Big(\expandboth{\_e175}{a}{}{rel}{X}{1}{1} \Big(\getvertices{\_e175}{}
\Big)
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\selection{\var{a.name} = \literal{''Andres''}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e175, rel, a} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e175, rel, a} \rangle$
			}
[
	{$\expandboth{\_e175}{a}{}{rel}{X}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e175, rel, a} \rangle$
			}
[
	{$\getvertices{\_e175}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e175} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\selection{\var{a.name} = \literal{''Andres''}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e175, rel, a} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e175, rel, a} \rangle$
			}
[
	{$\expandboth{\_e175}{a}{}{rel}{X}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e175, rel, a} \rangle$
			}
[
	{$\getvertices{\_e175}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e175} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Honour the column name for RETURN items}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WITH a.name AS a
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{a}} \Big(\alldifferent{} \Big(\getvertices{a}{}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsection{Filter based on rel prop name}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (node)-[r:KNOWS]->(a)
WHERE r.name = 'monkey'
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{a}} \Big(\selection{\var{r.name} = \literal{''monkey''}} \Big(\alldifferent{} \Big(\expandout{node}{a}{}{r}{KNOWS}{1}{1} \Big(\getvertices{node}{}
\Big)
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\selection{\var{r.name} = \literal{''monkey''}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{node, r, a} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{node, r, a} \rangle$
			}
[
	{$\expandout{node}{a}{}{r}{KNOWS}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{node, r, a} \rangle$
			}
[
	{$\getvertices{node}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{node} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\selection{\var{r.name} = \literal{''monkey''}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{node, r, a} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{node, r, a} \rangle$
			}
[
	{$\expandout{node}{a}{}{r}{KNOWS}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{node, r, a} \rangle$
			}
[
	{$\getvertices{node}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{node} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Cope with shadowed variables}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WITH n.name AS n
RETURN n
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{n}} \Big(\alldifferent{} \Big(\getvertices{n}{}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsection{Get neighbours}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n1)-[rel:KNOWS]->(n2)
RETURN n1, n2
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{n1},~\var{n2}} \Big(\alldifferent{} \Big(\expandout{n1}{n2}{}{rel}{KNOWS}{1}{1} \Big(\getvertices{n1}{}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{n1},~\var{n2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n1, n2} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n1, rel, n2} \rangle$
			}
[
	{$\expandout{n1}{n2}{}{rel}{KNOWS}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n1, rel, n2} \rangle$
			}
[
	{$\getvertices{n1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n1} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{n1},~\var{n2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n1, n2} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n1, rel, n2} \rangle$
			}
[
	{$\expandout{n1}{n2}{}{rel}{KNOWS}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n1, rel, n2} \rangle$
			}
[
	{$\getvertices{n1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n1} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsection{Get two related nodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[rel:KNOWS]->(x)
RETURN x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{x}} \Big(\alldifferent{} \Big(\expandout{\_e176}{x}{}{rel}{KNOWS}{1}{1} \Big(\getvertices{\_e176}{}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{x}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{x} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e176, rel, x} \rangle$
			}
[
	{$\expandout{\_e176}{x}{}{rel}{KNOWS}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e176, rel, x} \rangle$
			}
[
	{$\getvertices{\_e176}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e176} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{x}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{x} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e176, rel, x} \rangle$
			}
[
	{$\expandout{\_e176}{x}{}{rel}{KNOWS}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e176, rel, x} \rangle$
			}
[
	{$\getvertices{\_e176}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e176} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsection{Get related to related to}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)-->(a)-->(b)
RETURN b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handle comparison between node properties}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)-[rel]->(x)
WHERE n.animal = x.animal
RETURN n, x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{n},~\var{x}} \Big(\selection{\var{n.animal} = \var{x.animal}} \Big(\alldifferent{} \Big(\expandout{n}{x}{}{rel}{}{1}{1} \Big(\getvertices{n}{}
\Big)
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{n},~\var{x}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, x} \rangle$
			}
[
	{$\selection{\var{n.animal} = \var{x.animal}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, rel, x} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, rel, x} \rangle$
			}
[
	{$\expandout{n}{x}{}{rel}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, rel, x} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{n},~\var{x}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, x} \rangle$
			}
[
	{$\selection{\var{n.animal} = \var{x.animal}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, rel, x} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, rel, x} \rangle$
			}
[
	{$\expandout{n}{x}{}{rel}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, rel, x} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Return two subgraphs with bound undirected relationship}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-[r {name: 'r'}]-(b)
RETURN a, b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{a},~\var{b}} \Big(\alldifferent{} \Big(\expandboth{a}{b}{}{r}{}{1}{1} \Big(\getvertices{a}{}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b} \rangle$
			}
[
	{$\expandboth{a}{b}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b} \rangle$
			}
[
	{$\expandboth{a}{b}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsection{Return two subgraphs with bound undirected relationship and optional relationship}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-[r {name: 'r1'}]-(b)
OPTIONAL MATCH (b)-[r2]-(c)
WHERE r <> r2
RETURN a, b, c
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{a},~\var{b},~\var{c}} \Big(\alldifferent{} \Big(\expandboth{a}{b}{}{r}{}{1}{1} \Big(\getvertices{a}{}
\Big)
\Big)
 \join \selection{\var{r} \neq \var{r2}} \Big(\alldifferent{} \Big(\expandboth{b}{c}{}{r2}{}{1}{1} \Big(\getvertices{b}{}
\Big)
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b},~\var{c}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b, c} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b, r2, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b} \rangle$
			}
[
	{$\expandboth{a}{b}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\selection{\var{r} \neq \var{r2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b, r2, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b, r2, c} \rangle$
			}
[
	{$\expandboth{b}{c}{}{r2}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b, r2, c} \rangle$
			}
[
	{$\getvertices{b}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b},~\var{c}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b, c} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b, r2, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b} \rangle$
			}
[
	{$\expandboth{a}{b}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\selection{\var{r} \neq \var{r2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b, r2, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b, r2, c} \rangle$
			}
[
	{$\expandboth{b}{c}{}{r2}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b, r2, c} \rangle$
			}
[
	{$\getvertices{b}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
}

\subsection{Rel type function works as expected}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n {name: 'A'})-[r]->(x)
WHERE type(r) = 'KNOWS'
RETURN x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Walk alternative relationships}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)-[r]->(x)
WHERE type(r) = 'KNOWS' OR type(r) = 'HATES'
RETURN r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handle OR in the WHERE clause}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WHERE n.p1 = 12 OR n.p2 = 13
RETURN n
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{n}} \Big(\selection{\var{n.p1} = \literal{12} \lor \var{n.p2} = \literal{13}} \Big(\alldifferent{} \Big(\getvertices{n}{}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\selection{\var{n.p1} = \literal{12} \lor \var{n.p2} = \literal{13}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\selection{\var{n.p1} = \literal{12} \lor \var{n.p2} = \literal{13}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsection{Return a simple path}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (a {name: 'A'})-->(b)
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Return a three node path}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (a {name: 'A'})-[rel1]->(b)-[rel2]->(c)
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Do not return anything because path length does not match}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (n)-->(x)
WHERE length(p) = 10
RETURN x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Pass the path length test}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (n)-->(x)
WHERE length(p) = 1
RETURN x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Return relationships by fetching them from the path - starting from the end}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (a)-[:REL*2..2]->(b:End)
RETURN relationships(p)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Return relationships by fetching them from the path}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (a:Start)-[:REL*2..2]->(b)
RETURN relationships(p)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Return relationships by collecting them as a list - wrong way}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-[r:REL*2..2]->(b:End)
RETURN r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{r}} \Big(\alldifferent{} \Big(\expandout{a}{b}{End}{r}{REL}{2}{2} \Big(\getvertices{a}{}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{r} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b} \rangle$
			}
[
	{$\expandout{a}{b}{End}{r}{REL}{2}{2}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{r} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b} \rangle$
			}
[
	{$\expandout{a}{b}{End}{r}{REL}{2}{2}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsection{Return relationships by collecting them as a list - undirected}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-[r:REL*2..2]-(b:End)
RETURN r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{r}} \Big(\alldifferent{} \Big(\expandboth{a}{b}{End}{r}{REL}{2}{2} \Big(\getvertices{a}{}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{r} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b} \rangle$
			}
[
	{$\expandboth{a}{b}{End}{r}{REL}{2}{2}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{r} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b} \rangle$
			}
[
	{$\expandboth{a}{b}{End}{r}{REL}{2}{2}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsection{Return relationships by collecting them as a list}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:Start)-[r:REL*2..2]-(b)
RETURN r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{r}} \Big(\alldifferent{} \Big(\expandboth{a}{b}{}{r}{REL}{2}{2} \Big(\getvertices{a}{Start}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{r} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b} \rangle$
			}
[
	{$\expandboth{a}{b}{}{r}{REL}{2}{2}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b} \rangle$
			}
[
	{$\getvertices{a}{Start}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{r} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b} \rangle$
			}
[
	{$\expandboth{a}{b}{}{r}{REL}{2}{2}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b} \rangle$
			}
[
	{$\getvertices{a}{Start}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsection{Return a var length path}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (n {name: 'A'})-[:KNOWS*1..2]->(x)
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Return a var length path of length zero}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (a)-[*0..1]->(b)
RETURN a, b, length(p) AS l
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Return a named var length path of length zero}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (a {name: 'A'})-[:KNOWS*0..1]->(b)-[:FRIEND*0..1]->(c)
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Accept skip zero}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WHERE 1 = 0
RETURN n SKIP 0
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\topp{}{0} \Big(\projection{\var{n}} \Big(\selection{\literal{1} = \literal{0}} \Big(\alldifferent{} \Big(\getvertices{n}{}
\Big)
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\topp{}{0}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\selection{\literal{1} = \literal{0}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\topp{}{0}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\selection{\literal{1} = \literal{0}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}
\section{MatchAcceptance2}


\subsection{Do not return non-existent nodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{n}} \Big(\alldifferent{} \Big(\getvertices{n}{}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsection{Do not return non-existent relationships}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[r]->()
RETURN r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{r}} \Big(\alldifferent{} \Big(\expandout{\_e177}{\_e178}{}{r}{}{1}{1} \Big(\getvertices{\_e177}{}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{r} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e177, r, \_e178} \rangle$
			}
[
	{$\expandout{\_e177}{\_e178}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e177, r, \_e178} \rangle$
			}
[
	{$\getvertices{\_e177}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e177} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{r} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e177, r, \_e178} \rangle$
			}
[
	{$\expandout{\_e177}{\_e178}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e177, r, \_e178} \rangle$
			}
[
	{$\getvertices{\_e177}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e177} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsection{Do not fail when evaluating predicates with illegal operations if the AND'ed predicate evaluates to false}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (:Root {name: 'x'})-->(i:TextNode)
WHERE i.id > 'te'
RETURN i
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Do not fail when evaluating predicates with illegal operations if the OR'd predicate evaluates to true}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (:Root {name: 'x'})-->(i)
WHERE exists(i.id) OR i.id > 'te'
RETURN i
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Aggregation with named paths}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = ()-[*]->()
WITH count(*) AS count, p AS p
WITH nodes(p) AS nodes
RETURN *
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Zero-length variable length pattern in the middle of the pattern}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a {name: 'A'})-[:CONTAINS*0..1]->(b)-[:FRIEND*0..1]->(c)
RETURN a, b, c
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{a},~\var{b},~\var{c}} \Big(\alldifferent{} \Big(\expandout{b}{c}{}{\_e182}{FRIEND}{0}{1} \Big(\expandout{a}{b}{}{\_e181}{CONTAINS}{0}{1} \Big(\getvertices{a}{}
\Big)
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b},~\var{c}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e181, b, \_e182, c} \rangle$
			}
[
	{$\expandout{b}{c}{}{\_e182}{FRIEND}{0}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e181, b, \_e182, c} \rangle$
			}
[
	{$\expandout{a}{b}{}{\_e181}{CONTAINS}{0}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e181, b} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b},~\var{c}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e181, b, \_e182, c} \rangle$
			}
[
	{$\expandout{b}{c}{}{\_e182}{FRIEND}{0}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e181, b, \_e182, c} \rangle$
			}
[
	{$\expandout{a}{b}{}{\_e181}{CONTAINS}{0}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e181, b} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Simple variable length pattern}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a {name: 'A'})-[*]->(x)
RETURN x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Variable length relationship without lower bound}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = ({name: 'A'})-[:KNOWS*..2]->()
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Variable length relationship without bounds}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = ({name: 'A'})-[:KNOWS*..]->()
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Returning bound nodes that are not part of the pattern}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a {name: 'A'}), (c {name: 'C'})
MATCH (a)-->(b)
RETURN a, b, c
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Two bound nodes pointing to the same node}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a {name: 'A'}), (b {name: 'B'})
MATCH (a)-->(x)<-->(b)
RETURN x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Three bound nodes pointing to the same node}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a {name: 'A'}), (b {name: 'B'}), (c {name: 'C'})
MATCH (a)-->(x), (b)-->(x), (c)-->(x)
RETURN x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Three bound nodes pointing to the same node with extra connections}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a {name: 'a'}), (b {name: 'b'}), (c {name: 'c'})
MATCH (a)-->(x), (b)-->(x), (c)-->(x)
RETURN x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{MATCH with OPTIONAL MATCH in longer pattern}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a {name: 'A'})
OPTIONAL MATCH (a)-[:KNOWS]->()-[:KNOWS]->(foo)
RETURN foo
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{foo}} \Big(\alldifferent{} \Big(\getvertices{a}{}
\Big)
 \join \alldifferent{} \Big(\expandout{\_e184}{foo}{}{\_e186}{KNOWS}{1}{1} \Big(\expandout{a}{\_e184}{}{\_e185}{KNOWS}{1}{1} \Big(\getvertices{a}{}
\Big)
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{foo}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{foo} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e185, \_e184, \_e186, foo} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e185, \_e184, \_e186, foo} \rangle$
			}
[
	{$\expandout{\_e184}{foo}{}{\_e186}{KNOWS}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e185, \_e184, \_e186, foo} \rangle$
			}
[
	{$\expandout{a}{\_e184}{}{\_e185}{KNOWS}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e185, \_e184} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{foo}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{foo} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e185, \_e184, \_e186, foo} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e185, \_e184, \_e186, foo} \rangle$
			}
[
	{$\expandout{\_e184}{foo}{}{\_e186}{KNOWS}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e185, \_e184, \_e186, foo} \rangle$
			}
[
	{$\expandout{a}{\_e184}{}{\_e185}{KNOWS}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e185, \_e184} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
}

\subsection{Optionally matching named paths}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a {name: 'A'}), (x)
WHERE x.name IN ['B', 'C']
OPTIONAL MATCH p = (a)-->(x)
RETURN x, p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Optionally matching named paths with single and variable length patterns}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a {name: 'A'})
OPTIONAL MATCH p = (a)-->(b)-[*]->(c)
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Optionally matching named paths with variable length patterns}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a {name: 'A'}), (x)
WHERE x.name IN ['B', 'C']
OPTIONAL MATCH p = (a)-[r*]->(x)
RETURN r, x, p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Matching variable length patterns from a bound node}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[r*2]->()
RETURN r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{r}} \Big(\alldifferent{} \Big(\getvertices{a}{A}
\Big)
 \join \alldifferent{} \Big(\expandout{a}{\_e187}{}{r}{}{2}{} \Big(\getvertices{a}{A}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{r} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, \_e187} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, \_e187} \rangle$
			}
[
	{$\expandout{a}{\_e187}{}{r}{}{2}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, \_e187} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{r} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, \_e187} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, \_e187} \rangle$
			}
[
	{$\expandout{a}{\_e187}{}{r}{}{2}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, \_e187} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Excluding connected nodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A), (other:B)
OPTIONAL MATCH (a)-[r]->(other)
WITH other WHERE r IS NULL
RETURN other
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{other}} \Big(\alldifferent{} \Big(\getvertices{a}{A}
 \join \getvertices{other}{B}
\Big)
 \join \alldifferent{} \Big(\expandout{a}{other}{B}{r}{}{1}{1} \Big(\getvertices{a}{A}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{other}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{other} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, other, r} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, other} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, other} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\getvertices{other}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{other} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, other} \rangle$
			}
[
	{$\expandout{a}{other}{B}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, other} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{other}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{other} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, other, r} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, other} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, other} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\getvertices{other}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{other} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, other} \rangle$
			}
[
	{$\expandout{a}{other}{B}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, other} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Do not fail when predicates on optionally matched and missed nodes are invalid}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)-->(x0)
OPTIONAL MATCH (x0)-->(x1)
WHERE x1.foo = 'bar'
RETURN x0.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{MATCH and OPTIONAL MATCH on same pattern}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-->(b)
WHERE b:B
OPTIONAL MATCH (a)-->(c)
WHERE c:C
RETURN a.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Matching using an undirected pattern}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-[:ADMIN]-(b)
WHERE a:A
RETURN a.id, b.id
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Matching all nodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{n}} \Big(\alldifferent{} \Big(\getvertices{n}{}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsection{Comparing nodes for equality}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a), (b)
WHERE a <> b
RETURN a, b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{a},~\var{b}} \Big(\selection{\var{a} \neq \var{b}} \Big(\alldifferent{} \Big(\getvertices{a}{}
 \join \getvertices{b}{}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\selection{\var{a} \neq \var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\getvertices{b}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\selection{\var{a} \neq \var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
[
	{$\getvertices{b}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Matching using self-referencing pattern returns no result}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-->(b), (b)-->(b)
RETURN b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Variable length relationship in OPTIONAL MATCH}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A), (b:B)
OPTIONAL MATCH (a)-[r*]-(b)
WHERE r IS NULL
  AND a <> b
RETURN b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Matching using relationship predicate with multiples of the same type}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-[:T|:T]->(b)
RETURN b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{b}} \Big(\alldifferent{} \Big(\expandout{a}{b}{}{\_e189}{T}{1}{1} \Big(\getvertices{a}{}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e189, b} \rangle$
			}
[
	{$\expandout{a}{b}{}{\_e189}{T}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e189, b} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e189, b} \rangle$
			}
[
	{$\expandout{a}{b}{}{\_e189}{T}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e189, b} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsection{ORDER BY with LIMIT}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-->(n)-->(m)
RETURN n.x, count(*)
  ORDER BY n.x
  LIMIT 1000
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Simple node property predicate}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WHERE n.foo = 'bar'
RETURN n
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{n}} \Big(\selection{\var{n.foo} = \literal{''bar''}} \Big(\alldifferent{} \Big(\getvertices{n}{}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\selection{\var{n.foo} = \literal{''bar''}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\selection{\var{n.foo} = \literal{''bar''}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsection{Handling direction of named paths}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (b)<--(a)
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Simple OPTIONAL MATCH on empty graph}

\subsubsection*{Query specification}

\begin{lstlisting}
OPTIONAL MATCH (n)
RETURN n
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{n}} \Big(\alldifferent{} \Big(\getvertices{n}{}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsection{OPTIONAL MATCH with previously bound nodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
OPTIONAL MATCH (n)-[:NOT_EXIST]->(x)
RETURN n, x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{n},~\var{x}} \Big(\alldifferent{} \Big(\getvertices{n}{}
\Big)
 \join \alldifferent{} \Big(\expandout{n}{x}{}{\_e190}{NOT\_EXIST}{1}{1} \Big(\getvertices{n}{}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{n},~\var{x}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, x} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, \_e190, x} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, \_e190, x} \rangle$
			}
[
	{$\expandout{n}{x}{}{\_e190}{NOT\_EXIST}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, \_e190, x} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{n},~\var{x}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, x} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, \_e190, x} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, \_e190, x} \rangle$
			}
[
	{$\expandout{n}{x}{}{\_e190}{NOT\_EXIST}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, \_e190, x} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{`collect()` filtering nulls}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
OPTIONAL MATCH (n)-[:NOT_EXIST]->(x)
RETURN n, collect(x)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Multiple anonymous nodes in a pattern}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)<--()<--(b)-->()-->(c)
WHERE a:A
RETURN c
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Matching a relationship pattern using a label predicate}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-->(b:Foo)
RETURN b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Matching a relationship pattern using a label predicate on both sides}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (:A)-[r]->(:B)
RETURN r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{r}} \Big(\alldifferent{} \Big(\expandout{\_e193}{\_e194}{B}{r}{}{1}{1} \Big(\getvertices{\_e193}{A}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{r} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e193, r, \_e194} \rangle$
			}
[
	{$\expandout{\_e193}{\_e194}{B}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e193, r, \_e194} \rangle$
			}
[
	{$\getvertices{\_e193}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e193} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{r} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e193, r, \_e194} \rangle$
			}
[
	{$\expandout{\_e193}{\_e194}{B}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e193, r, \_e194} \rangle$
			}
[
	{$\getvertices{\_e193}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e193} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsection{Matching nodes using multiple labels}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A:B:C)
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{a}} \Big(\alldifferent{} \Big(\getvertices{a}{A \land B \land C}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A \land B \land C}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A \land B \land C}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsection{Returning label predicate expression}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN (n:Foo)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Matching with many predicates and larger pattern}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (advertiser)-[:ADV_HAS_PRODUCT]->(out)-[:AP_HAS_VALUE]->(red)<-[:AA_HAS_VALUE]-(a)
WHERE advertiser.id = $1
  AND a.id = $2
  AND red.name = 'red'
  AND out.name = 'product1'
RETURN out.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Returning label predicate expression}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN (n:Foo)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Matching using a simple pattern with label predicate}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n:Person)-->()
WHERE n.name = 'Bob'
RETURN n
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Matching disconnected patterns}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-->(b)
MATCH (c)-->(d)
RETURN a, b, c, d
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Non-optional matches should not return nulls}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)--(b)--(c)--(d)--(a), (b)--(d)
WHERE a.id = 1
  AND c.id = 2
RETURN d
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling cyclic patterns}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-[:A]->()-[:B]->(a)
RETURN a.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{a.name}} \Big(\alldifferent{} \Big(\expandout{\_e199}{a}{}{\_e201}{B}{1}{1} \Big(\expandout{a}{\_e199}{}{\_e200}{A}{1}{1} \Big(\getvertices{a}{}
\Big)
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e200, \_e199, \_e201} \rangle$
			}
[
	{$\expandout{\_e199}{a}{}{\_e201}{B}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e200, \_e199, \_e201} \rangle$
			}
[
	{$\expandout{a}{\_e199}{}{\_e200}{A}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e200, \_e199} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e200, \_e199, \_e201} \rangle$
			}
[
	{$\expandout{\_e199}{a}{}{\_e201}{B}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e200, \_e199, \_e201} \rangle$
			}
[
	{$\expandout{a}{\_e199}{}{\_e200}{A}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e200, \_e199} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Handling cyclic patterns when separated into two parts}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-[:A]->(b), (b)-[:B]->(a)
RETURN a.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{a.name}} \Big(\alldifferent{} \Big(\expandout{a}{b}{}{\_e202}{A}{1}{1} \Big(\getvertices{a}{}
\Big)
 \join \expandout{b}{a}{}{\_e203}{B}{1}{1} \Big(\getvertices{b}{}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e202, b, \_e203} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e202, b, \_e203} \rangle$
			}
[
	{$\expandout{a}{b}{}{\_e202}{A}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e202, b} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\expandout{b}{a}{}{\_e203}{B}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b, \_e203, a} \rangle$
			}
[
	{$\getvertices{b}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e202, b, \_e203} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e202, b, \_e203} \rangle$
			}
[
	{$\expandout{a}{b}{}{\_e202}{A}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e202, b} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\expandout{b}{a}{}{\_e203}{B}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b, \_e203, a} \rangle$
			}
[
	{$\getvertices{b}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Handling fixed-length variable length pattern}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-[r*1..1]->(b)
RETURN r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{r}} \Big(\alldifferent{} \Big(\expandout{a}{b}{}{r}{}{1}{1} \Big(\getvertices{a}{}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{r} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b} \rangle$
			}
[
	{$\expandout{a}{b}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{r} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b} \rangle$
			}
[
	{$\expandout{a}{b}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsection{Matching from null nodes should return no results owing to finding no matches}

\subsubsection*{Query specification}

\begin{lstlisting}
OPTIONAL MATCH (a)
WITH a
MATCH (a)-->(b)
RETURN b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Matching from null nodes should return no results owing to matches being filtered out}

\subsubsection*{Query specification}

\begin{lstlisting}
OPTIONAL MATCH (a:Label)
WITH a
MATCH (a)-->(b)
RETURN b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Optionally matching from null nodes should return null}

\subsubsection*{Query specification}

\begin{lstlisting}
OPTIONAL MATCH (a)
WITH a
OPTIONAL MATCH (a)-->(b)
RETURN b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{OPTIONAL MATCH returns null}

\subsubsection*{Query specification}

\begin{lstlisting}
OPTIONAL MATCH (a)
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{a}} \Big(\alldifferent{} \Big(\getvertices{a}{}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsection{Zero-length named path}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (a)
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Variable-length named path}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = ()-[*0..]->()
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Matching with aggregation}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n.prop AS n, count(n) AS count
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Matching using a relationship that is already bound}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[r1]->()
WITH r1 AS r2
MATCH ()-[r2]->()
RETURN r2 AS rel
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{r2}\assign \var{rel}} \Big(\alldifferent{} \Big(\expandout{\_e204}{\_e205}{}{r1}{}{1}{1} \Big(\getvertices{\_e204}{}
\Big)
\Big)
 \join \alldifferent{} \Big(\expandout{\_e206}{\_e207}{}{r2}{}{1}{1} \Big(\getvertices{\_e206}{}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{r2}\assign \var{rel}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{r2} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e204, r1, \_e205, \_e206, r2, \_e207} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e204, r1, \_e205} \rangle$
			}
[
	{$\expandout{\_e204}{\_e205}{}{r1}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e204, r1, \_e205} \rangle$
			}
[
	{$\getvertices{\_e204}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e204} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e206, r2, \_e207} \rangle$
			}
[
	{$\expandout{\_e206}{\_e207}{}{r2}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e206, r2, \_e207} \rangle$
			}
[
	{$\getvertices{\_e206}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e206} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{r2}\assign \var{rel}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{r2} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e204, r1, \_e205, \_e206, r2, \_e207} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e204, r1, \_e205} \rangle$
			}
[
	{$\expandout{\_e204}{\_e205}{}{r1}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e204, r1, \_e205} \rangle$
			}
[
	{$\getvertices{\_e204}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e204} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e206, r2, \_e207} \rangle$
			}
[
	{$\expandout{\_e206}{\_e207}{}{r2}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e206, r2, \_e207} \rangle$
			}
[
	{$\getvertices{\_e206}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e206} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Matching using a relationship that is already bound, in conjunction with aggregation}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[r1]->()
WITH r1 AS r2, count(*) AS c
  ORDER BY c
MATCH ()-[r2]->()
RETURN r2 AS rel
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{r2}\assign \var{rel}} \Big(\alldifferent{} \Big(\expandout{\_e208}{\_e209}{}{r1}{}{1}{1} \Big(\getvertices{\_e208}{}
\Big)
\Big)
 \join \alldifferent{} \Big(\expandout{\_e210}{\_e211}{}{r2}{}{1}{1} \Big(\getvertices{\_e210}{}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{r2}\assign \var{rel}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{r2} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e208, r1, \_e209, \_e210, r2, \_e211} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e208, r1, \_e209} \rangle$
			}
[
	{$\expandout{\_e208}{\_e209}{}{r1}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e208, r1, \_e209} \rangle$
			}
[
	{$\getvertices{\_e208}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e208} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e210, r2, \_e211} \rangle$
			}
[
	{$\expandout{\_e210}{\_e211}{}{r2}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e210, r2, \_e211} \rangle$
			}
[
	{$\getvertices{\_e210}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e210} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{r2}\assign \var{rel}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{r2} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e208, r1, \_e209, \_e210, r2, \_e211} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e208, r1, \_e209} \rangle$
			}
[
	{$\expandout{\_e208}{\_e209}{}{r1}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e208, r1, \_e209} \rangle$
			}
[
	{$\getvertices{\_e208}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e208} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e210, r2, \_e211} \rangle$
			}
[
	{$\expandout{\_e210}{\_e211}{}{r2}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e210, r2, \_e211} \rangle$
			}
[
	{$\getvertices{\_e210}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e210} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Matching using a relationship that is already bound, in conjunction with aggregation and ORDER BY}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-[r]->(b)
WITH a, r, b, count(*) AS c
  ORDER BY c
MATCH (a)-[r]->(b)
RETURN r AS rel
  ORDER BY rel.id
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Matching with LIMIT and optionally matching using a relationship that is already bound}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[r]->()
WITH r
  LIMIT 1
OPTIONAL MATCH (a2)-[r]->(b2)
RETURN a2, r, b2
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{a2},~\var{r},~\var{b2}} \Big(\alldifferent{} \Big(\expandout{\_e212}{\_e213}{}{r}{}{1}{1} \Big(\getvertices{\_e212}{}
\Big)
\Big)
 \join \alldifferent{} \Big(\expandout{a2}{b2}{}{r}{}{1}{1} \Big(\getvertices{a2}{}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a2},~\var{r},~\var{b2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a2, r, b2} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e212, r, \_e213, a2, b2} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e212, r, \_e213} \rangle$
			}
[
	{$\expandout{\_e212}{\_e213}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e212, r, \_e213} \rangle$
			}
[
	{$\getvertices{\_e212}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e212} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a2, r, b2} \rangle$
			}
[
	{$\expandout{a2}{b2}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a2, r, b2} \rangle$
			}
[
	{$\getvertices{a2}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a2} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a2},~\var{r},~\var{b2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a2, r, b2} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e212, r, \_e213, a2, b2} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e212, r, \_e213} \rangle$
			}
[
	{$\expandout{\_e212}{\_e213}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e212, r, \_e213} \rangle$
			}
[
	{$\getvertices{\_e212}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e212} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a2, r, b2} \rangle$
			}
[
	{$\expandout{a2}{b2}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a2, r, b2} \rangle$
			}
[
	{$\getvertices{a2}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a2} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Matching with LIMIT and optionally matching using a relationship and node that are both already bound}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a1)-[r]->()
WITH r, a1
  LIMIT 1
OPTIONAL MATCH (a1)-[r]->(b2)
RETURN a1, r, b2
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{a1},~\var{r},~\var{b2}} \Big(\alldifferent{} \Big(\expandout{a1}{\_e214}{}{r}{}{1}{1} \Big(\getvertices{a1}{}
\Big)
\Big)
 \join \alldifferent{} \Big(\expandout{a1}{b2}{}{r}{}{1}{1} \Big(\getvertices{a1}{}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a1},~\var{r},~\var{b2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e214, b2} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e214} \rangle$
			}
[
	{$\expandout{a1}{\_e214}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e214} \rangle$
			}
[
	{$\getvertices{a1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2} \rangle$
			}
[
	{$\expandout{a1}{b2}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2} \rangle$
			}
[
	{$\getvertices{a1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a1},~\var{r},~\var{b2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e214, b2} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e214} \rangle$
			}
[
	{$\expandout{a1}{\_e214}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e214} \rangle$
			}
[
	{$\getvertices{a1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2} \rangle$
			}
[
	{$\expandout{a1}{b2}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2} \rangle$
			}
[
	{$\getvertices{a1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Matching with LIMIT, then matching again using a relationship and node that are both already bound along with an additional predicate}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a1)-[r]->()
WITH r, a1
  LIMIT 1
MATCH (a1:X)-[r]->(b2)
RETURN a1, r, b2
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{a1},~\var{r},~\var{b2}} \Big(\alldifferent{} \Big(\expandout{a1}{\_e215}{}{r}{}{1}{1} \Big(\getvertices{a1}{X}
\Big)
\Big)
 \join \alldifferent{} \Big(\expandout{a1}{b2}{}{r}{}{1}{1} \Big(\getvertices{a1}{X}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a1},~\var{r},~\var{b2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e215, b2} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e215} \rangle$
			}
[
	{$\expandout{a1}{\_e215}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e215} \rangle$
			}
[
	{$\getvertices{a1}{X}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2} \rangle$
			}
[
	{$\expandout{a1}{b2}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2} \rangle$
			}
[
	{$\getvertices{a1}{X}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a1},~\var{r},~\var{b2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e215, b2} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e215} \rangle$
			}
[
	{$\expandout{a1}{\_e215}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e215} \rangle$
			}
[
	{$\getvertices{a1}{X}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2} \rangle$
			}
[
	{$\expandout{a1}{b2}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2} \rangle$
			}
[
	{$\getvertices{a1}{X}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Matching with LIMIT and predicates, then matching again using a relationship and node that are both already bound along with a duplicate predicate}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a1:X:Y)-[r]->()
WITH r, a1
  LIMIT 1
MATCH (a1:Y)-[r]->(b2)
RETURN a1, r, b2
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{a1},~\var{r},~\var{b2}} \Big(\alldifferent{} \Big(\expandout{a1}{\_e216}{}{r}{}{1}{1} \Big(\getvertices{a1}{X \land Y}
\Big)
\Big)
 \join \alldifferent{} \Big(\expandout{a1}{b2}{}{r}{}{1}{1} \Big(\getvertices{a1}{X \land Y}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a1},~\var{r},~\var{b2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e216, b2} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e216} \rangle$
			}
[
	{$\expandout{a1}{\_e216}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e216} \rangle$
			}
[
	{$\getvertices{a1}{X \land Y}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2} \rangle$
			}
[
	{$\expandout{a1}{b2}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2} \rangle$
			}
[
	{$\getvertices{a1}{X \land Y}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a1},~\var{r},~\var{b2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e216, b2} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e216} \rangle$
			}
[
	{$\expandout{a1}{\_e216}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e216} \rangle$
			}
[
	{$\getvertices{a1}{X \land Y}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2} \rangle$
			}
[
	{$\expandout{a1}{b2}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2} \rangle$
			}
[
	{$\getvertices{a1}{X \land Y}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Matching twice with conflicting relationship types on same relationship}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a1)-[r:T]->()
WITH r, a1
  LIMIT 1
MATCH (a1)-[r:Y]->(b2)
RETURN a1, r, b2
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{a1},~\var{r},~\var{b2}} \Big(\alldifferent{} \Big(\expandout{a1}{\_e217}{}{r}{CONTRADICTING LABEL CONSTRAINTS}{1}{1} \Big(\getvertices{a1}{}
\Big)
\Big)
 \join \alldifferent{} \Big(\expandout{a1}{b2}{}{r}{CONTRADICTING LABEL CONSTRAINTS}{1}{1} \Big(\getvertices{a1}{}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a1},~\var{r},~\var{b2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e217, b2} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e217} \rangle$
			}
[
	{$\expandout{a1}{\_e217}{}{r}{CONTRADICTING LABEL CONSTRAINTS}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e217} \rangle$
			}
[
	{$\getvertices{a1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2} \rangle$
			}
[
	{$\expandout{a1}{b2}{}{r}{CONTRADICTING LABEL CONSTRAINTS}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2} \rangle$
			}
[
	{$\getvertices{a1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a1},~\var{r},~\var{b2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e217, b2} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e217} \rangle$
			}
[
	{$\expandout{a1}{\_e217}{}{r}{CONTRADICTING LABEL CONSTRAINTS}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e217} \rangle$
			}
[
	{$\getvertices{a1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2} \rangle$
			}
[
	{$\expandout{a1}{b2}{}{r}{CONTRADICTING LABEL CONSTRAINTS}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2} \rangle$
			}
[
	{$\getvertices{a1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Matching twice with duplicate relationship types on same relationship}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a1)-[r:T]->() WITH r, a1
LIMIT 1
MATCH (a1)-[r:T]->(b2)
RETURN a1, r, b2
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{a1},~\var{r},~\var{b2}} \Big(\alldifferent{} \Big(\expandout{a1}{\_e218}{}{r}{T}{1}{1} \Big(\getvertices{a1}{}
\Big)
\Big)
 \join \alldifferent{} \Big(\expandout{a1}{b2}{}{r}{T}{1}{1} \Big(\getvertices{a1}{}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a1},~\var{r},~\var{b2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e218, b2} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e218} \rangle$
			}
[
	{$\expandout{a1}{\_e218}{}{r}{T}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e218} \rangle$
			}
[
	{$\getvertices{a1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2} \rangle$
			}
[
	{$\expandout{a1}{b2}{}{r}{T}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2} \rangle$
			}
[
	{$\getvertices{a1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a1},~\var{r},~\var{b2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e218, b2} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e218} \rangle$
			}
[
	{$\expandout{a1}{\_e218}{}{r}{T}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e218} \rangle$
			}
[
	{$\getvertices{a1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2} \rangle$
			}
[
	{$\expandout{a1}{b2}{}{r}{T}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2} \rangle$
			}
[
	{$\getvertices{a1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Matching relationships into a list and matching variable length using the list}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[r1]->()-[r2]->()
WITH [r1, r2] AS rs
  LIMIT 1
MATCH (first)-[rs*]->(second)
RETURN first, second
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Matching relationships into a list and matching variable length using the list, with bound nodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-[r1]->()-[r2]->(b)
WITH [r1, r2] AS rs, a AS first, b AS second
  LIMIT 1
MATCH (first)-[rs*]->(second)
RETURN first, second
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Matching relationships into a list and matching variable length using the list, with bound nodes, wrong direction}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-[r1]->()-[r2]->(b)
WITH [r1, r2] AS rs, a AS second, b AS first
  LIMIT 1
MATCH (first)-[rs*]->(second)
RETURN first, second
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Matching and optionally matching with bound nodes in reverse direction}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a1)-[r]->()
WITH r, a1
  LIMIT 1
OPTIONAL MATCH (a1)<-[r]-(b2)
RETURN a1, r, b2
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{a1},~\var{r},~\var{b2}} \Big(\alldifferent{} \Big(\expandout{a1}{\_e224}{}{r}{}{1}{1} \Big(\getvertices{a1}{}
\Big)
\Big)
 \join \alldifferent{} \Big(\expandin{a1}{b2}{}{r}{}{1}{1} \Big(\getvertices{a1}{}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a1},~\var{r},~\var{b2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e224, b2} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e224} \rangle$
			}
[
	{$\expandout{a1}{\_e224}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e224} \rangle$
			}
[
	{$\getvertices{a1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2} \rangle$
			}
[
	{$\expandin{a1}{b2}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2} \rangle$
			}
[
	{$\getvertices{a1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a1},~\var{r},~\var{b2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e224, b2} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e224} \rangle$
			}
[
	{$\expandout{a1}{\_e224}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e224} \rangle$
			}
[
	{$\getvertices{a1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2} \rangle$
			}
[
	{$\expandin{a1}{b2}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2} \rangle$
			}
[
	{$\getvertices{a1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Matching and optionally matching with unbound nodes and equality predicate in reverse direction}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a1)-[r]->()
WITH r, a1
  LIMIT 1
OPTIONAL MATCH (a2)<-[r]-(b2)
WHERE a1 = a2
RETURN a1, r, b2, a2
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{a1},~\var{r},~\var{b2},~\var{a2}} \Big(\alldifferent{} \Big(\expandout{a1}{\_e225}{}{r}{}{1}{1} \Big(\getvertices{a1}{}
\Big)
\Big)
 \join \selection{\var{a1} = \var{a2}} \Big(\alldifferent{} \Big(\expandin{a2}{b2}{}{r}{}{1}{1} \Big(\getvertices{a2}{}
\Big)
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a1},~\var{r},~\var{b2},~\var{a2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2, a2} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e225, a2, b2} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e225} \rangle$
			}
[
	{$\expandout{a1}{\_e225}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e225} \rangle$
			}
[
	{$\getvertices{a1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\selection{\var{a1} = \var{a2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a2, r, b2} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a2, r, b2} \rangle$
			}
[
	{$\expandin{a2}{b2}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a2, r, b2} \rangle$
			}
[
	{$\getvertices{a2}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a2} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a1},~\var{r},~\var{b2},~\var{a2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, b2, a2} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e225, a2, b2} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e225} \rangle$
			}
[
	{$\expandout{a1}{\_e225}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1, r, \_e225} \rangle$
			}
[
	{$\getvertices{a1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a1} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\selection{\var{a1} = \var{a2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a2, r, b2} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a2, r, b2} \rangle$
			}
[
	{$\expandin{a2}{b2}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a2, r, b2} \rangle$
			}
[
	{$\getvertices{a2}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a2} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
}

\subsection{Matching and returning ordered results, with LIMIT}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (foo)
RETURN foo.bar AS x
  ORDER BY x DESC
  LIMIT 4
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\topp{4}{} \Big(\sort{\desc \var{x}} \Big(\projection{\var{foo.bar}\assign \var{x}} \Big(\alldifferent{} \Big(\getvertices{foo}{}
\Big)
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\topp{4}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bar} \rangle$
			}
[
	{$\sort{\desc \var{x}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bar} \rangle$
			}
[
	{$\projection{\var{foo.bar}\assign \var{x}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bar} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{foo} \rangle$
			}
[
	{$\getvertices{foo}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{foo} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\topp{4}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bar} \rangle$
			}
[
	{$\sort{\desc \var{x}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bar} \rangle$
			}
[
	{$\projection{\var{foo.bar}\assign \var{x}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bar} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{foo} \rangle$
			}
[
	{$\getvertices{foo}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{foo} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Counting an empty graph}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
RETURN count(a) > 0
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Matching variable length pattern with property predicate}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:Artist)-[:WORKED_WITH* {year: 1988}]->(b:Artist)
RETURN *
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Variable length pattern checking labels on endnodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a), (b)
WHERE a.id = 0
  AND (a)-[:T]->(b:Label)
  OR (a)-[:T*]->(b:MissingLabel)
RETURN DISTINCT b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Variable length pattern with label predicate on both sides}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:Blue)-[r*]->(b:Green)
RETURN count(r)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Undirected named path}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (n:Movie)--(m)
RETURN p
  LIMIT 1
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Named path with WITH}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (a)
WITH p
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Named path with alternating directed/undirected relationships}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (n)-->(m)--(o)
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Named path with multiple alternating directed/undirected relationships}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH path = (n)-->(m)--(o)--(p)
RETURN path
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Named path with undirected fixed variable length pattern}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH topRoute = (:Start)<-[:CONNECTED_TO]-()-[:CONNECTED_TO*3..3]-(:End)
RETURN topRoute
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Returning a node property value}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
RETURN a.prop
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{a.prop}} \Big(\alldifferent{} \Big(\getvertices{a}{}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a.prop}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{prop} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a.prop}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{prop} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsection{Returning a relationship property value}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[r]->()
RETURN r.prop
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{r.prop}} \Big(\alldifferent{} \Big(\expandout{\_e229}{\_e230}{}{r}{}{1}{1} \Big(\getvertices{\_e229}{}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{r.prop}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{prop} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e229, r, \_e230} \rangle$
			}
[
	{$\expandout{\_e229}{\_e230}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e229, r, \_e230} \rangle$
			}
[
	{$\getvertices{\_e229}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e229} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{r.prop}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{prop} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e229, r, \_e230} \rangle$
			}
[
	{$\expandout{\_e229}{\_e230}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e229, r, \_e230} \rangle$
			}
[
	{$\getvertices{\_e229}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e229} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsection{Projecting nodes and relationships}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-[r]->()
RETURN a AS foo, r AS bar
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{a}\assign \var{foo},~\var{r}\assign \var{bar}} \Big(\alldifferent{} \Big(\expandout{a}{\_e231}{}{r}{}{1}{1} \Big(\getvertices{a}{}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a}\assign \var{foo},~\var{r}\assign \var{bar}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, \_e231} \rangle$
			}
[
	{$\expandout{a}{\_e231}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, \_e231} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a}\assign \var{foo},~\var{r}\assign \var{bar}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, \_e231} \rangle$
			}
[
	{$\expandout{a}{\_e231}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, \_e231} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsection{Missing node property should become null}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
RETURN a.bar
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{a.bar}} \Big(\alldifferent{} \Big(\getvertices{a}{}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a.bar}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bar} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a.bar}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bar} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsection{Missing relationship property should become null}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[r]->()
RETURN r.bar
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{r.bar}} \Big(\alldifferent{} \Big(\expandout{\_e232}{\_e233}{}{r}{}{1}{1} \Big(\getvertices{\_e232}{}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{r.bar}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bar} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e232, r, \_e233} \rangle$
			}
[
	{$\expandout{\_e232}{\_e233}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e232, r, \_e233} \rangle$
			}
[
	{$\getvertices{\_e232}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e232} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{r.bar}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{bar} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e232, r, \_e233} \rangle$
			}
[
	{$\expandout{\_e232}{\_e233}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e232, r, \_e233} \rangle$
			}
[
	{$\getvertices{\_e232}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{\_e232} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsection{Returning multiple node property values}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
RETURN a.name, a.age, a.seasons
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{a.name},~\var{a.age},~\var{a.seasons}} \Big(\alldifferent{} \Big(\getvertices{a}{}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a.name},~\var{a.age},~\var{a.seasons}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name, age, seasons} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a.name},~\var{a.age},~\var{a.seasons}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name, age, seasons} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsection{Adding a property and a literal in projection}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
RETURN a.prop + 1 AS foo
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Adding list properties in projection}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
RETURN a.prop2 + a.prop1 AS foo
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Variable length relationship variables are lists of relationships}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[r*0..1]-()
RETURN last(r) AS l
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Variable length patterns and nulls}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
OPTIONAL MATCH (a)-[:FOO]->(b:B)
OPTIONAL MATCH (b)<-[:BAR*]-(c:B)
RETURN a, b, c
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Projecting a list of nodes and relationships}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)-[r]->(m)
RETURN [n, r, m] AS r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Projecting a map of nodes and relationships}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)-[r]->(m)
RETURN {node1: n, rel: r, node2: m} AS m
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Respecting direction when matching existing path}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = ({prop: 'a'})-->({prop: 'b'})
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Respecting direction when matching non-existent path}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = ({prop: 'a'})<--({prop: 'b'})
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Respecting direction when matching non-existent path with multiple directions}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (n)-->(k)<--(n)
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Matching path with both directions should respect other directions}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (n)<-->(k)<--(n)
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Matching path with multiple bidirectional relationships}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p=(n)<-->(k)<-->(n)
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Matching nodes with many labels}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n:A:B:C:D:E:F:G:H:I:J:K:L:M)-[:T]->(m:Z:Y:X:W:V:U)
RETURN n, m
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{n},~\var{m}} \Big(\alldifferent{} \Big(\expandout{n}{m}{Z \land Y \land X \land W \land V \land U}{\_e238}{T}{1}{1} \Big(\getvertices{n}{A \land B \land C \land D \land E \land F \land G \land H \land I \land J \land K \land L \land M}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{n},~\var{m}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, m} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, \_e238, m} \rangle$
			}
[
	{$\expandout{n}{m}{Z \land Y \land X \land W \land V \land U}{\_e238}{T}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, \_e238, m} \rangle$
			}
[
	{$\getvertices{n}{A \land B \land C \land D \land E \land F \land G \land H \land I \land J \land K \land L \land M}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{n},~\var{m}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, m} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, \_e238, m} \rangle$
			}
[
	{$\expandout{n}{m}{Z \land Y \land X \land W \land V \land U}{\_e238}{T}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, \_e238, m} \rangle$
			}
[
	{$\getvertices{n}{A \land B \land C \land D \land E \land F \land G \land H \land I \land J \land K \land L \land M}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsection{Matching longer variable length paths}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n {prop: 'start'})-[:T*]->(m {prop: 'end'})
RETURN m
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Matching a self-loop}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[r]-()
RETURN type(r) AS r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
\section{MergeIntoAcceptance}

\section{MergeNodeAcceptance}

\section{MergeRelationshipAcceptance}

\section{MiscellaneousErrorAcceptance}

\section{NullAcceptance}

\section{OptionalMatch}


\subsection{Satisfies the open world assumption, relationships between same nodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (p:Player)-[:PLAYS_FOR]->(team:Team)
OPTIONAL MATCH (p)-[s:SUPPORTS]->(team)
RETURN count(*) AS matches, s IS NULL AS optMatch
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Satisfies the open world assumption, single relationship}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (p:Player)-[:PLAYS_FOR]->(team:Team)
OPTIONAL MATCH (p)-[s:SUPPORTS]->(team)
RETURN count(*) AS matches, s IS NULL AS optMatch
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Satisfies the open world assumption, relationships between different nodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (p:Player)-[:PLAYS_FOR]->(team:Team)
OPTIONAL MATCH (p)-[s:SUPPORTS]->(team)
RETURN count(*) AS matches, s IS NULL AS optMatch
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
\section{OptionalMatchAcceptance}


\subsection{Return null when no matches due to inline label predicate}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n:Single)
OPTIONAL MATCH (n)-[r]-(m:NonExistent)
RETURN r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{r}} \Big(\alldifferent{} \Big(\getvertices{n}{Single}
\Big)
 \join \alldifferent{} \Big(\expandboth{n}{m}{NonExistent}{r}{}{1}{1} \Big(\getvertices{n}{Single}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{r} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, r, m} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, r, m} \rangle$
			}
[
	{$\expandboth{n}{m}{NonExistent}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, r, m} \rangle$
			}
[
	{$\getvertices{n}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{r} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, r, m} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, r, m} \rangle$
			}
[
	{$\expandboth{n}{m}{NonExistent}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, r, m} \rangle$
			}
[
	{$\getvertices{n}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Return null when no matches due to label predicate in WHERE}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n:Single)
OPTIONAL MATCH (n)-[r]-(m)
WHERE m:NonExistent
RETURN r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Respect predicates on the OPTIONAL MATCH}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n:Single)
OPTIONAL MATCH (n)-[r]-(m)
WHERE m.prop = 42
RETURN m
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{m}} \Big(\alldifferent{} \Big(\getvertices{n}{Single}
\Big)
 \join \selection{\var{m.prop} = \literal{42}} \Big(\alldifferent{} \Big(\expandboth{n}{m}{}{r}{}{1}{1} \Big(\getvertices{n}{Single}
\Big)
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{m}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{m} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, r, m} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\selection{\var{m.prop} = \literal{42}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, r, m} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, r, m} \rangle$
			}
[
	{$\expandboth{n}{m}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, r, m} \rangle$
			}
[
	{$\getvertices{n}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{m}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{m} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, r, m} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\selection{\var{m.prop} = \literal{42}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, r, m} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, r, m} \rangle$
			}
[
	{$\expandboth{n}{m}{}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, r, m} \rangle$
			}
[
	{$\getvertices{n}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
}

\subsection{Returning label predicate on null node}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n:Single)
OPTIONAL MATCH (n)-[r:TYPE]-(m)
RETURN m:TYPE
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{m}} \Big(\alldifferent{} \Big(\getvertices{n}{Single}
\Big)
 \join \alldifferent{} \Big(\expandboth{n}{m}{}{r}{TYPE}{1}{1} \Big(\getvertices{n}{Single}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{m}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{m} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, r, m} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, r, m} \rangle$
			}
[
	{$\expandboth{n}{m}{}{r}{TYPE}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, r, m} \rangle$
			}
[
	{$\getvertices{n}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{m}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{m} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, r, m} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, r, m} \rangle$
			}
[
	{$\expandboth{n}{m}{}{r}{TYPE}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n, r, m} \rangle$
			}
[
	{$\getvertices{n}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{MATCH after OPTIONAL MATCH}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:Single)
OPTIONAL MATCH (a)-->(b:NonExistent)
OPTIONAL MATCH (a)-->(c:NonExistent)
WITH coalesce(b, c) AS x
MATCH (x)-->(d)
RETURN d
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{WITH after OPTIONAL MATCH}

\subsubsection*{Query specification}

\begin{lstlisting}
OPTIONAL MATCH (a:A)
WITH a AS a
MATCH (b:B)
RETURN a, b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{a},~\var{b}} \Big(\alldifferent{} \Big(\getvertices{a}{A}
\Big)
 \join \alldifferent{} \Big(\getvertices{b}{B}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			}
[
	{$\getvertices{b}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			}
[
	{$\getvertices{b}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsection{Named paths in optional matches}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
OPTIONAL MATCH p = (a)-[:X]->(b)
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{OPTIONAL MATCH and bound nodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A), (b:C)
OPTIONAL MATCH (x)-->(b)
RETURN x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{OPTIONAL MATCH with labels on the optional end node}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:X)
OPTIONAL MATCH (a)-->(b:Y)
RETURN b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Named paths inside optional matches with node predicates}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A), (b:B)
OPTIONAL MATCH p = (a)-[:X]->(b)
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Variable length optional relationships}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:Single)
OPTIONAL MATCH (a)-[*]->(b)
RETURN b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Variable length optional relationships with length predicates}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:Single)
OPTIONAL MATCH (a)-[*3..]-(b)
RETURN b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{b}} \Big(\alldifferent{} \Big(\getvertices{a}{Single}
\Big)
 \join \alldifferent{} \Big(\expandboth{a}{b}{}{\_e246}{}{3}{} \Big(\getvertices{a}{Single}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e246, b} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e246, b} \rangle$
			}
[
	{$\expandboth{a}{b}{}{\_e246}{}{3}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e246, b} \rangle$
			}
[
	{$\getvertices{a}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e246, b} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e246, b} \rangle$
			}
[
	{$\expandboth{a}{b}{}{\_e246}{}{3}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e246, b} \rangle$
			}
[
	{$\getvertices{a}{Single}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Optionally matching self-loops}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:B)
OPTIONAL MATCH (a)-[r]-(a)
RETURN r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{r}} \Big(\alldifferent{} \Big(\getvertices{a}{B}
\Big)
 \join \alldifferent{} \Big(\expandboth{a}{a}{B}{r}{}{1}{1} \Big(\getvertices{a}{B}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{r} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r} \rangle$
			}
[
	{$\expandboth{a}{a}{B}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r} \rangle$
			}
[
	{$\getvertices{a}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{r} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r} \rangle$
			}
[
	{$\expandboth{a}{a}{B}{r}{}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r} \rangle$
			}
[
	{$\getvertices{a}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Optionally matching self-loops without matches}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE NOT (a:B)
OPTIONAL MATCH (a)-[r]->(a)
RETURN r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Variable length optional relationships with bound nodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:Single), (x:C)
OPTIONAL MATCH (a)-[*]->(x)
RETURN x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Variable length optional relationships with bound nodes, no matches}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A), (b:B)
OPTIONAL MATCH p = (a)-[*]->(b)
RETURN p
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Longer pattern with bound nodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:Single), (c:C)
OPTIONAL MATCH (a)-->(b)-->(c)
RETURN b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Longer pattern with bound nodes without matches}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A), (c:C)
OPTIONAL MATCH (a)-->(b)-->(c)
RETURN b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling correlated optional matches; first does not match implies second does not match}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A), (b:B)
OPTIONAL MATCH (a)-->(x)
OPTIONAL MATCH (x)-[r]->(b)
RETURN x, r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling optional matches between optionally matched entities}

\subsubsection*{Query specification}

\begin{lstlisting}
OPTIONAL MATCH (a:NotThere)
WITH a
MATCH (b:B)
WITH a, b
OPTIONAL MATCH (b)-[r:NOR_THIS]->(a)
RETURN a, b, r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{a},~\var{b},~\var{r}} \Big(\alldifferent{} \Big(\getvertices{a}{NotThere}
\Big)
 \join \alldifferent{} \Big(\getvertices{b}{B}
\Big)
 \join \alldifferent{} \Big(\expandout{b}{a}{NotThere}{r}{NOR\_THIS}{1}{1} \Big(\getvertices{b}{B}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b},~\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b, r} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b, r} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{NotThere}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			}
[
	{$\getvertices{b}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b, r, a} \rangle$
			}
[
	{$\expandout{b}{a}{NotThere}{r}{NOR\_THIS}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b, r, a} \rangle$
			}
[
	{$\getvertices{b}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b},~\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b, r} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b, r} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{NotThere}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			}
[
	{$\getvertices{b}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b, r, a} \rangle$
			}
[
	{$\expandout{b}{a}{NotThere}{r}{NOR\_THIS}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b, r, a} \rangle$
			}
[
	{$\getvertices{b}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Handling optional matches between nulls}

\subsubsection*{Query specification}

\begin{lstlisting}
OPTIONAL MATCH (a:NotThere)
OPTIONAL MATCH (b:NotThere)
WITH a, b
OPTIONAL MATCH (b)-[r:NOR_THIS]->(a)
RETURN a, b, r
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{a},~\var{b},~\var{r}} \Big(\alldifferent{} \Big(\getvertices{a}{NotThere}
\Big)
 \join \alldifferent{} \Big(\getvertices{b}{NotThere}
\Big)
 \join \alldifferent{} \Big(\expandout{b}{a}{NotThere}{r}{NOR\_THIS}{1}{1} \Big(\getvertices{b}{NotThere}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b},~\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b, r} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b, r} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{NotThere}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			}
[
	{$\getvertices{b}{NotThere}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b, r, a} \rangle$
			}
[
	{$\expandout{b}{a}{NotThere}{r}{NOR\_THIS}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b, r, a} \rangle$
			}
[
	{$\getvertices{b}{NotThere}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b},~\var{r}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b, r} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b, r} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{NotThere}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			}
[
	{$\getvertices{b}{NotThere}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b, r, a} \rangle$
			}
[
	{$\expandout{b}{a}{NotThere}{r}{NOR\_THIS}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b, r, a} \rangle$
			}
[
	{$\getvertices{b}{NotThere}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{OPTIONAL MATCH and `collect()`}

\subsubsection*{Query specification}

\begin{lstlisting}
OPTIONAL MATCH (f:DoesExist)
OPTIONAL MATCH (n:DoesNotExist)
RETURN collect(DISTINCT n.property) AS a, collect(DISTINCT f.property) AS b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
\section{OrderByAcceptance}


\subsection{ORDER BY should return results in ascending order}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n.prop AS prop
ORDER BY n.prop
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{ORDER BY DESC should return results in descending order}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n.prop AS prop
ORDER BY n.prop DESC
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{ORDER BY of a column introduced in RETURN should return salient results in ascending order}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH [0, 1] AS prows, [[2], [3, 4]] AS qrows
UNWIND prows AS p
UNWIND qrows[p] AS q
WITH p, count(q) AS rng
RETURN p
ORDER BY rng
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Renaming columns before ORDER BY should return results in ascending order}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n.prop AS n
ORDER BY n + 2
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handle projections with ORDER BY - GH\#4937}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (c:Crew {name: 'Neo'})
WITH c, 0 AS relevance
RETURN c.rank AS rank
ORDER BY relevance, c.rank
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{ORDER BY should order booleans in the expected order}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND [true, false] AS bools
RETURN bools
ORDER BY bools
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{ORDER BY DESC should order booleans in the expected order}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND [true, false] AS bools
RETURN bools
ORDER BY bools DESC
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{ORDER BY should order strings in the expected order}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND ['.*', '', ' ', 'one'] AS strings
RETURN strings
ORDER BY strings
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{ORDER BY DESC should order strings in the expected order}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND ['.*', '', ' ', 'one'] AS strings
RETURN strings
ORDER BY strings DESC
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{ORDER BY should order ints in the expected order}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND [1, 3, 2] AS ints
RETURN ints
ORDER BY ints
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{ORDER BY DESC should order ints in the expected order}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND [1, 3, 2] AS ints
RETURN ints
ORDER BY ints DESC
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{ORDER BY should order floats in the expected order}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND [1.5, 1.3, 999.99] AS floats
RETURN floats
ORDER BY floats
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{ORDER BY DESC should order floats in the expected order}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND [1.5, 1.3, 999.99] AS floats
RETURN floats
ORDER BY floats DESC
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handle ORDER BY with LIMIT 1}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (p:Person)
RETURN p.name AS name
ORDER BY p.name
LIMIT 1
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{ORDER BY with LIMIT 0 should not generate errors}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (p:Person)
RETURN p.name AS name
ORDER BY p.name
LIMIT 0
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{ORDER BY with negative parameter for LIMIT should not generate errors}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (p:Person)
RETURN p.name AS name
ORDER BY p.name
LIMIT $limit
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
\section{PatternComprehension}


\subsection{Pattern comprehension and ORDER BY}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (liker)
RETURN [p = (liker)--() | p] AS isNew
  ORDER BY liker.time
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Returning a pattern comprehension}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN [p = (n)-->() | p] AS ps
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Returning a pattern comprehension with label predicate}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n:A)
RETURN [p = (n)-->(:B) | p]
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Returning a pattern comprehension with bound nodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A), (b:B)
RETURN [p = (a)-[*]->(b) | p] AS paths
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Using a pattern comprehension in a WITH}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)-->(b)
WITH [p = (n)-->() | p] AS ps, count(b) AS c
RETURN ps, c
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Using a variable-length pattern comprehension in a WITH}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A), (b:B)
WITH [p = (a)-[*]->(b) | p] AS paths, count(a) AS c
RETURN paths, c
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Using pattern comprehension in RETURN}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n:A)
RETURN [p = (n)-[:HAS]->() | p] AS ps
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Aggregating on pattern comprehension}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n:A)
RETURN count([p = (n)-[:HAS]->() | p]) AS c
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Using pattern comprehension to test existence}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n:X)
RETURN n, size([(n)--() | 1]) > 0 AS b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Pattern comprehension inside list comprehension}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (n:X)-->(b)
RETURN n, [x IN nodes(p) | size([(x)-->(:Y) | 1])] AS list
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Get node degree via size of pattern comprehension}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:X)
RETURN size([(a)-->() | 1]) AS length
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Get node degree via size of pattern comprehension that specifies a relationship type}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:X)
RETURN size([(a)-[:T]->() | 1]) AS length
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Get node degree via size of pattern comprehension that specifies multiple relationship types}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:X)
RETURN size([(a)-[:T|OTHER]->() | 1]) AS length
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Introducing new node variable in pattern comprehension}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN [(n)-[:T]->(b) | b.prop] AS list
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Introducing new relationship variable in pattern comprehension}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN [(n)-[r:T]->() | r.prop] AS list
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
\section{RemoveAcceptance}

\section{ReturnAcceptanceTest}


\subsection{Allow addition}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a.id = 1337
RETURN a.version + 5
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Limit to two hits}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n
LIMIT 2
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\topp{2}{} \Big(\projection{\var{n}} \Big(\alldifferent{} \Big(\getvertices{n}{}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\topp{2}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\topp{2}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsection{Start the result from the second row}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n
ORDER BY n.name ASC
SKIP 2
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Start the result from the second row by param}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n
ORDER BY n.name ASC
SKIP $skipAmount
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Get rows in the middle}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n
ORDER BY n.name ASC
SKIP 2
LIMIT 2
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Get rows in the middle by param}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n
ORDER BY n.name ASC
SKIP $s
LIMIT $l
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Sort on aggregated function}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n.division, max(n.age)
  ORDER BY max(n.age)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Support sort and distinct}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
RETURN DISTINCT a
  ORDER BY a.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Support column renaming}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
RETURN a AS ColumnName
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{a}\assign \var{ColumnName}} \Big(\alldifferent{} \Big(\getvertices{a}{}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a}\assign \var{ColumnName}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a}\assign \var{ColumnName}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsection{Support ordering by a property after being distinct-ified}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-->(b)
RETURN DISTINCT b
  ORDER BY b.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Arithmetic precedence test}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN 12 / 4 * 3 - 2 * 4
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Arithmetic precedence with parenthesis test}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN 12 / 4 * (3 - 2 * 4)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Count star should count everything in scope}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
RETURN a, count(*)
ORDER BY count(*)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Absolute function}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN abs(-1)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Return collection size}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN size([1, 2, 3]) AS n
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
\section{ReturnAcceptance2}


\subsection{Accept valid Unicode literal}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN '\u01FF' AS a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{LIMIT 0 should return an empty result}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n
  LIMIT 0
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\topp{0}{} \Big(\projection{\var{n}} \Big(\alldifferent{} \Big(\getvertices{n}{}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\topp{0}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\topp{0}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsection{Ordering with aggregation}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n.name, count(*) AS foo
  ORDER BY n.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{DISTINCT on nullable values}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN DISTINCT n.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\duplicateelimination \Big(\projection{\var{n.name}} \Big(\alldifferent{} \Big(\getvertices{n}{}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\duplicateelimination$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\projection{\var{n.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\duplicateelimination$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\projection{\var{n.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsection{Return all variables}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH p = (a:Start)-->(b)
RETURN *
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`sqrt()` returning float values}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN sqrt(12.96)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Arithmetic expressions inside aggregation}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (me)-[r1:ATE]->()<-[r2:ATE]-(you)
WHERE me.name = 'Michael'
WITH me, count(DISTINCT r1) AS H1, count(DISTINCT r2) AS H2, you
MATCH (me)-[r1:ATE]->()<-[r2:ATE]-(you)
RETURN me, you, sum((1 - abs(r1.times / H1 - r2.times / H2)) * (r1.times + r2.times) / (H1 + H2)) AS sum
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Matching and disregarding output, then matching again}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-->()
WITH 1 AS x
MATCH ()-[r1]->()<--()
RETURN sum(r1.times)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Returning a list property}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{n}} \Big(\alldifferent{} \Big(\getvertices{n}{}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsection{Returning a projected map}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN {a: 1, b: 'foo'}
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Returning an expression}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
RETURN exists(a.id), a IS NOT NULL
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Concatenating and returning the size of literal lists}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN size([[], []] + [[]]) AS l
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Limiting amount of rows when there are fewer left than the LIMIT argument}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
RETURN a.count
  ORDER BY a.count
  SKIP 10
  LIMIT 10
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`substring()` with default second argument}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN substring('0123456789', 1) AS s
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Returning all variables with ordering}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN *
  ORDER BY n.id
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Using aliased DISTINCT expression in ORDER BY}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN DISTINCT n.id AS id
  ORDER BY id DESC
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\sort{\desc \var{id}} \Big(\duplicateelimination \Big(\projection{\var{n.id}\assign \var{id}} \Big(\alldifferent{} \Big(\getvertices{n}{}
\Big)
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\sort{\desc \var{id}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{id} \rangle$
			}
[
	{$\duplicateelimination$
			\\
			\footnotesize
			$\color{gray} \langle \var{id} \rangle$
			}
[
	{$\projection{\var{n.id}\assign \var{id}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{id} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\sort{\desc \var{id}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{id} \rangle$
			}
[
	{$\duplicateelimination$
			\\
			\footnotesize
			$\color{gray} \langle \var{id} \rangle$
			}
[
	{$\projection{\var{n.id}\assign \var{id}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{id} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Returned columns do not change from using ORDER BY}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN DISTINCT n
  ORDER BY n.id
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Arithmetic expressions should propagate null values}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN 1 + (2 - (3 * (4 / (5 ^ (6 % null))))) AS a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Indexing into nested literal lists}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN [[1]][0][0]
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Aliasing expressions}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
RETURN a.id AS a, a.id
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{a.id}\assign \var{a},~\var{a.id}} \Big(\alldifferent{} \Big(\getvertices{a}{}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a.id}\assign \var{a},~\var{a.id}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{id} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a.id}\assign \var{a},~\var{a.id}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{id} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsection{Projecting an arithmetic expression with aggregation}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
RETURN a, count(a) + 3
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Aggregating by a list property has a correct definition of equality}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WITH a.a AS a, count(*) AS count
RETURN count
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Reusing variable names}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (person:Person)<--(message)<-[like]-(:Person)
WITH like.creationDate AS likeTime, person AS person
  ORDER BY likeTime, message.id
WITH head(collect({likeTime: likeTime})) AS latestLike, person AS person
RETURN latestLike.likeTime AS likeTime
  ORDER BY likeTime
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Concatenating lists of same type}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN [1, 10, 100] + [4, 5] AS foo
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Appending lists of same type}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN [false, true] + false AS foo
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{DISTINCT inside aggregation should work with lists in maps}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN count(DISTINCT {foo: n.list}) AS count
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling DISTINCT with lists in maps}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WITH DISTINCT {foo: n.list} AS map
RETURN count(*)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{DISTINCT inside aggregation should work with nested lists in maps}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN count(DISTINCT {foo: [[n.list, n.list], [n.list, n.list]]}) AS count
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{DISTINCT inside aggregation should work with nested lists of maps in maps}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN count(DISTINCT {foo: [{bar: n.list}, {baz: {apa: n.list}}]}) AS count
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
\section{SemanticErrorAcceptance}


\subsection{Handling property access on the Any type}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH [{prop: 0}, 1] AS list
RETURN (list[0]).prop
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Bad arguments for `range()`}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN range(2, 8, 0)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
\section{SetAcceptance}

\section{SkipLimitAcceptanceTest}


\subsection{SKIP with an expression that does not depend on variables}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WITH n SKIP toInteger(rand()*9)
WITH count(*) AS count
RETURN count > 0 AS nonEmpty
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{LIMIT with an expression that does not depend on variables}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WITH n LIMIT toInteger(ceil(1.7))
RETURN count(*) AS count
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
\section{StartingPointAcceptance}


\subsection{Find all nodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
RETURN n
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{n}} \Big(\alldifferent{} \Big(\getvertices{n}{}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsection{Find labelled nodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n:Animal)
RETURN n
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{n}} \Big(\alldifferent{} \Big(\getvertices{n}{Animal}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{Animal}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{Animal}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsection{Find nodes by property}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WHERE n.prop = 2
RETURN n
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{n}} \Big(\selection{\var{n.prop} = \literal{2}} \Big(\alldifferent{} \Big(\getvertices{n}{}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\selection{\var{n.prop} = \literal{2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{n}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\selection{\var{n.prop} = \literal{2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			}
[
	{$\getvertices{n}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{n} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}
\section{StartsWithAcceptance}


\subsection{Finding exact matches}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a.name STARTS WITH 'ABCDEF'
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Finding beginning of string}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a.name STARTS WITH 'ABC'
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Finding end of string 1}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a.name ENDS WITH 'DEF'
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Finding end of string 2}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a.name ENDS WITH 'AB'
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Finding middle of string}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a.name STARTS WITH 'a'
  AND a.name ENDS WITH 'f'
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Finding the empty string}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a.name STARTS WITH ''
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Finding when the middle is known}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a.name CONTAINS 'CD'
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Finding strings starting with whitespace}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a.name STARTS WITH ' '
RETURN a.name AS name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Finding strings starting with newline}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a.name STARTS WITH '\n'
RETURN a.name AS name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Finding strings ending with newline}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a.name ENDS WITH '\n'
RETURN a.name AS name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Finding strings ending with whitespace}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a.name ENDS WITH ' '
RETURN a.name AS name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Finding strings containing whitespace}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a.name CONTAINS ' '
RETURN a.name AS name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Finding strings containing newline}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a.name CONTAINS '\n'
RETURN a.name AS name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{No string starts with null}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a.name STARTS WITH null
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{No string does not start with null}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE NOT a.name STARTS WITH null
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{No string ends with null}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a.name ENDS WITH null
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{No string does not end with null}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE NOT a.name ENDS WITH null
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{No string contains null}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a.name CONTAINS null
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{No string does not contain null}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE NOT a.name CONTAINS null
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Combining string operators}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE a.name STARTS WITH 'A'
  AND a.name CONTAINS 'C'
  AND a.name ENDS WITH 'EF'
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{NOT with CONTAINS}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WHERE NOT a.name CONTAINS 'b'
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling non-string operands for STARTS WITH}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH [1, 3.14, true, [], {}, null] AS operands
UNWIND operands AS op1
UNWIND operands AS op2
WITH op1 STARTS WITH op2 AS v
RETURN v, count(*)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling non-string operands for CONTAINS}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH [1, 3.14, true, [], {}, null] AS operands
UNWIND operands AS op1
UNWIND operands AS op2
WITH op1 STARTS WITH op2 AS v
RETURN v, count(*)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling non-string operands for ENDS WITH}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH [1, 3.14, true, [], {}, null] AS operands
UNWIND operands AS op1
UNWIND operands AS op2
WITH op1 STARTS WITH op2 AS v
RETURN v, count(*)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
\section{SyntaxErrorAcceptance}

\section{TernaryLogicAcceptanceTest}


\subsection{The inverse of a null is a null}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN NOT null AS value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{A literal null IS null}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN null IS NULL AS value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{A literal null is not IS NOT null}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN null IS NOT NULL AS value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{It is unknown - i.e. null - if a null is equal to a null}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN null = null AS value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{It is unknown - i.e. null - if a null is not equal to a null}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN null <> null AS value
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
\section{TriadicSelection}


\subsection{Handling triadic friend of a friend}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-[:KNOWS]->(b)-->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling triadic friend of a friend that is not a friend}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-[:KNOWS]->(b)-->(c)
OPTIONAL MATCH (a)-[r:KNOWS]->(c)
WITH c WHERE r IS NULL
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling triadic friend of a friend that is not a friend with different relationship type}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-[:KNOWS]->(b)-->(c)
OPTIONAL MATCH (a)-[r:FOLLOWS]->(c)
WITH c WHERE r IS NULL
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling triadic friend of a friend that is not a friend with superset of relationship type}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-[:KNOWS]->(b)-->(c)
OPTIONAL MATCH (a)-[r]->(c)
WITH c WHERE r IS NULL
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling triadic friend of a friend that is not a friend with implicit subset of relationship type}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-->(b)-->(c)
OPTIONAL MATCH (a)-[r:KNOWS]->(c)
WITH c WHERE r IS NULL
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling triadic friend of a friend that is not a friend with explicit subset of relationship type}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-[:KNOWS|FOLLOWS]->(b)-->(c)
OPTIONAL MATCH (a)-[r:KNOWS]->(c)
WITH c WHERE r IS NULL
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling triadic friend of a friend that is not a friend with same labels}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-[:KNOWS]->(b:X)-->(c:X)
OPTIONAL MATCH (a)-[r:KNOWS]->(c)
WITH c WHERE r IS NULL
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling triadic friend of a friend that is not a friend with different labels}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-[:KNOWS]->(b:X)-->(c:Y)
OPTIONAL MATCH (a)-[r:KNOWS]->(c)
WITH c WHERE r IS NULL
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling triadic friend of a friend that is not a friend with implicit subset of labels}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-[:KNOWS]->(b)-->(c:X)
OPTIONAL MATCH (a)-[r:KNOWS]->(c)
WITH c WHERE r IS NULL
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling triadic friend of a friend that is not a friend with implicit superset of labels}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-[:KNOWS]->(b:X)-->(c)
OPTIONAL MATCH (a)-[r:KNOWS]->(c)
WITH c WHERE r IS NULL
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling triadic friend of a friend that is a friend}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-[:KNOWS]->(b)-->(c)
OPTIONAL MATCH (a)-[r:KNOWS]->(c)
WITH c WHERE r IS NOT NULL
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling triadic friend of a friend that is a friend with different relationship type}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-[:KNOWS]->(b)-->(c)
OPTIONAL MATCH (a)-[r:FOLLOWS]->(c)
WITH c WHERE r IS NOT NULL
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling triadic friend of a friend that is a friend with superset of relationship type}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-[:KNOWS]->(b)-->(c)
OPTIONAL MATCH (a)-[r]->(c)
WITH c WHERE r IS NOT NULL
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling triadic friend of a friend that is a friend with implicit subset of relationship type}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-->(b)-->(c)
OPTIONAL MATCH (a)-[r:KNOWS]->(c)
WITH c WHERE r IS NOT NULL
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling triadic friend of a friend that is a friend with explicit subset of relationship type}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-[:KNOWS|FOLLOWS]->(b)-->(c)
OPTIONAL MATCH (a)-[r:KNOWS]->(c)
WITH c WHERE r IS NOT NULL
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling triadic friend of a friend that is a friend with same labels}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-[:KNOWS]->(b:X)-->(c:X)
OPTIONAL MATCH (a)-[r:KNOWS]->(c)
WITH c WHERE r IS NOT NULL
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling triadic friend of a friend that is a friend with different labels}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-[:KNOWS]->(b:X)-->(c:Y)
OPTIONAL MATCH (a)-[r:KNOWS]->(c)
WITH c WHERE r IS NOT NULL
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling triadic friend of a friend that is a friend with implicit subset of labels}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-[:KNOWS]->(b)-->(c:X)
OPTIONAL MATCH (a)-[r:KNOWS]->(c)
WITH c WHERE r IS NOT NULL
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling triadic friend of a friend that is a friend with implicit superset of labels}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-[:KNOWS]->(b:X)-->(c)
OPTIONAL MATCH (a)-[r:KNOWS]->(c)
WITH c WHERE r IS NOT NULL
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
\section{TypeConversionFunctions}


\subsection{`toBoolean()` on valid literal string}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN toBoolean('true') AS b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`toBoolean()` on booleans}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND [true, false] AS b
RETURN toBoolean(b) AS b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`toBoolean()` on variables with valid string values}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND ['true', 'false'] AS s
RETURN toBoolean(s) AS b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`toBoolean()` on invalid strings}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND [null, '', ' tru ', 'f alse'] AS things
RETURN toBoolean(things) AS b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`toInteger()`}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (p:Person { age: '42' })
WITH *
MATCH (n)
RETURN toInteger(n.age) AS age
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`toInteger()` on float}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH 82.9 AS weight
RETURN toInteger(weight)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`toInteger()` returning null on non-numerical string}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH 'foo' AS foo_string, '' AS empty_string
RETURN toInteger(foo_string) AS foo, toInteger(empty_string) AS empty
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`toInteger()` handling mixed number types}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH [2, 2.9] AS numbers
RETURN [n IN numbers | toInteger(n)] AS int_numbers
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`toInteger()` handling Any type}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH [2, 2.9, '1.7'] AS things
RETURN [n IN things | toInteger(n)] AS int_numbers
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`toInteger()` on a list of strings}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH ['2', '2.9', 'foo'] AS numbers
RETURN [n IN numbers | toInteger(n)] AS int_numbers
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`toInteger()` on a complex-typed expression}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN toInteger(1 - {param}) AS result
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`toFloat()`}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (m:Movie { rating: 4 })
WITH *
MATCH (n)
RETURN toFloat(n.rating) AS float
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`toFloat()` on mixed number types}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH [3.4, 3] AS numbers
RETURN [n IN numbers | toFloat(n)] AS float_numbers
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`toFloat()` returning null on non-numerical string}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH 'foo' AS foo_string, '' AS empty_string
RETURN toFloat(foo_string) AS foo, toFloat(empty_string) AS empty
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`toFloat()` handling Any type}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH [3.4, 3, '5'] AS numbers
RETURN [n IN numbers | toFloat(n)] AS float_numbers
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`toFloat()` on a list of strings}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH ['1', '2', 'foo'] AS numbers
RETURN [n IN numbers | toFloat(n)] AS float_numbers
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`toString()`}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (m:Movie { rating: 4 })
WITH *
MATCH (n)
RETURN toString(n.rating)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`toString()` handling boolean properties}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (m:Movie)
RETURN toString(m.watched)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`toString()` handling inlined boolean}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN toString(1 < 0) AS bool
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`toString()` handling boolean literal}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN toString(true) AS bool
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`toString()` should work on Any type}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN [x IN [1, 2.3, true, 'apa'] | toString(x) ] AS list
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`toString()` on a list of integers}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH [1, 2, 3] AS numbers
RETURN [n IN numbers | toString(n)] AS string_numbers
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`toString()` should accept potentially correct types 1}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND ['male', 'female', null] AS gen
RETURN coalesce(toString(gen), 'x') AS result
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{`toString()` should accept potentially correct types 2}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND ['male', 'female', null] AS gen
RETURN toString(coalesce(gen, 'x')) AS result
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
\section{UnionAcceptance}


\subsection{Should be able to create text output from union queries}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
RETURN a AS a
UNION
MATCH (b:B)
RETURN b AS a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{a}\assign \var{a}} \Big(\alldifferent{} \Big(\getvertices{a}{A}
\Big)
\Big)
 \union \projection{\var{b}\assign \var{a}} \Big(\alldifferent{} \Big(\getvertices{b}{B}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\union$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\projection{\var{a}\assign \var{a}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\projection{\var{b}\assign \var{a}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			}
[
	{$\getvertices{b}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\union$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\projection{\var{a}\assign \var{a}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\projection{\var{b}\assign \var{a}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			}
[
	{$\getvertices{b}{B}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsection{Two elements, both unique, not distinct}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN 1 AS x
UNION ALL
RETURN 2 AS x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Two elements, both unique, distinct}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN 1 AS x
UNION
RETURN 2 AS x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Three elements, two unique, distinct}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN 2 AS x
UNION
RETURN 1 AS x
UNION
RETURN 2 AS x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Three elements, two unique, not distinct}

\subsubsection*{Query specification}

\begin{lstlisting}
RETURN 2 AS x
UNION ALL
RETURN 1 AS x
UNION ALL
RETURN 2 AS x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
\section{UnwindAcceptance}


\subsection{Unwinding a list}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND [1, 2, 3] AS x
RETURN x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Unwinding a range}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND range(1, 3) AS x
RETURN x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Unwinding a concatenation of lists}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH [1, 2, 3] AS first, [4, 5, 6] AS second
UNWIND (first + second) AS x
RETURN x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Unwinding a collected unwound expression}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND RANGE(1, 2) AS row
WITH collect(row) AS rows
UNWIND rows AS x
RETURN x
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Unwinding a collected expression}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (row)
WITH collect(row) AS rows
UNWIND rows AS node
RETURN node.id
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Double unwinding a list of lists}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH [[1, 2, 3], [4, 5, 6]] AS lol
UNWIND lol AS x
UNWIND x AS y
RETURN y
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Unwinding the empty list}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND [] AS empty
RETURN empty
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Unwinding null}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND null AS nil
RETURN nil
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Unwinding list with duplicates}

\subsubsection*{Query specification}

\begin{lstlisting}
UNWIND [1, 1, 2, 2, 3, 3, 4, 4, 5, 5] AS duplicate
RETURN duplicate
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Unwind does not prune context}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH [1, 2, 3] AS list
UNWIND list AS x
RETURN *
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Unwind does not remove variables from scope}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:S)-[:X]->(b1)
WITH a, collect(b1) AS bees
UNWIND bees AS b2
MATCH (a)-[:Y]->(b2)
RETURN a, b2
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{a},~\var{b2}} \Big(\alldifferent{} \Big(\expandout{a}{b1}{}{\_e269}{X}{1}{1} \Big(\getvertices{a}{S}
\Big)
\Big)
 \join \alldifferent{} \Big(\expandout{a}{b2}{}{\_e270}{Y}{1}{1} \Big(\getvertices{a}{S}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b2} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e269, b1, \_e270, b2} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e269, b1} \rangle$
			}
[
	{$\expandout{a}{b1}{}{\_e269}{X}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e269, b1} \rangle$
			}
[
	{$\getvertices{a}{S}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e270, b2} \rangle$
			}
[
	{$\expandout{a}{b2}{}{\_e270}{Y}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e270, b2} \rangle$
			}
[
	{$\getvertices{a}{S}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b2}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b2} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e269, b1, \_e270, b2} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e269, b1} \rangle$
			}
[
	{$\expandout{a}{b1}{}{\_e269}{X}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e269, b1} \rangle$
			}
[
	{$\getvertices{a}{S}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e270, b2} \rangle$
			}
[
	{$\expandout{a}{b2}{}{\_e270}{Y}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e270, b2} \rangle$
			}
[
	{$\getvertices{a}{S}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Multiple unwinds after each other}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH [1, 2] AS xs, [3, 4] AS ys, [5, 6] AS zs
UNWIND xs AS x
UNWIND ys AS y
UNWIND zs AS z
RETURN *
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
\section{VarLengthAcceptance}


\subsection{Handling unbounded variable length match}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling explicitly unbounded variable length match}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*..]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling single bounded variable length match 1}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*0]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}
\Big)
 \join \alldifferent{} \Big(\expandout{a}{c}{}{\_e273}{LIKES}{0}{} \Big(\getvertices{a}{A}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e273, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e273, c} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e273}{LIKES}{0}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e273, c} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e273, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e273, c} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e273}{LIKES}{0}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e273, c} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Handling single bounded variable length match 2}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*1]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}
\Big)
 \join \alldifferent{} \Big(\expandout{a}{c}{}{\_e274}{LIKES}{1}{} \Big(\getvertices{a}{A}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e274, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e274, c} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e274}{LIKES}{1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e274, c} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e274, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e274, c} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e274}{LIKES}{1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e274, c} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Handling single bounded variable length match 3}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*2]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}
\Big)
 \join \alldifferent{} \Big(\expandout{a}{c}{}{\_e275}{LIKES}{2}{} \Big(\getvertices{a}{A}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e275, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e275, c} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e275}{LIKES}{2}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e275, c} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e275, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e275, c} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e275}{LIKES}{2}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e275, c} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Handling upper and lower bounded variable length match 1}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*0..2]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}
\Big)
 \join \alldifferent{} \Big(\expandout{a}{c}{}{\_e276}{LIKES}{0}{2} \Big(\getvertices{a}{A}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e276, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e276, c} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e276}{LIKES}{0}{2}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e276, c} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e276, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e276, c} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e276}{LIKES}{0}{2}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e276, c} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Handling upper and lower bounded variable length match 2}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*1..2]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}
\Big)
 \join \alldifferent{} \Big(\expandout{a}{c}{}{\_e277}{LIKES}{1}{2} \Big(\getvertices{a}{A}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e277, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e277, c} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e277}{LIKES}{1}{2}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e277, c} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e277, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e277, c} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e277}{LIKES}{1}{2}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e277, c} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Handling symmetrically bounded variable length match, bounds are zero}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*0..0]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}
\Big)
 \join \alldifferent{} \Big(\expandout{a}{c}{}{\_e278}{LIKES}{0}{0} \Big(\getvertices{a}{A}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e278, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e278, c} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e278}{LIKES}{0}{0}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e278, c} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e278, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e278, c} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e278}{LIKES}{0}{0}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e278, c} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Handling symmetrically bounded variable length match, bounds are one}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*1..1]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}
\Big)
 \join \alldifferent{} \Big(\expandout{a}{c}{}{\_e279}{LIKES}{1}{1} \Big(\getvertices{a}{A}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e279, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e279, c} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e279}{LIKES}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e279, c} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e279, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e279, c} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e279}{LIKES}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e279, c} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Handling symmetrically bounded variable length match, bounds are two}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*2..2]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}
\Big)
 \join \alldifferent{} \Big(\expandout{a}{c}{}{\_e280}{LIKES}{2}{2} \Big(\getvertices{a}{A}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e280, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e280, c} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e280}{LIKES}{2}{2}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e280, c} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e280, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e280, c} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e280}{LIKES}{2}{2}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e280, c} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Handling upper and lower bounded variable length match, empty interval 1}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*2..1]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}
\Big)
 \join \alldifferent{} \Big(\expandout{a}{c}{}{\_e281}{LIKES}{2}{1} \Big(\getvertices{a}{A}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e281, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e281, c} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e281}{LIKES}{2}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e281, c} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e281, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e281, c} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e281}{LIKES}{2}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e281, c} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Handling upper and lower bounded variable length match, empty interval 2}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*1..0]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}
\Big)
 \join \alldifferent{} \Big(\expandout{a}{c}{}{\_e282}{LIKES}{1}{0} \Big(\getvertices{a}{A}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e282, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e282, c} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e282}{LIKES}{1}{0}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e282, c} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e282, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e282, c} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e282}{LIKES}{1}{0}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e282, c} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Handling upper bounded variable length match, empty interval}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*..0]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling upper bounded variable length match 1}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*..1]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling upper bounded variable length match 2}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*..2]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handling lower bounded variable length match 1}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*0..]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}
\Big)
 \join \alldifferent{} \Big(\expandout{a}{c}{}{\_e286}{LIKES}{0}{} \Big(\getvertices{a}{A}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e286, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e286, c} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e286}{LIKES}{0}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e286, c} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e286, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e286, c} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e286}{LIKES}{0}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e286, c} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Handling lower bounded variable length match 2}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*1..]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}
\Big)
 \join \alldifferent{} \Big(\expandout{a}{c}{}{\_e287}{LIKES}{1}{} \Big(\getvertices{a}{A}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e287, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e287, c} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e287}{LIKES}{1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e287, c} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e287, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e287, c} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e287}{LIKES}{1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e287, c} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Handling lower bounded variable length match 3}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*2..]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}
\Big)
 \join \alldifferent{} \Big(\expandout{a}{c}{}{\_e288}{LIKES}{2}{} \Big(\getvertices{a}{A}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e288, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e288, c} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e288}{LIKES}{2}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e288, c} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e288, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e288, c} \rangle$
			}
[
	{$\expandout{a}{c}{}{\_e288}{LIKES}{2}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e288, c} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Handling a variable length relationship and a standard relationship in chain, zero length 1}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*0]->()-[:LIKES]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}
\Big)
 \join \alldifferent{} \Big(\expandout{\_e289}{c}{}{\_e291}{LIKES}{1}{1} \Big(\expandout{a}{\_e289}{}{\_e290}{LIKES}{0}{} \Big(\getvertices{a}{A}
\Big)
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e290, \_e289, \_e291, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e290, \_e289, \_e291, c} \rangle$
			}
[
	{$\expandout{\_e289}{c}{}{\_e291}{LIKES}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e290, \_e289, \_e291, c} \rangle$
			}
[
	{$\expandout{a}{\_e289}{}{\_e290}{LIKES}{0}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e290, \_e289} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e290, \_e289, \_e291, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e290, \_e289, \_e291, c} \rangle$
			}
[
	{$\expandout{\_e289}{c}{}{\_e291}{LIKES}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e290, \_e289, \_e291, c} \rangle$
			}
[
	{$\expandout{a}{\_e289}{}{\_e290}{LIKES}{0}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e290, \_e289} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
}

\subsection{Handling a variable length relationship and a standard relationship in chain, zero length 2}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES]->()-[:LIKES*0]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}
\Big)
 \join \alldifferent{} \Big(\expandout{\_e292}{c}{}{\_e294}{LIKES}{0}{} \Big(\expandout{a}{\_e292}{}{\_e293}{LIKES}{1}{1} \Big(\getvertices{a}{A}
\Big)
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e293, \_e292, \_e294, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e293, \_e292, \_e294, c} \rangle$
			}
[
	{$\expandout{\_e292}{c}{}{\_e294}{LIKES}{0}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e293, \_e292, \_e294, c} \rangle$
			}
[
	{$\expandout{a}{\_e292}{}{\_e293}{LIKES}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e293, \_e292} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e293, \_e292, \_e294, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e293, \_e292, \_e294, c} \rangle$
			}
[
	{$\expandout{\_e292}{c}{}{\_e294}{LIKES}{0}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e293, \_e292, \_e294, c} \rangle$
			}
[
	{$\expandout{a}{\_e292}{}{\_e293}{LIKES}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e293, \_e292} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
}

\subsection{Handling a variable length relationship and a standard relationship in chain, single length 1}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*1]->()-[:LIKES]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}
\Big)
 \join \alldifferent{} \Big(\expandout{\_e295}{c}{}{\_e297}{LIKES}{1}{1} \Big(\expandout{a}{\_e295}{}{\_e296}{LIKES}{1}{} \Big(\getvertices{a}{A}
\Big)
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e296, \_e295, \_e297, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e296, \_e295, \_e297, c} \rangle$
			}
[
	{$\expandout{\_e295}{c}{}{\_e297}{LIKES}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e296, \_e295, \_e297, c} \rangle$
			}
[
	{$\expandout{a}{\_e295}{}{\_e296}{LIKES}{1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e296, \_e295} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e296, \_e295, \_e297, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e296, \_e295, \_e297, c} \rangle$
			}
[
	{$\expandout{\_e295}{c}{}{\_e297}{LIKES}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e296, \_e295, \_e297, c} \rangle$
			}
[
	{$\expandout{a}{\_e295}{}{\_e296}{LIKES}{1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e296, \_e295} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
}

\subsection{Handling a variable length relationship and a standard relationship in chain, single length 2}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES]->()-[:LIKES*1]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}
\Big)
 \join \alldifferent{} \Big(\expandout{\_e298}{c}{}{\_e300}{LIKES}{1}{} \Big(\expandout{a}{\_e298}{}{\_e299}{LIKES}{1}{1} \Big(\getvertices{a}{A}
\Big)
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e299, \_e298, \_e300, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e299, \_e298, \_e300, c} \rangle$
			}
[
	{$\expandout{\_e298}{c}{}{\_e300}{LIKES}{1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e299, \_e298, \_e300, c} \rangle$
			}
[
	{$\expandout{a}{\_e298}{}{\_e299}{LIKES}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e299, \_e298} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e299, \_e298, \_e300, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e299, \_e298, \_e300, c} \rangle$
			}
[
	{$\expandout{\_e298}{c}{}{\_e300}{LIKES}{1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e299, \_e298, \_e300, c} \rangle$
			}
[
	{$\expandout{a}{\_e298}{}{\_e299}{LIKES}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e299, \_e298} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
}

\subsection{Handling a variable length relationship and a standard relationship in chain, longer 1}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES*2]->()-[:LIKES]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}
\Big)
 \join \alldifferent{} \Big(\expandout{\_e301}{c}{}{\_e303}{LIKES}{1}{1} \Big(\expandout{a}{\_e301}{}{\_e302}{LIKES}{2}{} \Big(\getvertices{a}{A}
\Big)
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e302, \_e301, \_e303, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e302, \_e301, \_e303, c} \rangle$
			}
[
	{$\expandout{\_e301}{c}{}{\_e303}{LIKES}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e302, \_e301, \_e303, c} \rangle$
			}
[
	{$\expandout{a}{\_e301}{}{\_e302}{LIKES}{2}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e302, \_e301} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e302, \_e301, \_e303, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e302, \_e301, \_e303, c} \rangle$
			}
[
	{$\expandout{\_e301}{c}{}{\_e303}{LIKES}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e302, \_e301, \_e303, c} \rangle$
			}
[
	{$\expandout{a}{\_e301}{}{\_e302}{LIKES}{2}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e302, \_e301} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
}

\subsection{Handling a variable length relationship and a standard relationship in chain, longer 2}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES]->()-[:LIKES*2]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}
\Big)
 \join \alldifferent{} \Big(\expandout{\_e304}{c}{}{\_e306}{LIKES}{2}{} \Big(\expandout{a}{\_e304}{}{\_e305}{LIKES}{1}{1} \Big(\getvertices{a}{A}
\Big)
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e305, \_e304, \_e306, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e305, \_e304, \_e306, c} \rangle$
			}
[
	{$\expandout{\_e304}{c}{}{\_e306}{LIKES}{2}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e305, \_e304, \_e306, c} \rangle$
			}
[
	{$\expandout{a}{\_e304}{}{\_e305}{LIKES}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e305, \_e304} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e305, \_e304, \_e306, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e305, \_e304, \_e306, c} \rangle$
			}
[
	{$\expandout{\_e304}{c}{}{\_e306}{LIKES}{2}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e305, \_e304, \_e306, c} \rangle$
			}
[
	{$\expandout{a}{\_e304}{}{\_e305}{LIKES}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e305, \_e304} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
}

\subsection{Handling a variable length relationship and a standard relationship in chain, longer 3}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES]->()-[:LIKES*3]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}
\Big)
 \join \alldifferent{} \Big(\expandout{\_e307}{c}{}{\_e309}{LIKES}{3}{} \Big(\expandout{a}{\_e307}{}{\_e308}{LIKES}{1}{1} \Big(\getvertices{a}{A}
\Big)
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e308, \_e307, \_e309, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e308, \_e307, \_e309, c} \rangle$
			}
[
	{$\expandout{\_e307}{c}{}{\_e309}{LIKES}{3}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e308, \_e307, \_e309, c} \rangle$
			}
[
	{$\expandout{a}{\_e307}{}{\_e308}{LIKES}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e308, \_e307} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e308, \_e307, \_e309, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e308, \_e307, \_e309, c} \rangle$
			}
[
	{$\expandout{\_e307}{c}{}{\_e309}{LIKES}{3}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e308, \_e307, \_e309, c} \rangle$
			}
[
	{$\expandout{a}{\_e307}{}{\_e308}{LIKES}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e308, \_e307} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
}

\subsection{Handling mixed relationship patterns and directions 1}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)<-[:LIKES]-()-[:LIKES*3]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}
\Big)
 \join \alldifferent{} \Big(\expandout{\_e310}{c}{}{\_e312}{LIKES}{3}{} \Big(\expandin{a}{\_e310}{}{\_e311}{LIKES}{1}{1} \Big(\getvertices{a}{A}
\Big)
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e311, \_e310, \_e312, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e311, \_e310, \_e312, c} \rangle$
			}
[
	{$\expandout{\_e310}{c}{}{\_e312}{LIKES}{3}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e311, \_e310, \_e312, c} \rangle$
			}
[
	{$\expandin{a}{\_e310}{}{\_e311}{LIKES}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e311, \_e310} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e311, \_e310, \_e312, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e311, \_e310, \_e312, c} \rangle$
			}
[
	{$\expandout{\_e310}{c}{}{\_e312}{LIKES}{3}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e311, \_e310, \_e312, c} \rangle$
			}
[
	{$\expandin{a}{\_e310}{}{\_e311}{LIKES}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e311, \_e310} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
}

\subsection{Handling mixed relationship patterns and directions 2}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (a)-[:LIKES]->()<-[:LIKES*3]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}
\Big)
 \join \alldifferent{} \Big(\expandboth{\_e313}{c}{}{\_e315}{LIKES}{3}{} \Big(\expandout{a}{\_e313}{}{\_e314}{LIKES}{1}{1} \Big(\getvertices{a}{A}
\Big)
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e314, \_e313, \_e315, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e314, \_e313, \_e315, c} \rangle$
			}
[
	{$\expandboth{\_e313}{c}{}{\_e315}{LIKES}{3}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e314, \_e313, \_e315, c} \rangle$
			}
[
	{$\expandout{a}{\_e313}{}{\_e314}{LIKES}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e314, \_e313} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e314, \_e313, \_e315, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e314, \_e313, \_e315, c} \rangle$
			}
[
	{$\expandboth{\_e313}{c}{}{\_e315}{LIKES}{3}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e314, \_e313, \_e315, c} \rangle$
			}
[
	{$\expandout{a}{\_e313}{}{\_e314}{LIKES}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, \_e314, \_e313} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
;
\end{forest}
}

\subsection{Handling mixed relationship patterns 1}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (p)-[:LIKES*1]->()-[:LIKES]->()-[r:LIKES*2]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}
\Big)
 \join \alldifferent{} \Big(\expandout{\_e318}{c}{}{r}{LIKES}{2}{} \Big(\expandout{\_e316}{\_e318}{}{\_e319}{LIKES}{1}{1} \Big(\expandout{p}{\_e316}{}{\_e317}{LIKES}{1}{} \Big(\getvertices{p}{}
\Big)
\Big)
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, p, \_e317, \_e316, \_e319, \_e318, r, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{p, \_e317, \_e316, \_e319, \_e318, r, c} \rangle$
			}
[
	{$\expandout{\_e318}{c}{}{r}{LIKES}{2}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{p, \_e317, \_e316, \_e319, \_e318, r, c} \rangle$
			}
[
	{$\expandout{\_e316}{\_e318}{}{\_e319}{LIKES}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{p, \_e317, \_e316, \_e319, \_e318} \rangle$
			}
[
	{$\expandout{p}{\_e316}{}{\_e317}{LIKES}{1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{p, \_e317, \_e316} \rangle$
			}
[
	{$\getvertices{p}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{p} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, p, \_e317, \_e316, \_e319, \_e318, r, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{p, \_e317, \_e316, \_e319, \_e318, r, c} \rangle$
			}
[
	{$\expandout{\_e318}{c}{}{r}{LIKES}{2}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{p, \_e317, \_e316, \_e319, \_e318, r, c} \rangle$
			}
[
	{$\expandout{\_e316}{\_e318}{}{\_e319}{LIKES}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{p, \_e317, \_e316, \_e319, \_e318} \rangle$
			}
[
	{$\expandout{p}{\_e316}{}{\_e317}{LIKES}{1}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{p, \_e317, \_e316} \rangle$
			}
[
	{$\getvertices{p}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{p} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
]
;
\end{forest}
}

\subsection{Handling mixed relationship patterns 2}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
MATCH (p)-[:LIKES]->()-[:LIKES*2]->()-[r:LIKES]->(c)
RETURN c.name
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{c.name}} \Big(\alldifferent{} \Big(\getvertices{a}{A}
\Big)
 \join \alldifferent{} \Big(\expandout{\_e322}{c}{}{r}{LIKES}{1}{1} \Big(\expandout{\_e320}{\_e322}{}{\_e323}{LIKES}{2}{} \Big(\expandout{p}{\_e320}{}{\_e321}{LIKES}{1}{1} \Big(\getvertices{p}{}
\Big)
\Big)
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, p, \_e321, \_e320, \_e323, \_e322, r, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{p, \_e321, \_e320, \_e323, \_e322, r, c} \rangle$
			}
[
	{$\expandout{\_e322}{c}{}{r}{LIKES}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{p, \_e321, \_e320, \_e323, \_e322, r, c} \rangle$
			}
[
	{$\expandout{\_e320}{\_e322}{}{\_e323}{LIKES}{2}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{p, \_e321, \_e320, \_e323, \_e322} \rangle$
			}
[
	{$\expandout{p}{\_e320}{}{\_e321}{LIKES}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{p, \_e321, \_e320} \rangle$
			}
[
	{$\getvertices{p}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{p} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{c.name}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{name} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, p, \_e321, \_e320, \_e323, \_e322, r, c} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{p, \_e321, \_e320, \_e323, \_e322, r, c} \rangle$
			}
[
	{$\expandout{\_e322}{c}{}{r}{LIKES}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{p, \_e321, \_e320, \_e323, \_e322, r, c} \rangle$
			}
[
	{$\expandout{\_e320}{\_e322}{}{\_e323}{LIKES}{2}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{p, \_e321, \_e320, \_e323, \_e322} \rangle$
			}
[
	{$\expandout{p}{\_e320}{}{\_e321}{LIKES}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{p, \_e321, \_e320} \rangle$
			}
[
	{$\getvertices{p}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{p} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
]
]
;
\end{forest}
}
\section{VarLengthAcceptance2}


\subsection{Handling relationships that are already bound in variable length paths}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH ()-[r:EDGE]-()
MATCH p = (n)-[*0..1]-()-[r]-()-[*0..1]-(m)
RETURN count(p) AS c
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
\section{WhereAcceptance}


\subsection{NOT and false}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WHERE NOT(n.name = 'apa' AND false)
RETURN n
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
\section{WithAcceptance}


\subsection{Passing on pattern nodes}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
WITH a
MATCH (a)-->(b)
RETURN *
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{ORDER BY and LIMIT can be used}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)
WITH a
ORDER BY a.name
LIMIT 1
MATCH (a)-->(b)
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{No dependencies between the query parts}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WITH a
MATCH (b)
RETURN a, b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{a},~\var{b}} \Big(\alldifferent{} \Big(\getvertices{a}{}
\Big)
 \join \alldifferent{} \Big(\getvertices{b}{}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			}
[
	{$\getvertices{b}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, b} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			}
[
	{$\getvertices{b}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{b} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
;
\end{forest}
}

\subsection{Aliasing}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:Begin)
WITH a.prop AS property
MATCH (b:End)
WHERE property = b.prop
RETURN b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handle dependencies across WITH}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:Begin)
WITH a.prop AS property
  LIMIT 1
MATCH (b)
WHERE b.id = property
RETURN b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Handle dependencies across WITH with SKIP}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WITH a.prop AS property, a.key AS idToUse
  ORDER BY property
  SKIP 1
MATCH (b)
WHERE b.id = idToUse
RETURN DISTINCT b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{WHERE after WITH should filter results}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WITH a
WHERE a.name = 'B'
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{a}} \Big(\alldifferent{} \Big(\getvertices{a}{}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsection{WHERE after WITH can filter on top of an aggregation}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)-->()
WITH a, count(*) AS relCount
WHERE relCount > 1
RETURN a
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{ORDER BY on an aggregating key}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WITH a.bar AS bars, count(*) AS relCount
ORDER BY a.bar
RETURN *
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{} \Big(\alldifferent{} \Big(\getvertices{a}{}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsection{ORDER BY a DISTINCT column}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WITH DISTINCT a.bar AS bars
ORDER BY a.bar
RETURN *
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{} \Big(\alldifferent{} \Big(\getvertices{a}{}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsection{WHERE on a DISTINCT column}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a)
WITH DISTINCT a.bar AS bars
WHERE a.bar = 'B'
RETURN *
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{} \Big(\alldifferent{} \Big(\getvertices{a}{}
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			}
[
	{$\getvertices{a}{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
;
\end{forest}
}

\subsection{A simple pattern with one bound endpoint}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (a:A)-[r:REL]->(b:B)
WITH a AS b, b AS tmp, r AS r
WITH b AS a, r
LIMIT 1
MATCH (a)-[r]->(b)
RETURN a, r, b
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\projection{\var{a},~\var{r},~\var{b}} \Big(\alldifferent{} \Big(\expandout{a}{b}{B}{r}{REL}{1}{1} \Big(\getvertices{a}{A}
\Big)
\Big)
 \join \alldifferent{} \Big(\expandout{a}{b}{B}{r}{REL}{1}{1} \Big(\getvertices{a}{A}
\Big)
\Big)
\Big)
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{r},~\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b} \rangle$
			}
[
	{$\expandout{a}{b}{B}{r}{REL}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b} \rangle$
			}
[
	{$\expandout{a}{b}{B}{r}{REL}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
\begin{forest} for tree={align=center}
[
	{$\projection{\var{a},~\var{r},~\var{b}}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b} \rangle$
			}
[
	{$\join$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b} \rangle$
			}
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b} \rangle$
			}
[
	{$\expandout{a}{b}{B}{r}{REL}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
[
	{$\alldifferent{}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b} \rangle$
			}
[
	{$\expandout{a}{b}{B}{r}{REL}{1}{1}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a, r, b} \rangle$
			}
[
	{$\getvertices{a}{A}$
			\\
			\footnotesize
			$\color{gray} \langle \var{a} \rangle$
			},tier=input,for tree={blue,densely dashed}
]
]
]
]
]
;
\end{forest}
}

\subsection{Null handling}

\subsubsection*{Query specification}

\begin{lstlisting}
OPTIONAL MATCH (a:Start)
WITH a
MATCH (a)-->(b)
RETURN *
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Nested maps}

\subsubsection*{Query specification}

\begin{lstlisting}
WITH {foo: {bar: 'baz'}} AS nestedMap
RETURN nestedMap.foo.bar
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Connected components succeeding WITH}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n:A)
WITH n
LIMIT 1
MATCH (m:B), (n)-->(x:X)
RETURN *
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Single WITH using a predicate and aggregation}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (n)
WITH n
WHERE n.prop = 42
RETURN count(*)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}

\subsection{Multiple WITHs using a predicate and aggregation}

\subsubsection*{Query specification}

\begin{lstlisting}
MATCH (david {name: 'David'})--(otherPerson)-->()
WITH otherPerson, count(*) AS foaf
WHERE foaf > 1
WITH otherPerson
WHERE otherPerson.name <> 'NotOther'
RETURN count(*)
\end{lstlisting}

\subsubsection*{Relational algebra expression}

\begin{align*}
\begin{autobreak}
\text{Cannot convert to expression.}
\end{autobreak}
\end{align*}

\subsubsection*{Relational algebra tree}

\adjustbox{max width=\textwidth}{%
\text{Cannot visualize tree.}
}

\subsubsection*{Relational algebra tree for incremental queries}

\adjustbox{max width=\textwidth}{%
Cannot visualize incremental tree.
}
