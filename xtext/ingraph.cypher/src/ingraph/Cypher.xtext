grammar ingraph.Cypher with org.eclipse.xtext.common.Terminals

generate cypher "http://www.Cypher.ingraph"

CypherQuery:
	(query=Query) (unions+=Union)*;

Union:
	{Union} 'UNION' all?=('ALL')? query=Query;

Query:
	match=MatchClause
	return=ReturnClause
	';'?;

	// MATCH
MatchClause:
	('MATCH' patterns+=Pattern)+
	('WHERE' condition=Condition)?;

Condition:
	ID;

	// Patterns
Pattern:
	parts+=PatternPart (',' parts+=PatternPart)*;

PatternPart:
	node=NodePattern (chain+=PatternElementChain)*;

NodePattern:
	{NodePattern} '(' variable=Variable? (':' label=Label)? ')';

PatternElementChain:
	relationshipPattern=RelationshipPattern nodePattern=NodePattern;

RelationshipPattern:
	{RelationshipPattern} ((LEFT_ARROW_HEAD DASH RelationshipDetail? DASH RIGHT_ARROW_HEAD)
	| (LEFT_ARROW_HEAD DASH RelationshipDetail? DASH)
	| (DASH RelationshipDetail? DASH RIGHT_ARROW_HEAD)
	| (DASH RelationshipDetail? DASH));

RelationshipDetail:
	{RelationshipDetail} '[' variable=Variable? (':' label=Label)? ']';

ReturnClause:
	{ReturnClause} 'RETURN' distinct?=('DISTINCT')? variables+=Variable+ order=Order? skip=Skip? limit=Limit?;

Order:
	'ORDER' 'BY' variables+=Variable+ (asc?=('ASC' | 'ASCENDING') | desc?=('DESC' | 'DESCENDING'));

Skip:
	'SKIP' amount=INT;

Limit:
	'LIMIT' amount=INT;

	// Common rules
Variable:
	name=ID;

Label:
	name=ID;

LEFT_ARROW_HEAD:
	'<' | '⟨' | '〈' | '﹤' | '＜';

RIGHT_ARROW_HEAD:
	'>' | '⟩' | '〉' | '﹥' | '＞';

DASH:
	'-' | '­' | '‐' | '‑' | '‒' | '–' | '—' | '―' | '−' | '﹘' | '﹣' | '－';
