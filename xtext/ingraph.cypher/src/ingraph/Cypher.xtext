grammar ingraph.Cypher with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate cypher "http://www.Cypher.ingraph"

CypherQuery:
	(query=Query) (unions+=Union)*;

Union:
	{Union} 'UNION' all?='ALL'? query=Query;

Query:
	match=MatchClause
	return=ReturnClause
	';'?;

/* MATCH */
MatchClause:
	('MATCH' patterns+=Pattern)+
	('WHERE' condition=Expression)?;

Expression:
	nots+='NOT'* (logicalExpression=LogicalExpression | comparison=ArithmeticComparison);

LogicalExpression:
	atom=Atom ('OR' logicalExpressions+=LogicalExpression)+;

//expression12 : expression11 ( sp OR sp expression11 )* ;
//
//expression11 : expression10 ( sp XOR sp expression10 )* ;
//
//expression10 : expression9 ( sp AND sp expression9 )* ;
//
//expression9 : ( sp NOT sp )* expression8 ;
//
//expression8 : expression7 ( ws partialComparisonExpression )* ;
//
//expression7 : expression6 ( ( ws '+' ws expression6 ) | ( ws '-' ws expression6 ) )* ;
//
//expression6 : expression5 ( ( ws '*' ws expression5 ) | ( ws '/' ws expression5 ) | ( ws '%' ws expression5 ) )* ;
//
//expression5 : expression4 ( ws '^' ws expression4 )* ;
//
//expression4 : ( ( '+' | '-' ) ws )* expression3 ;

ArithmeticComparison:
	leftOperand=Atom operator=BINARY_ARITHMETIC_COMPARISON_OPERATOR rightOperand=Atom;

BINARY_ARITHMETIC_COMPARISON_OPERATOR:
	'=' | '<>' | '!=' | '<' | '>' | '<=' | '>=';

Atom:
	{Atom} (number=NumberLiteral | string=StringLiteral | "NULL" | '(' expression=Expression ')');

NumberLiteral:
	int=IntegerLiteral | double=DoubleLiteral;

IntegerLiteral returns ecore::EInt:
	INT;

DoubleLiteral returns ecore::EFloat:
	INT '.' INT;

StringLiteral returns ecore::EString:
	STRING;

/* Patterns */
Pattern:
	parts+=PatternPart (',' parts+=PatternPart)*;

PatternPart:
	node=NodePattern (chain+=PatternElementChain)*;

NodePattern:
	{NodePattern} '(' variable=Variable? (':' label=Label)? ')';

PatternElementChain:
	relationshipPattern=RelationshipPattern nodePattern=NodePattern;

RelationshipPattern:
	both=Both | in=In | out=Out;

Both:
	{Both} (LEFT_ARROW_HEAD DASH detail=RelationshipDetail? DASH RIGHT_ARROW_HEAD) | (DASH detail=RelationshipDetail? DASH);

In:
	{In} LEFT_ARROW_HEAD DASH detail=RelationshipDetail? DASH;

Out:
	{Out} DASH detail=RelationshipDetail? DASH RIGHT_ARROW_HEAD
;

RelationshipDetail:
	{RelationshipDetail} '[' variable=Variable? (':' label=Label)? ']';

/* Return */
ReturnClause:
	{ReturnClause} 'RETURN' distinct?='DISTINCT'? variables+=Variable+ order=Order? skip=Skip? limit=Limit?;

Order:
	'ORDER' 'BY' variables+=Variable+ (asc?=('ASC' | 'ASCENDING') | desc?=('DESC' | 'DESCENDING'));

Skip:
	'SKIP' amount=INT;

Limit:
	'LIMIT' amount=INT;

/* Common rules */
Variable:
	name=ID;

Label:
	name=ID;

LEFT_ARROW_HEAD:
	'<' | '⟨' | '〈' | '﹤' | '＜';

RIGHT_ARROW_HEAD:
	'>' | '⟩' | '〉' | '﹥' | '＞';

DASH:
	'-' | '­' | '‐' | '‑' | '‒' | '–' | '—' | '―' | '−' | '﹘' | '﹣' | '－';
