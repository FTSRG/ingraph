grammar ingraph.Cypher with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate cypher "http://www.Cypher.ingraph"

CypherQuery:
	(query=Query) (unions+=Union)*;

Union:
	{Union} 'UNION' all?='ALL'? query=Query;

Query:
	match=MatchClause
	return=ReturnClause
	';'?;

/* MATCH */
MatchClause:
	('MATCH' patterns+=Pattern)+
	('WHERE' condition=Expression)?;

Expression: Expression12;

Expression12 : leftExpression=Expression11 ( 'OR' rightExpression+=Expression11 )* ;

Expression11 : leftExpression=Expression10 ( 'XOR' rightExpression+=Expression10 )* ;

Expression10 : leftExpression=Expression9 ( 'AND' rightExpression+=Expression9 )* ;

Expression9 : ( 'NOT' )* Expression8 ;

Expression8 : leftExpression=Expression7 ( comparison+=PartialComparisonExpression )* ;

Expression7 : leftExpression=Expression6 ( ( '+' rightExpression+=Expression6 ) | ( '-' rightExpression+=Expression6 ) )* ;

Expression6 : leftExpression=Expression5 ( ( '*' rightExpression+=Expression5 ) | ( '/' rightExpression+=Expression5 ) | ( '%' rightExpression+=Expression5 ) )* ;

Expression5 : leftExpression=Expression4 ( '^' rightExpression+=Expression4 )* ;

Expression4 : ( ( '+' | '-' ) )* expression=Expression3;

Expression3 : Expression2;

Expression2 : Atom ( propertyLookups+=PropertyLookup | nodeLabels+=NodeLabels )* ;

PropertyLookup:
	variable=Variable '.' property=Variable;
	
NodeLabels:	labels+=Label+;

PartialComparisonExpression:
	BINARY_ARITHMETIC_COMPARISON_OPERATOR expression=Expression7;

BINARY_ARITHMETIC_COMPARISON_OPERATOR:
	'=' | '<>' | '!=' | '<' | '>' | '<=' | '>=';

Atom:
	{Atom} (number=NumberLiteral | string=StringLiteral | "NULL" | '(' expression=Expression ')');

NumberLiteral:
	int=IntegerLiteral | double=DoubleLiteral;

IntegerLiteral returns ecore::EInt:
	INT;

DoubleLiteral returns ecore::EFloat:
	INT '.' INT;

StringLiteral returns ecore::EString:
	STRING;

/* Patterns */
Pattern:
	parts+=PatternPart (',' parts+=PatternPart)*;

PatternPart:
	node=NodePattern (chain+=PatternElementChain)*;

NodePattern:
	{NodePattern} '(' variable=Variable? (':' label=Label)? ')';

PatternElementChain:
	relationshipPattern=RelationshipPattern nodePattern=NodePattern;

RelationshipPattern:
	both=Both | in=In | out=Out;

Both:
	{Both} ((LEFT_ARROW_HEAD DASH detail=RelationshipDetail? DASH RIGHT_ARROW_HEAD) | (DASH detail=RelationshipDetail? DASH));

In:
	{In} LEFT_ARROW_HEAD DASH detail=RelationshipDetail? DASH;

Out:
	{Out} DASH detail=RelationshipDetail? DASH RIGHT_ARROW_HEAD
;

RelationshipDetail:
	{RelationshipDetail} '[' variable=Variable? (':' label=Label)? ']';

/* Return */
ReturnClause:
	{ReturnClause} 'RETURN' distinct?='DISTINCT'? variables+=Variable+ order=Order? skip=Skip? limit=Limit?;

Order:
	'ORDER' 'BY' variables+=Variable+ (asc?=('ASC' | 'ASCENDING') | desc?=('DESC' | 'DESCENDING'));

Skip:
	'SKIP' amount=INT;

Limit:
	'LIMIT' amount=INT;

/* Common rules */
Variable:
	name=ID;

Label:
	name=ID;

LEFT_ARROW_HEAD:
	'<' | '⟨' | '〈' | '﹤' | '＜';

RIGHT_ARROW_HEAD:
	'>' | '⟩' | '〉' | '﹥' | '＞';

DASH:
	'-' | '­' | '‐' | '‑' | '‒' | '–' | '—' | '―' | '−' | '﹘' | '﹣' | '－';
