/*
 * generated by Xtext 2.10.0
 */
package org.slizaa.neo4j.opencypher.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.slizaa.neo4j.opencypher.openCypher.All;
import org.slizaa.neo4j.opencypher.openCypher.AllOptions;
import org.slizaa.neo4j.opencypher.openCypher.AllShortestPath;
import org.slizaa.neo4j.opencypher.openCypher.Any;
import org.slizaa.neo4j.opencypher.openCypher.BoolConstant;
import org.slizaa.neo4j.opencypher.openCypher.BulkImportQuery;
import org.slizaa.neo4j.opencypher.openCypher.CaseAlternatives;
import org.slizaa.neo4j.opencypher.openCypher.CaseExpression;
import org.slizaa.neo4j.opencypher.openCypher.ConfigurationOption;
import org.slizaa.neo4j.opencypher.openCypher.Contains;
import org.slizaa.neo4j.opencypher.openCypher.Count;
import org.slizaa.neo4j.opencypher.openCypher.Create;
import org.slizaa.neo4j.opencypher.openCypher.CreateIndex;
import org.slizaa.neo4j.opencypher.openCypher.Cypher;
import org.slizaa.neo4j.opencypher.openCypher.CypherOption;
import org.slizaa.neo4j.opencypher.openCypher.DecimalInteger;
import org.slizaa.neo4j.opencypher.openCypher.Delete;
import org.slizaa.neo4j.opencypher.openCypher.DropIndex;
import org.slizaa.neo4j.opencypher.openCypher.DropNodePropertyExistenceConstraint;
import org.slizaa.neo4j.opencypher.openCypher.DropRelationshipPropertyExistenceConstraint;
import org.slizaa.neo4j.opencypher.openCypher.DropUniqueConstraint;
import org.slizaa.neo4j.opencypher.openCypher.EndsWith;
import org.slizaa.neo4j.opencypher.openCypher.Expression;
import org.slizaa.neo4j.opencypher.openCypher.ExpressionAnd;
import org.slizaa.neo4j.opencypher.openCypher.ExpressionComparison;
import org.slizaa.neo4j.opencypher.openCypher.ExpressionList;
import org.slizaa.neo4j.opencypher.openCypher.ExpressionMulDiv;
import org.slizaa.neo4j.opencypher.openCypher.ExpressionNodeLabelsAndPropertyLookup;
import org.slizaa.neo4j.opencypher.openCypher.ExpressionOr;
import org.slizaa.neo4j.opencypher.openCypher.ExpressionPlusMinus;
import org.slizaa.neo4j.opencypher.openCypher.ExpressionPower;
import org.slizaa.neo4j.opencypher.openCypher.ExpressionXor;
import org.slizaa.neo4j.opencypher.openCypher.Filter;
import org.slizaa.neo4j.opencypher.openCypher.FilterExpression;
import org.slizaa.neo4j.opencypher.openCypher.Foreach;
import org.slizaa.neo4j.opencypher.openCypher.FunctionInvocation;
import org.slizaa.neo4j.opencypher.openCypher.FunctionName;
import org.slizaa.neo4j.opencypher.openCypher.IdInColl;
import org.slizaa.neo4j.opencypher.openCypher.IdLookup;
import org.slizaa.neo4j.opencypher.openCypher.IdentifiedIndexLookup;
import org.slizaa.neo4j.opencypher.openCypher.InCollection;
import org.slizaa.neo4j.opencypher.openCypher.Index;
import org.slizaa.neo4j.opencypher.openCypher.IndexHint;
import org.slizaa.neo4j.opencypher.openCypher.IndexQuery;
import org.slizaa.neo4j.opencypher.openCypher.IsNotNull;
import org.slizaa.neo4j.opencypher.openCypher.IsNull;
import org.slizaa.neo4j.opencypher.openCypher.JoinHint;
import org.slizaa.neo4j.opencypher.openCypher.LegacyParameter;
import org.slizaa.neo4j.opencypher.openCypher.Limit;
import org.slizaa.neo4j.opencypher.openCypher.ListComprehension;
import org.slizaa.neo4j.opencypher.openCypher.LiteralIds;
import org.slizaa.neo4j.opencypher.openCypher.LoadCSV;
import org.slizaa.neo4j.opencypher.openCypher.LoadCSVQuery;
import org.slizaa.neo4j.opencypher.openCypher.MapLiteral;
import org.slizaa.neo4j.opencypher.openCypher.MapLiteralEntry;
import org.slizaa.neo4j.opencypher.openCypher.Match;
import org.slizaa.neo4j.opencypher.openCypher.Merge;
import org.slizaa.neo4j.opencypher.openCypher.MergeAction;
import org.slizaa.neo4j.opencypher.openCypher.NodeLabel;
import org.slizaa.neo4j.opencypher.openCypher.NodeLabels;
import org.slizaa.neo4j.opencypher.openCypher.NodePattern;
import org.slizaa.neo4j.opencypher.openCypher.NodePropertyExistenceConstraint;
import org.slizaa.neo4j.opencypher.openCypher.None;
import org.slizaa.neo4j.opencypher.openCypher.NullConstant;
import org.slizaa.neo4j.opencypher.openCypher.NumberConstant;
import org.slizaa.neo4j.opencypher.openCypher.OpenCypherPackage;
import org.slizaa.neo4j.opencypher.openCypher.Order;
import org.slizaa.neo4j.opencypher.openCypher.ParenthesizedExpression;
import org.slizaa.neo4j.opencypher.openCypher.Pattern;
import org.slizaa.neo4j.opencypher.openCypher.PatternElement;
import org.slizaa.neo4j.opencypher.openCypher.PatternElementChain;
import org.slizaa.neo4j.opencypher.openCypher.PatternPart;
import org.slizaa.neo4j.opencypher.openCypher.PeriodicCommitHint;
import org.slizaa.neo4j.opencypher.openCypher.PropertyLookup;
import org.slizaa.neo4j.opencypher.openCypher.RangeLiteral;
import org.slizaa.neo4j.opencypher.openCypher.Reduce;
import org.slizaa.neo4j.opencypher.openCypher.RegExpMatching;
import org.slizaa.neo4j.opencypher.openCypher.RegularQuery;
import org.slizaa.neo4j.opencypher.openCypher.RelationshipDetail;
import org.slizaa.neo4j.opencypher.openCypher.RelationshipPattern;
import org.slizaa.neo4j.opencypher.openCypher.RelationshipPatternSyntax;
import org.slizaa.neo4j.opencypher.openCypher.RelationshipPropertyExistenceConstraint;
import org.slizaa.neo4j.opencypher.openCypher.RelationshipTypes;
import org.slizaa.neo4j.opencypher.openCypher.RelationshipsPattern;
import org.slizaa.neo4j.opencypher.openCypher.Remove;
import org.slizaa.neo4j.opencypher.openCypher.RemoveItem;
import org.slizaa.neo4j.opencypher.openCypher.Return;
import org.slizaa.neo4j.opencypher.openCypher.ReturnItem;
import org.slizaa.neo4j.opencypher.openCypher.ReturnItems;
import org.slizaa.neo4j.opencypher.openCypher.ScanHint;
import org.slizaa.neo4j.opencypher.openCypher.SetItem;
import org.slizaa.neo4j.opencypher.openCypher.ShortestPath;
import org.slizaa.neo4j.opencypher.openCypher.Single;
import org.slizaa.neo4j.opencypher.openCypher.SingleQuery;
import org.slizaa.neo4j.opencypher.openCypher.Skip;
import org.slizaa.neo4j.opencypher.openCypher.SortItem;
import org.slizaa.neo4j.opencypher.openCypher.Start;
import org.slizaa.neo4j.opencypher.openCypher.StartPoint;
import org.slizaa.neo4j.opencypher.openCypher.StartsWith;
import org.slizaa.neo4j.opencypher.openCypher.StringConstant;
import org.slizaa.neo4j.opencypher.openCypher.Union;
import org.slizaa.neo4j.opencypher.openCypher.UniqueConstraint;
import org.slizaa.neo4j.opencypher.openCypher.Unwind;
import org.slizaa.neo4j.opencypher.openCypher.Variable;
import org.slizaa.neo4j.opencypher.openCypher.VariableRef;
import org.slizaa.neo4j.opencypher.openCypher.VersionNumber;
import org.slizaa.neo4j.opencypher.openCypher.Where;
import org.slizaa.neo4j.opencypher.openCypher.With;
import org.slizaa.neo4j.opencypher.services.OpenCypherGrammarAccess;

@SuppressWarnings("all")
public class OpenCypherSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private OpenCypherGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == OpenCypherPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case OpenCypherPackage.ALL:
				if (rule == grammarAccess.getAtomRule()) {
					sequence_Atom(context, (All) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getExpressionOrRule()
						|| action == grammarAccess.getExpressionOrAccess().getExpressionOrLeftAction_1_0()
						|| rule == grammarAccess.getExpressionXorRule()
						|| action == grammarAccess.getExpressionXorAccess().getExpressionXorLeftAction_1_0()
						|| rule == grammarAccess.getExpressionAndRule()
						|| action == grammarAccess.getExpressionAndAccess().getExpressionAndLeftAction_1_0()
						|| rule == grammarAccess.getExpressionNotRule()
						|| rule == grammarAccess.getExpressionComparisonRule()
						|| action == grammarAccess.getExpressionComparisonAccess().getExpressionComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPlusMinusRule()
						|| action == grammarAccess.getExpressionPlusMinusAccess().getExpressionPlusMinusLeftAction_1_0()
						|| rule == grammarAccess.getExpressionMulDivRule()
						|| action == grammarAccess.getExpressionMulDivAccess().getExpressionMulDivLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPowerRule()
						|| action == grammarAccess.getExpressionPowerAccess().getExpressionPowerLeftAction_1_0()
						|| rule == grammarAccess.getExpressionUnaryPlusMinusRule()
						|| rule == grammarAccess.getExpression3Rule()) {
					sequence_Atom_Expression3_ExpressionNodeLabelsAndPropertyLookup(context, (All) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionNodeLabelsAndPropertyLookupRule()
						|| action == grammarAccess.getExpressionNodeLabelsAndPropertyLookupAccess().getExpressionNodeLabelsAndPropertyLookupLeftAction_1_0_0()) {
					sequence_Atom_ExpressionNodeLabelsAndPropertyLookup(context, (All) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRemoveItemRule()
						|| rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_Atom_PropertyExpression(context, (All) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.ALL_OPTIONS:
				sequence_QueryOptions(context, (AllOptions) semanticObject); 
				return; 
			case OpenCypherPackage.ALL_SHORTEST_PATH:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getExpressionOrRule()
						|| action == grammarAccess.getExpressionOrAccess().getExpressionOrLeftAction_1_0()
						|| rule == grammarAccess.getExpressionXorRule()
						|| action == grammarAccess.getExpressionXorAccess().getExpressionXorLeftAction_1_0()
						|| rule == grammarAccess.getExpressionAndRule()
						|| action == grammarAccess.getExpressionAndAccess().getExpressionAndLeftAction_1_0()
						|| rule == grammarAccess.getExpressionNotRule()
						|| rule == grammarAccess.getExpressionComparisonRule()
						|| action == grammarAccess.getExpressionComparisonAccess().getExpressionComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPlusMinusRule()
						|| action == grammarAccess.getExpressionPlusMinusAccess().getExpressionPlusMinusLeftAction_1_0()
						|| rule == grammarAccess.getExpressionMulDivRule()
						|| action == grammarAccess.getExpressionMulDivAccess().getExpressionMulDivLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPowerRule()
						|| action == grammarAccess.getExpressionPowerAccess().getExpressionPowerLeftAction_1_0()
						|| rule == grammarAccess.getExpressionUnaryPlusMinusRule()
						|| rule == grammarAccess.getExpression3Rule()) {
					sequence_Expression3_ExpressionNodeLabelsAndPropertyLookup_ShortestPathPattern(context, (AllShortestPath) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionNodeLabelsAndPropertyLookupRule()
						|| action == grammarAccess.getExpressionNodeLabelsAndPropertyLookupAccess().getExpressionNodeLabelsAndPropertyLookupLeftAction_1_0_0()) {
					sequence_ExpressionNodeLabelsAndPropertyLookup_ShortestPathPattern(context, (AllShortestPath) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRemoveItemRule()
						|| rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_PropertyExpression_ShortestPathPattern(context, (AllShortestPath) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPatternPartRule()
						|| rule == grammarAccess.getAnonymousPatternPartRule()
						|| rule == grammarAccess.getShortestPathPatternRule()
						|| rule == grammarAccess.getAtomRule()) {
					sequence_ShortestPathPattern(context, (AllShortestPath) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.ANY:
				if (rule == grammarAccess.getAtomRule()) {
					sequence_Atom(context, (Any) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getExpressionOrRule()
						|| action == grammarAccess.getExpressionOrAccess().getExpressionOrLeftAction_1_0()
						|| rule == grammarAccess.getExpressionXorRule()
						|| action == grammarAccess.getExpressionXorAccess().getExpressionXorLeftAction_1_0()
						|| rule == grammarAccess.getExpressionAndRule()
						|| action == grammarAccess.getExpressionAndAccess().getExpressionAndLeftAction_1_0()
						|| rule == grammarAccess.getExpressionNotRule()
						|| rule == grammarAccess.getExpressionComparisonRule()
						|| action == grammarAccess.getExpressionComparisonAccess().getExpressionComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPlusMinusRule()
						|| action == grammarAccess.getExpressionPlusMinusAccess().getExpressionPlusMinusLeftAction_1_0()
						|| rule == grammarAccess.getExpressionMulDivRule()
						|| action == grammarAccess.getExpressionMulDivAccess().getExpressionMulDivLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPowerRule()
						|| action == grammarAccess.getExpressionPowerAccess().getExpressionPowerLeftAction_1_0()
						|| rule == grammarAccess.getExpressionUnaryPlusMinusRule()
						|| rule == grammarAccess.getExpression3Rule()) {
					sequence_Atom_Expression3_ExpressionNodeLabelsAndPropertyLookup(context, (Any) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionNodeLabelsAndPropertyLookupRule()
						|| action == grammarAccess.getExpressionNodeLabelsAndPropertyLookupAccess().getExpressionNodeLabelsAndPropertyLookupLeftAction_1_0_0()) {
					sequence_Atom_ExpressionNodeLabelsAndPropertyLookup(context, (Any) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRemoveItemRule()
						|| rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_Atom_PropertyExpression(context, (Any) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.BOOL_CONSTANT:
				if (rule == grammarAccess.getAtomRule()) {
					sequence_Atom(context, (BoolConstant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getExpressionOrRule()
						|| action == grammarAccess.getExpressionOrAccess().getExpressionOrLeftAction_1_0()
						|| rule == grammarAccess.getExpressionXorRule()
						|| action == grammarAccess.getExpressionXorAccess().getExpressionXorLeftAction_1_0()
						|| rule == grammarAccess.getExpressionAndRule()
						|| action == grammarAccess.getExpressionAndAccess().getExpressionAndLeftAction_1_0()
						|| rule == grammarAccess.getExpressionNotRule()
						|| rule == grammarAccess.getExpressionComparisonRule()
						|| action == grammarAccess.getExpressionComparisonAccess().getExpressionComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPlusMinusRule()
						|| action == grammarAccess.getExpressionPlusMinusAccess().getExpressionPlusMinusLeftAction_1_0()
						|| rule == grammarAccess.getExpressionMulDivRule()
						|| action == grammarAccess.getExpressionMulDivAccess().getExpressionMulDivLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPowerRule()
						|| action == grammarAccess.getExpressionPowerAccess().getExpressionPowerLeftAction_1_0()
						|| rule == grammarAccess.getExpressionUnaryPlusMinusRule()
						|| rule == grammarAccess.getExpression3Rule()) {
					sequence_Atom_Expression3_ExpressionNodeLabelsAndPropertyLookup(context, (BoolConstant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionNodeLabelsAndPropertyLookupRule()
						|| action == grammarAccess.getExpressionNodeLabelsAndPropertyLookupAccess().getExpressionNodeLabelsAndPropertyLookupLeftAction_1_0_0()) {
					sequence_Atom_ExpressionNodeLabelsAndPropertyLookup(context, (BoolConstant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRemoveItemRule()
						|| rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_Atom_PropertyExpression(context, (BoolConstant) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.BULK_IMPORT_QUERY:
				sequence_BulkImportQuery(context, (BulkImportQuery) semanticObject); 
				return; 
			case OpenCypherPackage.CASE_ALTERNATIVES:
				sequence_CaseAlternatives(context, (CaseAlternatives) semanticObject); 
				return; 
			case OpenCypherPackage.CASE_EXPRESSION:
				if (rule == grammarAccess.getAtomRule()) {
					sequence_Atom(context, (CaseExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getExpressionOrRule()
						|| action == grammarAccess.getExpressionOrAccess().getExpressionOrLeftAction_1_0()
						|| rule == grammarAccess.getExpressionXorRule()
						|| action == grammarAccess.getExpressionXorAccess().getExpressionXorLeftAction_1_0()
						|| rule == grammarAccess.getExpressionAndRule()
						|| action == grammarAccess.getExpressionAndAccess().getExpressionAndLeftAction_1_0()
						|| rule == grammarAccess.getExpressionNotRule()
						|| rule == grammarAccess.getExpressionComparisonRule()
						|| action == grammarAccess.getExpressionComparisonAccess().getExpressionComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPlusMinusRule()
						|| action == grammarAccess.getExpressionPlusMinusAccess().getExpressionPlusMinusLeftAction_1_0()
						|| rule == grammarAccess.getExpressionMulDivRule()
						|| action == grammarAccess.getExpressionMulDivAccess().getExpressionMulDivLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPowerRule()
						|| action == grammarAccess.getExpressionPowerAccess().getExpressionPowerLeftAction_1_0()
						|| rule == grammarAccess.getExpressionUnaryPlusMinusRule()
						|| rule == grammarAccess.getExpression3Rule()) {
					sequence_Atom_Expression3_ExpressionNodeLabelsAndPropertyLookup(context, (CaseExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionNodeLabelsAndPropertyLookupRule()
						|| action == grammarAccess.getExpressionNodeLabelsAndPropertyLookupAccess().getExpressionNodeLabelsAndPropertyLookupLeftAction_1_0_0()) {
					sequence_Atom_ExpressionNodeLabelsAndPropertyLookup(context, (CaseExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRemoveItemRule()
						|| rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_Atom_PropertyExpression(context, (CaseExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getCaseExpressionRule()) {
					sequence_CaseExpression(context, (CaseExpression) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.CONFIGURATION_OPTION:
				sequence_ConfigurationOption(context, (ConfigurationOption) semanticObject); 
				return; 
			case OpenCypherPackage.CONTAINS:
				sequence_Expression3Part(context, (Contains) semanticObject); 
				return; 
			case OpenCypherPackage.COUNT:
				if (rule == grammarAccess.getAtomRule()) {
					sequence_Atom(context, (Count) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getExpressionOrRule()
						|| action == grammarAccess.getExpressionOrAccess().getExpressionOrLeftAction_1_0()
						|| rule == grammarAccess.getExpressionXorRule()
						|| action == grammarAccess.getExpressionXorAccess().getExpressionXorLeftAction_1_0()
						|| rule == grammarAccess.getExpressionAndRule()
						|| action == grammarAccess.getExpressionAndAccess().getExpressionAndLeftAction_1_0()
						|| rule == grammarAccess.getExpressionNotRule()
						|| rule == grammarAccess.getExpressionComparisonRule()
						|| action == grammarAccess.getExpressionComparisonAccess().getExpressionComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPlusMinusRule()
						|| action == grammarAccess.getExpressionPlusMinusAccess().getExpressionPlusMinusLeftAction_1_0()
						|| rule == grammarAccess.getExpressionMulDivRule()
						|| action == grammarAccess.getExpressionMulDivAccess().getExpressionMulDivLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPowerRule()
						|| action == grammarAccess.getExpressionPowerAccess().getExpressionPowerLeftAction_1_0()
						|| rule == grammarAccess.getExpressionUnaryPlusMinusRule()
						|| rule == grammarAccess.getExpression3Rule()) {
					sequence_Atom_Expression3_ExpressionNodeLabelsAndPropertyLookup(context, (Count) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionNodeLabelsAndPropertyLookupRule()
						|| action == grammarAccess.getExpressionNodeLabelsAndPropertyLookupAccess().getExpressionNodeLabelsAndPropertyLookupLeftAction_1_0_0()) {
					sequence_Atom_ExpressionNodeLabelsAndPropertyLookup(context, (Count) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRemoveItemRule()
						|| rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_Atom_PropertyExpression(context, (Count) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.CREATE:
				sequence_Create(context, (Create) semanticObject); 
				return; 
			case OpenCypherPackage.CREATE_INDEX:
				sequence_CreateIndex(context, (CreateIndex) semanticObject); 
				return; 
			case OpenCypherPackage.CYPHER:
				sequence_Cypher(context, (Cypher) semanticObject); 
				return; 
			case OpenCypherPackage.CYPHER_OPTION:
				sequence_CypherOption(context, (CypherOption) semanticObject); 
				return; 
			case OpenCypherPackage.DECIMAL_INTEGER:
				sequence_DecimalInteger(context, (DecimalInteger) semanticObject); 
				return; 
			case OpenCypherPackage.DELETE:
				sequence_Delete(context, (Delete) semanticObject); 
				return; 
			case OpenCypherPackage.DROP_INDEX:
				sequence_DropIndex(context, (DropIndex) semanticObject); 
				return; 
			case OpenCypherPackage.DROP_NODE_PROPERTY_EXISTENCE_CONSTRAINT:
				sequence_DropNodePropertyExistenceConstraint(context, (DropNodePropertyExistenceConstraint) semanticObject); 
				return; 
			case OpenCypherPackage.DROP_RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT:
				sequence_DropRelationshipPropertyExistenceConstraint(context, (DropRelationshipPropertyExistenceConstraint) semanticObject); 
				return; 
			case OpenCypherPackage.DROP_UNIQUE_CONSTRAINT:
				sequence_DropUniqueConstraint(context, (DropUniqueConstraint) semanticObject); 
				return; 
			case OpenCypherPackage.ENDS_WITH:
				sequence_Expression3Part(context, (EndsWith) semanticObject); 
				return; 
			case OpenCypherPackage.EXPRESSION:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getExpressionOrRule()
						|| action == grammarAccess.getExpressionOrAccess().getExpressionOrLeftAction_1_0()
						|| rule == grammarAccess.getExpressionXorRule()
						|| action == grammarAccess.getExpressionXorAccess().getExpressionXorLeftAction_1_0()
						|| rule == grammarAccess.getExpressionAndRule()
						|| action == grammarAccess.getExpressionAndAccess().getExpressionAndLeftAction_1_0()
						|| rule == grammarAccess.getExpressionNotRule()) {
					sequence_ExpressionNot_ExpressionUnaryPlusMinus(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionComparisonRule()
						|| action == grammarAccess.getExpressionComparisonAccess().getExpressionComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPlusMinusRule()
						|| action == grammarAccess.getExpressionPlusMinusAccess().getExpressionPlusMinusLeftAction_1_0()
						|| rule == grammarAccess.getExpressionMulDivRule()
						|| action == grammarAccess.getExpressionMulDivAccess().getExpressionMulDivLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPowerRule()
						|| action == grammarAccess.getExpressionPowerAccess().getExpressionPowerLeftAction_1_0()
						|| rule == grammarAccess.getExpressionUnaryPlusMinusRule()) {
					sequence_ExpressionUnaryPlusMinus(context, (Expression) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.EXPRESSION_AND:
				sequence_ExpressionAnd(context, (ExpressionAnd) semanticObject); 
				return; 
			case OpenCypherPackage.EXPRESSION_COMPARISON:
				sequence_ExpressionComparison(context, (ExpressionComparison) semanticObject); 
				return; 
			case OpenCypherPackage.EXPRESSION_LIST:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getExpressionOrRule()
						|| action == grammarAccess.getExpressionOrAccess().getExpressionOrLeftAction_1_0()
						|| rule == grammarAccess.getExpressionXorRule()
						|| action == grammarAccess.getExpressionXorAccess().getExpressionXorLeftAction_1_0()
						|| rule == grammarAccess.getExpressionAndRule()
						|| action == grammarAccess.getExpressionAndAccess().getExpressionAndLeftAction_1_0()
						|| rule == grammarAccess.getExpressionNotRule()
						|| rule == grammarAccess.getExpressionComparisonRule()
						|| action == grammarAccess.getExpressionComparisonAccess().getExpressionComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPlusMinusRule()
						|| action == grammarAccess.getExpressionPlusMinusAccess().getExpressionPlusMinusLeftAction_1_0()
						|| rule == grammarAccess.getExpressionMulDivRule()
						|| action == grammarAccess.getExpressionMulDivAccess().getExpressionMulDivLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPowerRule()
						|| action == grammarAccess.getExpressionPowerAccess().getExpressionPowerLeftAction_1_0()
						|| rule == grammarAccess.getExpressionUnaryPlusMinusRule()
						|| rule == grammarAccess.getExpression3Rule()) {
					sequence_Atom_Expression3_ExpressionNodeLabelsAndPropertyLookup(context, (ExpressionList) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAtomRule()) {
					sequence_Atom(context, (ExpressionList) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionNodeLabelsAndPropertyLookupRule()
						|| action == grammarAccess.getExpressionNodeLabelsAndPropertyLookupAccess().getExpressionNodeLabelsAndPropertyLookupLeftAction_1_0_0()) {
					sequence_Atom_ExpressionNodeLabelsAndPropertyLookup(context, (ExpressionList) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRemoveItemRule()
						|| rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_Atom_PropertyExpression(context, (ExpressionList) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.EXPRESSION_MUL_DIV:
				sequence_ExpressionMulDiv(context, (ExpressionMulDiv) semanticObject); 
				return; 
			case OpenCypherPackage.EXPRESSION_NODE_LABELS_AND_PROPERTY_LOOKUP:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getExpressionOrRule()
						|| action == grammarAccess.getExpressionOrAccess().getExpressionOrLeftAction_1_0()
						|| rule == grammarAccess.getExpressionXorRule()
						|| action == grammarAccess.getExpressionXorAccess().getExpressionXorLeftAction_1_0()
						|| rule == grammarAccess.getExpressionAndRule()
						|| action == grammarAccess.getExpressionAndAccess().getExpressionAndLeftAction_1_0()
						|| rule == grammarAccess.getExpressionNotRule()
						|| rule == grammarAccess.getExpressionComparisonRule()
						|| action == grammarAccess.getExpressionComparisonAccess().getExpressionComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPlusMinusRule()
						|| action == grammarAccess.getExpressionPlusMinusAccess().getExpressionPlusMinusLeftAction_1_0()
						|| rule == grammarAccess.getExpressionMulDivRule()
						|| action == grammarAccess.getExpressionMulDivAccess().getExpressionMulDivLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPowerRule()
						|| action == grammarAccess.getExpressionPowerAccess().getExpressionPowerLeftAction_1_0()
						|| rule == grammarAccess.getExpressionUnaryPlusMinusRule()
						|| rule == grammarAccess.getExpression3Rule()) {
					sequence_Expression3_ExpressionNodeLabelsAndPropertyLookup(context, (ExpressionNodeLabelsAndPropertyLookup) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionNodeLabelsAndPropertyLookupRule()
						|| action == grammarAccess.getExpressionNodeLabelsAndPropertyLookupAccess().getExpressionNodeLabelsAndPropertyLookupLeftAction_1_0_0()) {
					sequence_ExpressionNodeLabelsAndPropertyLookup(context, (ExpressionNodeLabelsAndPropertyLookup) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.EXPRESSION_OR:
				sequence_ExpressionOr(context, (ExpressionOr) semanticObject); 
				return; 
			case OpenCypherPackage.EXPRESSION_PLUS_MINUS:
				sequence_ExpressionPlusMinus(context, (ExpressionPlusMinus) semanticObject); 
				return; 
			case OpenCypherPackage.EXPRESSION_POWER:
				sequence_ExpressionPower(context, (ExpressionPower) semanticObject); 
				return; 
			case OpenCypherPackage.EXPRESSION_XOR:
				sequence_ExpressionXor(context, (ExpressionXor) semanticObject); 
				return; 
			case OpenCypherPackage.FILTER:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getExpressionOrRule()
						|| action == grammarAccess.getExpressionOrAccess().getExpressionOrLeftAction_1_0()
						|| rule == grammarAccess.getExpressionXorRule()
						|| action == grammarAccess.getExpressionXorAccess().getExpressionXorLeftAction_1_0()
						|| rule == grammarAccess.getExpressionAndRule()
						|| action == grammarAccess.getExpressionAndAccess().getExpressionAndLeftAction_1_0()
						|| rule == grammarAccess.getExpressionNotRule()
						|| rule == grammarAccess.getExpressionComparisonRule()
						|| action == grammarAccess.getExpressionComparisonAccess().getExpressionComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPlusMinusRule()
						|| action == grammarAccess.getExpressionPlusMinusAccess().getExpressionPlusMinusLeftAction_1_0()
						|| rule == grammarAccess.getExpressionMulDivRule()
						|| action == grammarAccess.getExpressionMulDivAccess().getExpressionMulDivLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPowerRule()
						|| action == grammarAccess.getExpressionPowerAccess().getExpressionPowerLeftAction_1_0()
						|| rule == grammarAccess.getExpressionUnaryPlusMinusRule()
						|| rule == grammarAccess.getExpression3Rule()) {
					sequence_Atom_Expression3_ExpressionNodeLabelsAndPropertyLookup(context, (Filter) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionNodeLabelsAndPropertyLookupRule()
						|| action == grammarAccess.getExpressionNodeLabelsAndPropertyLookupAccess().getExpressionNodeLabelsAndPropertyLookupLeftAction_1_0_0()) {
					sequence_Atom_ExpressionNodeLabelsAndPropertyLookup(context, (Filter) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAtomRule()) {
					sequence_Atom(context, (Filter) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRemoveItemRule()
						|| rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_Atom_PropertyExpression(context, (Filter) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.FILTER_EXPRESSION:
				sequence_FilterExpression(context, (FilterExpression) semanticObject); 
				return; 
			case OpenCypherPackage.FOREACH:
				sequence_Foreach(context, (Foreach) semanticObject); 
				return; 
			case OpenCypherPackage.FUNCTION_INVOCATION:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getExpressionOrRule()
						|| action == grammarAccess.getExpressionOrAccess().getExpressionOrLeftAction_1_0()
						|| rule == grammarAccess.getExpressionXorRule()
						|| action == grammarAccess.getExpressionXorAccess().getExpressionXorLeftAction_1_0()
						|| rule == grammarAccess.getExpressionAndRule()
						|| action == grammarAccess.getExpressionAndAccess().getExpressionAndLeftAction_1_0()
						|| rule == grammarAccess.getExpressionNotRule()
						|| rule == grammarAccess.getExpressionComparisonRule()
						|| action == grammarAccess.getExpressionComparisonAccess().getExpressionComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPlusMinusRule()
						|| action == grammarAccess.getExpressionPlusMinusAccess().getExpressionPlusMinusLeftAction_1_0()
						|| rule == grammarAccess.getExpressionMulDivRule()
						|| action == grammarAccess.getExpressionMulDivAccess().getExpressionMulDivLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPowerRule()
						|| action == grammarAccess.getExpressionPowerAccess().getExpressionPowerLeftAction_1_0()
						|| rule == grammarAccess.getExpressionUnaryPlusMinusRule()
						|| rule == grammarAccess.getExpression3Rule()) {
					sequence_Expression3_ExpressionNodeLabelsAndPropertyLookup_FunctionInvocation(context, (FunctionInvocation) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionNodeLabelsAndPropertyLookupRule()
						|| action == grammarAccess.getExpressionNodeLabelsAndPropertyLookupAccess().getExpressionNodeLabelsAndPropertyLookupLeftAction_1_0_0()) {
					sequence_ExpressionNodeLabelsAndPropertyLookup_FunctionInvocation(context, (FunctionInvocation) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAtomRule()
						|| rule == grammarAccess.getFunctionInvocationRule()) {
					sequence_FunctionInvocation(context, (FunctionInvocation) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRemoveItemRule()
						|| rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_FunctionInvocation_PropertyExpression(context, (FunctionInvocation) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.FUNCTION_NAME:
				sequence_FunctionName(context, (FunctionName) semanticObject); 
				return; 
			case OpenCypherPackage.ID_IN_COLL:
				sequence_IdInColl(context, (IdInColl) semanticObject); 
				return; 
			case OpenCypherPackage.ID_LOOKUP:
				sequence_IdLookup(context, (IdLookup) semanticObject); 
				return; 
			case OpenCypherPackage.IDENTIFIED_INDEX_LOOKUP:
				sequence_IdentifiedIndexLookup(context, (IdentifiedIndexLookup) semanticObject); 
				return; 
			case OpenCypherPackage.IN_COLLECTION:
				sequence_Expression3Part(context, (InCollection) semanticObject); 
				return; 
			case OpenCypherPackage.INDEX:
				if (rule == grammarAccess.getExpression3PartRule()) {
					sequence_Expression3Part(context, (Index) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getIndexRule()) {
					sequence_Index(context, (Index) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.INDEX_HINT:
				sequence_Hint(context, (IndexHint) semanticObject); 
				return; 
			case OpenCypherPackage.INDEX_QUERY:
				sequence_IndexQuery(context, (IndexQuery) semanticObject); 
				return; 
			case OpenCypherPackage.IS_NOT_NULL:
				sequence_Expression3Part(context, (IsNotNull) semanticObject); 
				return; 
			case OpenCypherPackage.IS_NULL:
				sequence_Expression3Part(context, (IsNull) semanticObject); 
				return; 
			case OpenCypherPackage.JOIN_HINT:
				sequence_Hint(context, (JoinHint) semanticObject); 
				return; 
			case OpenCypherPackage.LEGACY_PARAMETER:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getExpressionOrRule()
						|| action == grammarAccess.getExpressionOrAccess().getExpressionOrLeftAction_1_0()
						|| rule == grammarAccess.getExpressionXorRule()
						|| action == grammarAccess.getExpressionXorAccess().getExpressionXorLeftAction_1_0()
						|| rule == grammarAccess.getExpressionAndRule()
						|| action == grammarAccess.getExpressionAndAccess().getExpressionAndLeftAction_1_0()
						|| rule == grammarAccess.getExpressionNotRule()
						|| rule == grammarAccess.getExpressionComparisonRule()
						|| action == grammarAccess.getExpressionComparisonAccess().getExpressionComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPlusMinusRule()
						|| action == grammarAccess.getExpressionPlusMinusAccess().getExpressionPlusMinusLeftAction_1_0()
						|| rule == grammarAccess.getExpressionMulDivRule()
						|| action == grammarAccess.getExpressionMulDivAccess().getExpressionMulDivLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPowerRule()
						|| action == grammarAccess.getExpressionPowerAccess().getExpressionPowerLeftAction_1_0()
						|| rule == grammarAccess.getExpressionUnaryPlusMinusRule()
						|| rule == grammarAccess.getExpression3Rule()) {
					sequence_Expression3_ExpressionNodeLabelsAndPropertyLookup_LegacyParameter(context, (LegacyParameter) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionNodeLabelsAndPropertyLookupRule()
						|| action == grammarAccess.getExpressionNodeLabelsAndPropertyLookupAccess().getExpressionNodeLabelsAndPropertyLookupLeftAction_1_0_0()) {
					sequence_ExpressionNodeLabelsAndPropertyLookup_LegacyParameter(context, (LegacyParameter) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPropertiesRule()
						|| rule == grammarAccess.getAtomRule()
						|| rule == grammarAccess.getLegacyParameterRule()) {
					sequence_LegacyParameter(context, (LegacyParameter) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRemoveItemRule()
						|| rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_LegacyParameter_PropertyExpression(context, (LegacyParameter) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.LIMIT:
				sequence_Limit(context, (Limit) semanticObject); 
				return; 
			case OpenCypherPackage.LIST_COMPREHENSION:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getExpressionOrRule()
						|| action == grammarAccess.getExpressionOrAccess().getExpressionOrLeftAction_1_0()
						|| rule == grammarAccess.getExpressionXorRule()
						|| action == grammarAccess.getExpressionXorAccess().getExpressionXorLeftAction_1_0()
						|| rule == grammarAccess.getExpressionAndRule()
						|| action == grammarAccess.getExpressionAndAccess().getExpressionAndLeftAction_1_0()
						|| rule == grammarAccess.getExpressionNotRule()
						|| rule == grammarAccess.getExpressionComparisonRule()
						|| action == grammarAccess.getExpressionComparisonAccess().getExpressionComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPlusMinusRule()
						|| action == grammarAccess.getExpressionPlusMinusAccess().getExpressionPlusMinusLeftAction_1_0()
						|| rule == grammarAccess.getExpressionMulDivRule()
						|| action == grammarAccess.getExpressionMulDivAccess().getExpressionMulDivLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPowerRule()
						|| action == grammarAccess.getExpressionPowerAccess().getExpressionPowerLeftAction_1_0()
						|| rule == grammarAccess.getExpressionUnaryPlusMinusRule()
						|| rule == grammarAccess.getExpression3Rule()) {
					sequence_Expression3_ExpressionNodeLabelsAndPropertyLookup_ListComprehension(context, (ListComprehension) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionNodeLabelsAndPropertyLookupRule()
						|| action == grammarAccess.getExpressionNodeLabelsAndPropertyLookupAccess().getExpressionNodeLabelsAndPropertyLookupLeftAction_1_0_0()) {
					sequence_ExpressionNodeLabelsAndPropertyLookup_ListComprehension(context, (ListComprehension) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAtomRule()
						|| rule == grammarAccess.getListComprehensionRule()) {
					sequence_ListComprehension(context, (ListComprehension) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRemoveItemRule()
						|| rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_ListComprehension_PropertyExpression(context, (ListComprehension) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.LITERAL_IDS:
				sequence_LiteralIds(context, (LiteralIds) semanticObject); 
				return; 
			case OpenCypherPackage.LOAD_CSV:
				sequence_LoadCSV(context, (LoadCSV) semanticObject); 
				return; 
			case OpenCypherPackage.LOAD_CSV_QUERY:
				sequence_LoadCSVQuery(context, (LoadCSVQuery) semanticObject); 
				return; 
			case OpenCypherPackage.MAP_LITERAL:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getExpressionOrRule()
						|| action == grammarAccess.getExpressionOrAccess().getExpressionOrLeftAction_1_0()
						|| rule == grammarAccess.getExpressionXorRule()
						|| action == grammarAccess.getExpressionXorAccess().getExpressionXorLeftAction_1_0()
						|| rule == grammarAccess.getExpressionAndRule()
						|| action == grammarAccess.getExpressionAndAccess().getExpressionAndLeftAction_1_0()
						|| rule == grammarAccess.getExpressionNotRule()
						|| rule == grammarAccess.getExpressionComparisonRule()
						|| action == grammarAccess.getExpressionComparisonAccess().getExpressionComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPlusMinusRule()
						|| action == grammarAccess.getExpressionPlusMinusAccess().getExpressionPlusMinusLeftAction_1_0()
						|| rule == grammarAccess.getExpressionMulDivRule()
						|| action == grammarAccess.getExpressionMulDivAccess().getExpressionMulDivLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPowerRule()
						|| action == grammarAccess.getExpressionPowerAccess().getExpressionPowerLeftAction_1_0()
						|| rule == grammarAccess.getExpressionUnaryPlusMinusRule()
						|| rule == grammarAccess.getExpression3Rule()) {
					sequence_Expression3_ExpressionNodeLabelsAndPropertyLookup_MapLiteral(context, (MapLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionNodeLabelsAndPropertyLookupRule()
						|| action == grammarAccess.getExpressionNodeLabelsAndPropertyLookupAccess().getExpressionNodeLabelsAndPropertyLookupLeftAction_1_0_0()) {
					sequence_ExpressionNodeLabelsAndPropertyLookup_MapLiteral(context, (MapLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPropertiesRule()
						|| rule == grammarAccess.getAtomRule()
						|| rule == grammarAccess.getMapLiteralRule()) {
					sequence_MapLiteral(context, (MapLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRemoveItemRule()
						|| rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_MapLiteral_PropertyExpression(context, (MapLiteral) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.MAP_LITERAL_ENTRY:
				sequence_MapLiteralEntry(context, (MapLiteralEntry) semanticObject); 
				return; 
			case OpenCypherPackage.MATCH:
				sequence_Match(context, (Match) semanticObject); 
				return; 
			case OpenCypherPackage.MERGE:
				sequence_Merge(context, (Merge) semanticObject); 
				return; 
			case OpenCypherPackage.MERGE_ACTION:
				sequence_MergeAction(context, (MergeAction) semanticObject); 
				return; 
			case OpenCypherPackage.NODE_LABEL:
				sequence_NodeLabel(context, (NodeLabel) semanticObject); 
				return; 
			case OpenCypherPackage.NODE_LABELS:
				sequence_NodeLabels(context, (NodeLabels) semanticObject); 
				return; 
			case OpenCypherPackage.NODE_PATTERN:
				sequence_NodePattern(context, (NodePattern) semanticObject); 
				return; 
			case OpenCypherPackage.NODE_PROPERTY_EXISTENCE_CONSTRAINT:
				sequence_NodePropertyExistenceConstraint(context, (NodePropertyExistenceConstraint) semanticObject); 
				return; 
			case OpenCypherPackage.NONE:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getExpressionOrRule()
						|| action == grammarAccess.getExpressionOrAccess().getExpressionOrLeftAction_1_0()
						|| rule == grammarAccess.getExpressionXorRule()
						|| action == grammarAccess.getExpressionXorAccess().getExpressionXorLeftAction_1_0()
						|| rule == grammarAccess.getExpressionAndRule()
						|| action == grammarAccess.getExpressionAndAccess().getExpressionAndLeftAction_1_0()
						|| rule == grammarAccess.getExpressionNotRule()
						|| rule == grammarAccess.getExpressionComparisonRule()
						|| action == grammarAccess.getExpressionComparisonAccess().getExpressionComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPlusMinusRule()
						|| action == grammarAccess.getExpressionPlusMinusAccess().getExpressionPlusMinusLeftAction_1_0()
						|| rule == grammarAccess.getExpressionMulDivRule()
						|| action == grammarAccess.getExpressionMulDivAccess().getExpressionMulDivLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPowerRule()
						|| action == grammarAccess.getExpressionPowerAccess().getExpressionPowerLeftAction_1_0()
						|| rule == grammarAccess.getExpressionUnaryPlusMinusRule()
						|| rule == grammarAccess.getExpression3Rule()) {
					sequence_Atom_Expression3_ExpressionNodeLabelsAndPropertyLookup(context, (None) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionNodeLabelsAndPropertyLookupRule()
						|| action == grammarAccess.getExpressionNodeLabelsAndPropertyLookupAccess().getExpressionNodeLabelsAndPropertyLookupLeftAction_1_0_0()) {
					sequence_Atom_ExpressionNodeLabelsAndPropertyLookup(context, (None) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAtomRule()) {
					sequence_Atom(context, (None) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRemoveItemRule()
						|| rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_Atom_PropertyExpression(context, (None) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.NULL_CONSTANT:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getExpressionOrRule()
						|| action == grammarAccess.getExpressionOrAccess().getExpressionOrLeftAction_1_0()
						|| rule == grammarAccess.getExpressionXorRule()
						|| action == grammarAccess.getExpressionXorAccess().getExpressionXorLeftAction_1_0()
						|| rule == grammarAccess.getExpressionAndRule()
						|| action == grammarAccess.getExpressionAndAccess().getExpressionAndLeftAction_1_0()
						|| rule == grammarAccess.getExpressionNotRule()
						|| rule == grammarAccess.getExpressionComparisonRule()
						|| action == grammarAccess.getExpressionComparisonAccess().getExpressionComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPlusMinusRule()
						|| action == grammarAccess.getExpressionPlusMinusAccess().getExpressionPlusMinusLeftAction_1_0()
						|| rule == grammarAccess.getExpressionMulDivRule()
						|| action == grammarAccess.getExpressionMulDivAccess().getExpressionMulDivLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPowerRule()
						|| action == grammarAccess.getExpressionPowerAccess().getExpressionPowerLeftAction_1_0()
						|| rule == grammarAccess.getExpressionUnaryPlusMinusRule()
						|| rule == grammarAccess.getExpression3Rule()) {
					sequence_Atom_Expression3_ExpressionNodeLabelsAndPropertyLookup(context, (NullConstant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionNodeLabelsAndPropertyLookupRule()
						|| action == grammarAccess.getExpressionNodeLabelsAndPropertyLookupAccess().getExpressionNodeLabelsAndPropertyLookupLeftAction_1_0_0()) {
					sequence_Atom_ExpressionNodeLabelsAndPropertyLookup(context, (NullConstant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAtomRule()) {
					sequence_Atom(context, (NullConstant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRemoveItemRule()
						|| rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_Atom_PropertyExpression(context, (NullConstant) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.NUMBER_CONSTANT:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getExpressionOrRule()
						|| action == grammarAccess.getExpressionOrAccess().getExpressionOrLeftAction_1_0()
						|| rule == grammarAccess.getExpressionXorRule()
						|| action == grammarAccess.getExpressionXorAccess().getExpressionXorLeftAction_1_0()
						|| rule == grammarAccess.getExpressionAndRule()
						|| action == grammarAccess.getExpressionAndAccess().getExpressionAndLeftAction_1_0()
						|| rule == grammarAccess.getExpressionNotRule()
						|| rule == grammarAccess.getExpressionComparisonRule()
						|| action == grammarAccess.getExpressionComparisonAccess().getExpressionComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPlusMinusRule()
						|| action == grammarAccess.getExpressionPlusMinusAccess().getExpressionPlusMinusLeftAction_1_0()
						|| rule == grammarAccess.getExpressionMulDivRule()
						|| action == grammarAccess.getExpressionMulDivAccess().getExpressionMulDivLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPowerRule()
						|| action == grammarAccess.getExpressionPowerAccess().getExpressionPowerLeftAction_1_0()
						|| rule == grammarAccess.getExpressionUnaryPlusMinusRule()
						|| rule == grammarAccess.getExpression3Rule()) {
					sequence_Atom_Expression3_ExpressionNodeLabelsAndPropertyLookup(context, (NumberConstant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionNodeLabelsAndPropertyLookupRule()
						|| action == grammarAccess.getExpressionNodeLabelsAndPropertyLookupAccess().getExpressionNodeLabelsAndPropertyLookupLeftAction_1_0_0()) {
					sequence_Atom_ExpressionNodeLabelsAndPropertyLookup(context, (NumberConstant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAtomRule()) {
					sequence_Atom(context, (NumberConstant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRemoveItemRule()
						|| rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_Atom_PropertyExpression(context, (NumberConstant) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.ORDER:
				sequence_Order(context, (Order) semanticObject); 
				return; 
			case OpenCypherPackage.PARAMETER:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getExpressionOrRule()
						|| action == grammarAccess.getExpressionOrAccess().getExpressionOrLeftAction_1_0()
						|| rule == grammarAccess.getExpressionXorRule()
						|| action == grammarAccess.getExpressionXorAccess().getExpressionXorLeftAction_1_0()
						|| rule == grammarAccess.getExpressionAndRule()
						|| action == grammarAccess.getExpressionAndAccess().getExpressionAndLeftAction_1_0()
						|| rule == grammarAccess.getExpressionNotRule()
						|| rule == grammarAccess.getExpressionComparisonRule()
						|| action == grammarAccess.getExpressionComparisonAccess().getExpressionComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPlusMinusRule()
						|| action == grammarAccess.getExpressionPlusMinusAccess().getExpressionPlusMinusLeftAction_1_0()
						|| rule == grammarAccess.getExpressionMulDivRule()
						|| action == grammarAccess.getExpressionMulDivAccess().getExpressionMulDivLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPowerRule()
						|| action == grammarAccess.getExpressionPowerAccess().getExpressionPowerLeftAction_1_0()
						|| rule == grammarAccess.getExpressionUnaryPlusMinusRule()
						|| rule == grammarAccess.getExpression3Rule()) {
					sequence_Expression3_ExpressionNodeLabelsAndPropertyLookup_Parameter(context, (org.slizaa.neo4j.opencypher.openCypher.Parameter) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionNodeLabelsAndPropertyLookupRule()
						|| action == grammarAccess.getExpressionNodeLabelsAndPropertyLookupAccess().getExpressionNodeLabelsAndPropertyLookupLeftAction_1_0_0()) {
					sequence_ExpressionNodeLabelsAndPropertyLookup_Parameter(context, (org.slizaa.neo4j.opencypher.openCypher.Parameter) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPropertiesRule()
						|| rule == grammarAccess.getAtomRule()
						|| rule == grammarAccess.getParameterRule()) {
					sequence_Parameter(context, (org.slizaa.neo4j.opencypher.openCypher.Parameter) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRemoveItemRule()
						|| rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_Parameter_PropertyExpression(context, (org.slizaa.neo4j.opencypher.openCypher.Parameter) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.PARENTHESIZED_EXPRESSION:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getExpressionOrRule()
						|| action == grammarAccess.getExpressionOrAccess().getExpressionOrLeftAction_1_0()
						|| rule == grammarAccess.getExpressionXorRule()
						|| action == grammarAccess.getExpressionXorAccess().getExpressionXorLeftAction_1_0()
						|| rule == grammarAccess.getExpressionAndRule()
						|| action == grammarAccess.getExpressionAndAccess().getExpressionAndLeftAction_1_0()
						|| rule == grammarAccess.getExpressionNotRule()
						|| rule == grammarAccess.getExpressionComparisonRule()
						|| action == grammarAccess.getExpressionComparisonAccess().getExpressionComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPlusMinusRule()
						|| action == grammarAccess.getExpressionPlusMinusAccess().getExpressionPlusMinusLeftAction_1_0()
						|| rule == grammarAccess.getExpressionMulDivRule()
						|| action == grammarAccess.getExpressionMulDivAccess().getExpressionMulDivLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPowerRule()
						|| action == grammarAccess.getExpressionPowerAccess().getExpressionPowerLeftAction_1_0()
						|| rule == grammarAccess.getExpressionUnaryPlusMinusRule()
						|| rule == grammarAccess.getExpression3Rule()) {
					sequence_Expression3_ExpressionNodeLabelsAndPropertyLookup_ParenthesizedExpression(context, (ParenthesizedExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionNodeLabelsAndPropertyLookupRule()
						|| action == grammarAccess.getExpressionNodeLabelsAndPropertyLookupAccess().getExpressionNodeLabelsAndPropertyLookupLeftAction_1_0_0()) {
					sequence_ExpressionNodeLabelsAndPropertyLookup_ParenthesizedExpression(context, (ParenthesizedExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAtomRule()
						|| rule == grammarAccess.getParenthesizedExpressionRule()) {
					sequence_ParenthesizedExpression(context, (ParenthesizedExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRemoveItemRule()
						|| rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_ParenthesizedExpression_PropertyExpression(context, (ParenthesizedExpression) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.PATTERN:
				sequence_Pattern(context, (Pattern) semanticObject); 
				return; 
			case OpenCypherPackage.PATTERN_ELEMENT:
				sequence_PatternElement(context, (PatternElement) semanticObject); 
				return; 
			case OpenCypherPackage.PATTERN_ELEMENT_CHAIN:
				sequence_PatternElementChain(context, (PatternElementChain) semanticObject); 
				return; 
			case OpenCypherPackage.PATTERN_PART:
				sequence_PatternPart(context, (PatternPart) semanticObject); 
				return; 
			case OpenCypherPackage.PERIODIC_COMMIT_HINT:
				sequence_PeriodicCommitHint(context, (PeriodicCommitHint) semanticObject); 
				return; 
			case OpenCypherPackage.PROPERTY_LOOKUP:
				sequence_PropertyLookup(context, (PropertyLookup) semanticObject); 
				return; 
			case OpenCypherPackage.RANGE_LITERAL:
				sequence_RangeLiteral(context, (RangeLiteral) semanticObject); 
				return; 
			case OpenCypherPackage.REDUCE:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getExpressionOrRule()
						|| action == grammarAccess.getExpressionOrAccess().getExpressionOrLeftAction_1_0()
						|| rule == grammarAccess.getExpressionXorRule()
						|| action == grammarAccess.getExpressionXorAccess().getExpressionXorLeftAction_1_0()
						|| rule == grammarAccess.getExpressionAndRule()
						|| action == grammarAccess.getExpressionAndAccess().getExpressionAndLeftAction_1_0()
						|| rule == grammarAccess.getExpressionNotRule()
						|| rule == grammarAccess.getExpressionComparisonRule()
						|| action == grammarAccess.getExpressionComparisonAccess().getExpressionComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPlusMinusRule()
						|| action == grammarAccess.getExpressionPlusMinusAccess().getExpressionPlusMinusLeftAction_1_0()
						|| rule == grammarAccess.getExpressionMulDivRule()
						|| action == grammarAccess.getExpressionMulDivAccess().getExpressionMulDivLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPowerRule()
						|| action == grammarAccess.getExpressionPowerAccess().getExpressionPowerLeftAction_1_0()
						|| rule == grammarAccess.getExpressionUnaryPlusMinusRule()
						|| rule == grammarAccess.getExpression3Rule()) {
					sequence_Expression3_ExpressionNodeLabelsAndPropertyLookup_Reduce(context, (Reduce) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionNodeLabelsAndPropertyLookupRule()
						|| action == grammarAccess.getExpressionNodeLabelsAndPropertyLookupAccess().getExpressionNodeLabelsAndPropertyLookupLeftAction_1_0_0()) {
					sequence_ExpressionNodeLabelsAndPropertyLookup_Reduce(context, (Reduce) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRemoveItemRule()
						|| rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_PropertyExpression_Reduce(context, (Reduce) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAtomRule()
						|| rule == grammarAccess.getReduceRule()) {
					sequence_Reduce(context, (Reduce) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.REG_EXP_MATCHING:
				sequence_Expression3Part(context, (RegExpMatching) semanticObject); 
				return; 
			case OpenCypherPackage.REGULAR_QUERY:
				sequence_RegularQuery(context, (RegularQuery) semanticObject); 
				return; 
			case OpenCypherPackage.RELATIONSHIP_DETAIL:
				sequence_RelationshipDetail(context, (RelationshipDetail) semanticObject); 
				return; 
			case OpenCypherPackage.RELATIONSHIP_PATTERN:
				sequence_RelationshipPattern(context, (RelationshipPattern) semanticObject); 
				return; 
			case OpenCypherPackage.RELATIONSHIP_PATTERN_SYNTAX:
				sequence_RelationshipPatternSyntax(context, (RelationshipPatternSyntax) semanticObject); 
				return; 
			case OpenCypherPackage.RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT:
				sequence_RelationshipPropertyExistenceConstraint(context, (RelationshipPropertyExistenceConstraint) semanticObject); 
				return; 
			case OpenCypherPackage.RELATIONSHIP_TYPES:
				sequence_RelationshipTypes(context, (RelationshipTypes) semanticObject); 
				return; 
			case OpenCypherPackage.RELATIONSHIPS_PATTERN:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getExpressionOrRule()
						|| action == grammarAccess.getExpressionOrAccess().getExpressionOrLeftAction_1_0()
						|| rule == grammarAccess.getExpressionXorRule()
						|| action == grammarAccess.getExpressionXorAccess().getExpressionXorLeftAction_1_0()
						|| rule == grammarAccess.getExpressionAndRule()
						|| action == grammarAccess.getExpressionAndAccess().getExpressionAndLeftAction_1_0()
						|| rule == grammarAccess.getExpressionNotRule()
						|| rule == grammarAccess.getExpressionComparisonRule()
						|| action == grammarAccess.getExpressionComparisonAccess().getExpressionComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPlusMinusRule()
						|| action == grammarAccess.getExpressionPlusMinusAccess().getExpressionPlusMinusLeftAction_1_0()
						|| rule == grammarAccess.getExpressionMulDivRule()
						|| action == grammarAccess.getExpressionMulDivAccess().getExpressionMulDivLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPowerRule()
						|| action == grammarAccess.getExpressionPowerAccess().getExpressionPowerLeftAction_1_0()
						|| rule == grammarAccess.getExpressionUnaryPlusMinusRule()
						|| rule == grammarAccess.getExpression3Rule()) {
					sequence_Expression3_ExpressionNodeLabelsAndPropertyLookup_RelationshipsPattern(context, (RelationshipsPattern) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionNodeLabelsAndPropertyLookupRule()
						|| action == grammarAccess.getExpressionNodeLabelsAndPropertyLookupAccess().getExpressionNodeLabelsAndPropertyLookupLeftAction_1_0_0()) {
					sequence_ExpressionNodeLabelsAndPropertyLookup_RelationshipsPattern(context, (RelationshipsPattern) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRemoveItemRule()
						|| rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_PropertyExpression_RelationshipsPattern(context, (RelationshipsPattern) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAtomRule()
						|| rule == grammarAccess.getRelationshipsPatternRule()) {
					sequence_RelationshipsPattern(context, (RelationshipsPattern) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.REMOVE:
				sequence_Remove(context, (Remove) semanticObject); 
				return; 
			case OpenCypherPackage.REMOVE_ITEM:
				sequence_RemoveItem(context, (RemoveItem) semanticObject); 
				return; 
			case OpenCypherPackage.RETURN:
				sequence_Return(context, (Return) semanticObject); 
				return; 
			case OpenCypherPackage.RETURN_ITEM:
				sequence_ReturnItem(context, (ReturnItem) semanticObject); 
				return; 
			case OpenCypherPackage.RETURN_ITEMS:
				if (rule == grammarAccess.getReturnBodyRule()) {
					sequence_ReturnBody_ReturnItems(context, (ReturnItems) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getReturnItemsRule()) {
					sequence_ReturnItems(context, (ReturnItems) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.SCAN_HINT:
				sequence_Hint(context, (ScanHint) semanticObject); 
				return; 
			case OpenCypherPackage.SET:
				sequence_Set(context, (org.slizaa.neo4j.opencypher.openCypher.Set) semanticObject); 
				return; 
			case OpenCypherPackage.SET_ITEM:
				sequence_SetItem(context, (SetItem) semanticObject); 
				return; 
			case OpenCypherPackage.SHORTEST_PATH:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getExpressionOrRule()
						|| action == grammarAccess.getExpressionOrAccess().getExpressionOrLeftAction_1_0()
						|| rule == grammarAccess.getExpressionXorRule()
						|| action == grammarAccess.getExpressionXorAccess().getExpressionXorLeftAction_1_0()
						|| rule == grammarAccess.getExpressionAndRule()
						|| action == grammarAccess.getExpressionAndAccess().getExpressionAndLeftAction_1_0()
						|| rule == grammarAccess.getExpressionNotRule()
						|| rule == grammarAccess.getExpressionComparisonRule()
						|| action == grammarAccess.getExpressionComparisonAccess().getExpressionComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPlusMinusRule()
						|| action == grammarAccess.getExpressionPlusMinusAccess().getExpressionPlusMinusLeftAction_1_0()
						|| rule == grammarAccess.getExpressionMulDivRule()
						|| action == grammarAccess.getExpressionMulDivAccess().getExpressionMulDivLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPowerRule()
						|| action == grammarAccess.getExpressionPowerAccess().getExpressionPowerLeftAction_1_0()
						|| rule == grammarAccess.getExpressionUnaryPlusMinusRule()
						|| rule == grammarAccess.getExpression3Rule()) {
					sequence_Expression3_ExpressionNodeLabelsAndPropertyLookup_ShortestPathPattern(context, (ShortestPath) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionNodeLabelsAndPropertyLookupRule()
						|| action == grammarAccess.getExpressionNodeLabelsAndPropertyLookupAccess().getExpressionNodeLabelsAndPropertyLookupLeftAction_1_0_0()) {
					sequence_ExpressionNodeLabelsAndPropertyLookup_ShortestPathPattern(context, (ShortestPath) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRemoveItemRule()
						|| rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_PropertyExpression_ShortestPathPattern(context, (ShortestPath) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPatternPartRule()
						|| rule == grammarAccess.getAnonymousPatternPartRule()
						|| rule == grammarAccess.getShortestPathPatternRule()
						|| rule == grammarAccess.getAtomRule()) {
					sequence_ShortestPathPattern(context, (ShortestPath) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.SINGLE:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getExpressionOrRule()
						|| action == grammarAccess.getExpressionOrAccess().getExpressionOrLeftAction_1_0()
						|| rule == grammarAccess.getExpressionXorRule()
						|| action == grammarAccess.getExpressionXorAccess().getExpressionXorLeftAction_1_0()
						|| rule == grammarAccess.getExpressionAndRule()
						|| action == grammarAccess.getExpressionAndAccess().getExpressionAndLeftAction_1_0()
						|| rule == grammarAccess.getExpressionNotRule()
						|| rule == grammarAccess.getExpressionComparisonRule()
						|| action == grammarAccess.getExpressionComparisonAccess().getExpressionComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPlusMinusRule()
						|| action == grammarAccess.getExpressionPlusMinusAccess().getExpressionPlusMinusLeftAction_1_0()
						|| rule == grammarAccess.getExpressionMulDivRule()
						|| action == grammarAccess.getExpressionMulDivAccess().getExpressionMulDivLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPowerRule()
						|| action == grammarAccess.getExpressionPowerAccess().getExpressionPowerLeftAction_1_0()
						|| rule == grammarAccess.getExpressionUnaryPlusMinusRule()
						|| rule == grammarAccess.getExpression3Rule()) {
					sequence_Atom_Expression3_ExpressionNodeLabelsAndPropertyLookup(context, (Single) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionNodeLabelsAndPropertyLookupRule()
						|| action == grammarAccess.getExpressionNodeLabelsAndPropertyLookupAccess().getExpressionNodeLabelsAndPropertyLookupLeftAction_1_0_0()) {
					sequence_Atom_ExpressionNodeLabelsAndPropertyLookup(context, (Single) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRemoveItemRule()
						|| rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_Atom_PropertyExpression(context, (Single) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAtomRule()) {
					sequence_Atom(context, (Single) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.SINGLE_QUERY:
				sequence_SingleQuery(context, (SingleQuery) semanticObject); 
				return; 
			case OpenCypherPackage.SKIP:
				sequence_Skip(context, (Skip) semanticObject); 
				return; 
			case OpenCypherPackage.SORT_ITEM:
				sequence_SortItem(context, (SortItem) semanticObject); 
				return; 
			case OpenCypherPackage.START:
				sequence_Start(context, (Start) semanticObject); 
				return; 
			case OpenCypherPackage.START_POINT:
				sequence_StartPoint(context, (StartPoint) semanticObject); 
				return; 
			case OpenCypherPackage.STARTS_WITH:
				sequence_Expression3Part(context, (StartsWith) semanticObject); 
				return; 
			case OpenCypherPackage.STRING_CONSTANT:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getExpressionOrRule()
						|| action == grammarAccess.getExpressionOrAccess().getExpressionOrLeftAction_1_0()
						|| rule == grammarAccess.getExpressionXorRule()
						|| action == grammarAccess.getExpressionXorAccess().getExpressionXorLeftAction_1_0()
						|| rule == grammarAccess.getExpressionAndRule()
						|| action == grammarAccess.getExpressionAndAccess().getExpressionAndLeftAction_1_0()
						|| rule == grammarAccess.getExpressionNotRule()
						|| rule == grammarAccess.getExpressionComparisonRule()
						|| action == grammarAccess.getExpressionComparisonAccess().getExpressionComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPlusMinusRule()
						|| action == grammarAccess.getExpressionPlusMinusAccess().getExpressionPlusMinusLeftAction_1_0()
						|| rule == grammarAccess.getExpressionMulDivRule()
						|| action == grammarAccess.getExpressionMulDivAccess().getExpressionMulDivLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPowerRule()
						|| action == grammarAccess.getExpressionPowerAccess().getExpressionPowerLeftAction_1_0()
						|| rule == grammarAccess.getExpressionUnaryPlusMinusRule()
						|| rule == grammarAccess.getExpression3Rule()) {
					sequence_Atom_Expression3_ExpressionNodeLabelsAndPropertyLookup(context, (StringConstant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionNodeLabelsAndPropertyLookupRule()
						|| action == grammarAccess.getExpressionNodeLabelsAndPropertyLookupAccess().getExpressionNodeLabelsAndPropertyLookupLeftAction_1_0_0()) {
					sequence_Atom_ExpressionNodeLabelsAndPropertyLookup(context, (StringConstant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRemoveItemRule()
						|| rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_Atom_PropertyExpression(context, (StringConstant) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAtomRule()) {
					sequence_Atom(context, (StringConstant) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.UNION:
				sequence_Union(context, (Union) semanticObject); 
				return; 
			case OpenCypherPackage.UNIQUE_CONSTRAINT:
				sequence_UniqueConstraint(context, (UniqueConstraint) semanticObject); 
				return; 
			case OpenCypherPackage.UNWIND:
				sequence_Unwind(context, (Unwind) semanticObject); 
				return; 
			case OpenCypherPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case OpenCypherPackage.VARIABLE_REF:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getExpressionOrRule()
						|| action == grammarAccess.getExpressionOrAccess().getExpressionOrLeftAction_1_0()
						|| rule == grammarAccess.getExpressionXorRule()
						|| action == grammarAccess.getExpressionXorAccess().getExpressionXorLeftAction_1_0()
						|| rule == grammarAccess.getExpressionAndRule()
						|| action == grammarAccess.getExpressionAndAccess().getExpressionAndLeftAction_1_0()
						|| rule == grammarAccess.getExpressionNotRule()
						|| rule == grammarAccess.getExpressionComparisonRule()
						|| action == grammarAccess.getExpressionComparisonAccess().getExpressionComparisonLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPlusMinusRule()
						|| action == grammarAccess.getExpressionPlusMinusAccess().getExpressionPlusMinusLeftAction_1_0()
						|| rule == grammarAccess.getExpressionMulDivRule()
						|| action == grammarAccess.getExpressionMulDivAccess().getExpressionMulDivLeftAction_1_0()
						|| rule == grammarAccess.getExpressionPowerRule()
						|| action == grammarAccess.getExpressionPowerAccess().getExpressionPowerLeftAction_1_0()
						|| rule == grammarAccess.getExpressionUnaryPlusMinusRule()
						|| rule == grammarAccess.getExpression3Rule()) {
					sequence_Atom_Expression3_ExpressionNodeLabelsAndPropertyLookup(context, (VariableRef) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionNodeLabelsAndPropertyLookupRule()
						|| action == grammarAccess.getExpressionNodeLabelsAndPropertyLookupAccess().getExpressionNodeLabelsAndPropertyLookupLeftAction_1_0_0()) {
					sequence_Atom_ExpressionNodeLabelsAndPropertyLookup(context, (VariableRef) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRemoveItemRule()
						|| rule == grammarAccess.getPropertyExpressionRule()) {
					sequence_Atom_PropertyExpression(context, (VariableRef) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAtomRule()) {
					sequence_Atom(context, (VariableRef) semanticObject); 
					return; 
				}
				else break;
			case OpenCypherPackage.VERSION_NUMBER:
				sequence_VersionNumber(context, (VersionNumber) semanticObject); 
				return; 
			case OpenCypherPackage.WHERE:
				sequence_Where(context, (Where) semanticObject); 
				return; 
			case OpenCypherPackage.WITH:
				sequence_With(context, (With) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Atom returns All
	 *
	 * Constraint:
	 *     filterExpression=FilterExpression
	 */
	protected void sequence_Atom(ISerializationContext context, All semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.ALL__FILTER_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.ALL__FILTER_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomAccess().getFilterExpressionFilterExpressionParserRuleCall_14_3_0(), semanticObject.getFilterExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Atom returns Any
	 *
	 * Constraint:
	 *     filterExpression=FilterExpression
	 */
	protected void sequence_Atom(ISerializationContext context, Any semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.ANY__FILTER_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.ANY__FILTER_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomAccess().getFilterExpressionFilterExpressionParserRuleCall_15_3_0(), semanticObject.getFilterExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Atom returns BoolConstant
	 *
	 * Constraint:
	 *     (value='TRUE' | value='FALSE')
	 */
	protected void sequence_Atom(ISerializationContext context, BoolConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Atom returns CaseExpression
	 *
	 * Constraint:
	 *     expression=CaseExpression
	 */
	protected void sequence_Atom(ISerializationContext context, CaseExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.CASE_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.CASE_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomAccess().getExpressionCaseExpressionParserRuleCall_6_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Atom returns Count
	 *
	 * Constraint:
	 *     {Count}
	 */
	protected void sequence_Atom(ISerializationContext context, Count semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns All
	 *     ExpressionOr returns All
	 *     ExpressionOr.ExpressionOr_1_0 returns All
	 *     ExpressionXor returns All
	 *     ExpressionXor.ExpressionXor_1_0 returns All
	 *     ExpressionAnd returns All
	 *     ExpressionAnd.ExpressionAnd_1_0 returns All
	 *     ExpressionNot returns All
	 *     ExpressionComparison returns All
	 *     ExpressionComparison.ExpressionComparison_1_0 returns All
	 *     ExpressionPlusMinus returns All
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns All
	 *     ExpressionMulDiv returns All
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns All
	 *     ExpressionPower returns All
	 *     ExpressionPower.ExpressionPower_1_0 returns All
	 *     ExpressionUnaryPlusMinus returns All
	 *     Expression3 returns All
	 *
	 * Constraint:
	 *     (filterExpression=FilterExpression nodeLabelList+=NodeLabel* expression3Parts+=Expression3Part*)
	 */
	protected void sequence_Atom_Expression3_ExpressionNodeLabelsAndPropertyLookup(ISerializationContext context, All semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Any
	 *     ExpressionOr returns Any
	 *     ExpressionOr.ExpressionOr_1_0 returns Any
	 *     ExpressionXor returns Any
	 *     ExpressionXor.ExpressionXor_1_0 returns Any
	 *     ExpressionAnd returns Any
	 *     ExpressionAnd.ExpressionAnd_1_0 returns Any
	 *     ExpressionNot returns Any
	 *     ExpressionComparison returns Any
	 *     ExpressionComparison.ExpressionComparison_1_0 returns Any
	 *     ExpressionPlusMinus returns Any
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns Any
	 *     ExpressionMulDiv returns Any
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns Any
	 *     ExpressionPower returns Any
	 *     ExpressionPower.ExpressionPower_1_0 returns Any
	 *     ExpressionUnaryPlusMinus returns Any
	 *     Expression3 returns Any
	 *
	 * Constraint:
	 *     (filterExpression=FilterExpression nodeLabelList+=NodeLabel* expression3Parts+=Expression3Part*)
	 */
	protected void sequence_Atom_Expression3_ExpressionNodeLabelsAndPropertyLookup(ISerializationContext context, Any semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BoolConstant
	 *     ExpressionOr returns BoolConstant
	 *     ExpressionOr.ExpressionOr_1_0 returns BoolConstant
	 *     ExpressionXor returns BoolConstant
	 *     ExpressionXor.ExpressionXor_1_0 returns BoolConstant
	 *     ExpressionAnd returns BoolConstant
	 *     ExpressionAnd.ExpressionAnd_1_0 returns BoolConstant
	 *     ExpressionNot returns BoolConstant
	 *     ExpressionComparison returns BoolConstant
	 *     ExpressionComparison.ExpressionComparison_1_0 returns BoolConstant
	 *     ExpressionPlusMinus returns BoolConstant
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns BoolConstant
	 *     ExpressionMulDiv returns BoolConstant
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns BoolConstant
	 *     ExpressionPower returns BoolConstant
	 *     ExpressionPower.ExpressionPower_1_0 returns BoolConstant
	 *     ExpressionUnaryPlusMinus returns BoolConstant
	 *     Expression3 returns BoolConstant
	 *
	 * Constraint:
	 *     ((value='TRUE' | value='FALSE') nodeLabelList+=NodeLabel* expression3Parts+=Expression3Part*)
	 */
	protected void sequence_Atom_Expression3_ExpressionNodeLabelsAndPropertyLookup(ISerializationContext context, BoolConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns CaseExpression
	 *     ExpressionOr returns CaseExpression
	 *     ExpressionOr.ExpressionOr_1_0 returns CaseExpression
	 *     ExpressionXor returns CaseExpression
	 *     ExpressionXor.ExpressionXor_1_0 returns CaseExpression
	 *     ExpressionAnd returns CaseExpression
	 *     ExpressionAnd.ExpressionAnd_1_0 returns CaseExpression
	 *     ExpressionNot returns CaseExpression
	 *     ExpressionComparison returns CaseExpression
	 *     ExpressionComparison.ExpressionComparison_1_0 returns CaseExpression
	 *     ExpressionPlusMinus returns CaseExpression
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns CaseExpression
	 *     ExpressionMulDiv returns CaseExpression
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns CaseExpression
	 *     ExpressionPower returns CaseExpression
	 *     ExpressionPower.ExpressionPower_1_0 returns CaseExpression
	 *     ExpressionUnaryPlusMinus returns CaseExpression
	 *     Expression3 returns CaseExpression
	 *
	 * Constraint:
	 *     (expression=CaseExpression nodeLabelList+=NodeLabel* expression3Parts+=Expression3Part*)
	 */
	protected void sequence_Atom_Expression3_ExpressionNodeLabelsAndPropertyLookup(ISerializationContext context, CaseExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Count
	 *     ExpressionOr returns Count
	 *     ExpressionOr.ExpressionOr_1_0 returns Count
	 *     ExpressionXor returns Count
	 *     ExpressionXor.ExpressionXor_1_0 returns Count
	 *     ExpressionAnd returns Count
	 *     ExpressionAnd.ExpressionAnd_1_0 returns Count
	 *     ExpressionNot returns Count
	 *     ExpressionComparison returns Count
	 *     ExpressionComparison.ExpressionComparison_1_0 returns Count
	 *     ExpressionPlusMinus returns Count
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns Count
	 *     ExpressionMulDiv returns Count
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns Count
	 *     ExpressionPower returns Count
	 *     ExpressionPower.ExpressionPower_1_0 returns Count
	 *     ExpressionUnaryPlusMinus returns Count
	 *     Expression3 returns Count
	 *
	 * Constraint:
	 *     (nodeLabelList+=NodeLabel* expression3Parts+=Expression3Part*)
	 */
	protected void sequence_Atom_Expression3_ExpressionNodeLabelsAndPropertyLookup(ISerializationContext context, Count semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionList
	 *     ExpressionOr returns ExpressionList
	 *     ExpressionOr.ExpressionOr_1_0 returns ExpressionList
	 *     ExpressionXor returns ExpressionList
	 *     ExpressionXor.ExpressionXor_1_0 returns ExpressionList
	 *     ExpressionAnd returns ExpressionList
	 *     ExpressionAnd.ExpressionAnd_1_0 returns ExpressionList
	 *     ExpressionNot returns ExpressionList
	 *     ExpressionComparison returns ExpressionList
	 *     ExpressionComparison.ExpressionComparison_1_0 returns ExpressionList
	 *     ExpressionPlusMinus returns ExpressionList
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns ExpressionList
	 *     ExpressionMulDiv returns ExpressionList
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns ExpressionList
	 *     ExpressionPower returns ExpressionList
	 *     ExpressionPower.ExpressionPower_1_0 returns ExpressionList
	 *     ExpressionUnaryPlusMinus returns ExpressionList
	 *     Expression3 returns ExpressionList
	 *
	 * Constraint:
	 *     (expressions+=Expression expressions+=Expression* nodeLabelList+=NodeLabel* expression3Parts+=Expression3Part*)
	 */
	protected void sequence_Atom_Expression3_ExpressionNodeLabelsAndPropertyLookup(ISerializationContext context, ExpressionList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Filter
	 *     ExpressionOr returns Filter
	 *     ExpressionOr.ExpressionOr_1_0 returns Filter
	 *     ExpressionXor returns Filter
	 *     ExpressionXor.ExpressionXor_1_0 returns Filter
	 *     ExpressionAnd returns Filter
	 *     ExpressionAnd.ExpressionAnd_1_0 returns Filter
	 *     ExpressionNot returns Filter
	 *     ExpressionComparison returns Filter
	 *     ExpressionComparison.ExpressionComparison_1_0 returns Filter
	 *     ExpressionPlusMinus returns Filter
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns Filter
	 *     ExpressionMulDiv returns Filter
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns Filter
	 *     ExpressionPower returns Filter
	 *     ExpressionPower.ExpressionPower_1_0 returns Filter
	 *     ExpressionUnaryPlusMinus returns Filter
	 *     Expression3 returns Filter
	 *
	 * Constraint:
	 *     (
	 *         ((filterExpression=FilterExpression expression=Expression?) | filterExpression=FilterExpression) 
	 *         nodeLabelList+=NodeLabel* 
	 *         expression3Parts+=Expression3Part*
	 *     )
	 */
	protected void sequence_Atom_Expression3_ExpressionNodeLabelsAndPropertyLookup(ISerializationContext context, Filter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns None
	 *     ExpressionOr returns None
	 *     ExpressionOr.ExpressionOr_1_0 returns None
	 *     ExpressionXor returns None
	 *     ExpressionXor.ExpressionXor_1_0 returns None
	 *     ExpressionAnd returns None
	 *     ExpressionAnd.ExpressionAnd_1_0 returns None
	 *     ExpressionNot returns None
	 *     ExpressionComparison returns None
	 *     ExpressionComparison.ExpressionComparison_1_0 returns None
	 *     ExpressionPlusMinus returns None
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns None
	 *     ExpressionMulDiv returns None
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns None
	 *     ExpressionPower returns None
	 *     ExpressionPower.ExpressionPower_1_0 returns None
	 *     ExpressionUnaryPlusMinus returns None
	 *     Expression3 returns None
	 *
	 * Constraint:
	 *     (filterExpression=FilterExpression nodeLabelList+=NodeLabel* expression3Parts+=Expression3Part*)
	 */
	protected void sequence_Atom_Expression3_ExpressionNodeLabelsAndPropertyLookup(ISerializationContext context, None semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NullConstant
	 *     ExpressionOr returns NullConstant
	 *     ExpressionOr.ExpressionOr_1_0 returns NullConstant
	 *     ExpressionXor returns NullConstant
	 *     ExpressionXor.ExpressionXor_1_0 returns NullConstant
	 *     ExpressionAnd returns NullConstant
	 *     ExpressionAnd.ExpressionAnd_1_0 returns NullConstant
	 *     ExpressionNot returns NullConstant
	 *     ExpressionComparison returns NullConstant
	 *     ExpressionComparison.ExpressionComparison_1_0 returns NullConstant
	 *     ExpressionPlusMinus returns NullConstant
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns NullConstant
	 *     ExpressionMulDiv returns NullConstant
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns NullConstant
	 *     ExpressionPower returns NullConstant
	 *     ExpressionPower.ExpressionPower_1_0 returns NullConstant
	 *     ExpressionUnaryPlusMinus returns NullConstant
	 *     Expression3 returns NullConstant
	 *
	 * Constraint:
	 *     (nodeLabelList+=NodeLabel* expression3Parts+=Expression3Part*)
	 */
	protected void sequence_Atom_Expression3_ExpressionNodeLabelsAndPropertyLookup(ISerializationContext context, NullConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NumberConstant
	 *     ExpressionOr returns NumberConstant
	 *     ExpressionOr.ExpressionOr_1_0 returns NumberConstant
	 *     ExpressionXor returns NumberConstant
	 *     ExpressionXor.ExpressionXor_1_0 returns NumberConstant
	 *     ExpressionAnd returns NumberConstant
	 *     ExpressionAnd.ExpressionAnd_1_0 returns NumberConstant
	 *     ExpressionNot returns NumberConstant
	 *     ExpressionComparison returns NumberConstant
	 *     ExpressionComparison.ExpressionComparison_1_0 returns NumberConstant
	 *     ExpressionPlusMinus returns NumberConstant
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns NumberConstant
	 *     ExpressionMulDiv returns NumberConstant
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns NumberConstant
	 *     ExpressionPower returns NumberConstant
	 *     ExpressionPower.ExpressionPower_1_0 returns NumberConstant
	 *     ExpressionUnaryPlusMinus returns NumberConstant
	 *     Expression3 returns NumberConstant
	 *
	 * Constraint:
	 *     (value=Number nodeLabelList+=NodeLabel* expression3Parts+=Expression3Part*)
	 */
	protected void sequence_Atom_Expression3_ExpressionNodeLabelsAndPropertyLookup(ISerializationContext context, NumberConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Single
	 *     ExpressionOr returns Single
	 *     ExpressionOr.ExpressionOr_1_0 returns Single
	 *     ExpressionXor returns Single
	 *     ExpressionXor.ExpressionXor_1_0 returns Single
	 *     ExpressionAnd returns Single
	 *     ExpressionAnd.ExpressionAnd_1_0 returns Single
	 *     ExpressionNot returns Single
	 *     ExpressionComparison returns Single
	 *     ExpressionComparison.ExpressionComparison_1_0 returns Single
	 *     ExpressionPlusMinus returns Single
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns Single
	 *     ExpressionMulDiv returns Single
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns Single
	 *     ExpressionPower returns Single
	 *     ExpressionPower.ExpressionPower_1_0 returns Single
	 *     ExpressionUnaryPlusMinus returns Single
	 *     Expression3 returns Single
	 *
	 * Constraint:
	 *     (filterExpression=FilterExpression nodeLabelList+=NodeLabel* expression3Parts+=Expression3Part*)
	 */
	protected void sequence_Atom_Expression3_ExpressionNodeLabelsAndPropertyLookup(ISerializationContext context, Single semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns StringConstant
	 *     ExpressionOr returns StringConstant
	 *     ExpressionOr.ExpressionOr_1_0 returns StringConstant
	 *     ExpressionXor returns StringConstant
	 *     ExpressionXor.ExpressionXor_1_0 returns StringConstant
	 *     ExpressionAnd returns StringConstant
	 *     ExpressionAnd.ExpressionAnd_1_0 returns StringConstant
	 *     ExpressionNot returns StringConstant
	 *     ExpressionComparison returns StringConstant
	 *     ExpressionComparison.ExpressionComparison_1_0 returns StringConstant
	 *     ExpressionPlusMinus returns StringConstant
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns StringConstant
	 *     ExpressionMulDiv returns StringConstant
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns StringConstant
	 *     ExpressionPower returns StringConstant
	 *     ExpressionPower.ExpressionPower_1_0 returns StringConstant
	 *     ExpressionUnaryPlusMinus returns StringConstant
	 *     Expression3 returns StringConstant
	 *
	 * Constraint:
	 *     (value=STRING_LITERAL nodeLabelList+=NodeLabel* expression3Parts+=Expression3Part*)
	 */
	protected void sequence_Atom_Expression3_ExpressionNodeLabelsAndPropertyLookup(ISerializationContext context, StringConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns VariableRef
	 *     ExpressionOr returns VariableRef
	 *     ExpressionOr.ExpressionOr_1_0 returns VariableRef
	 *     ExpressionXor returns VariableRef
	 *     ExpressionXor.ExpressionXor_1_0 returns VariableRef
	 *     ExpressionAnd returns VariableRef
	 *     ExpressionAnd.ExpressionAnd_1_0 returns VariableRef
	 *     ExpressionNot returns VariableRef
	 *     ExpressionComparison returns VariableRef
	 *     ExpressionComparison.ExpressionComparison_1_0 returns VariableRef
	 *     ExpressionPlusMinus returns VariableRef
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns VariableRef
	 *     ExpressionMulDiv returns VariableRef
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns VariableRef
	 *     ExpressionPower returns VariableRef
	 *     ExpressionPower.ExpressionPower_1_0 returns VariableRef
	 *     ExpressionUnaryPlusMinus returns VariableRef
	 *     Expression3 returns VariableRef
	 *
	 * Constraint:
	 *     (variableRef=[Variable|SYMBOLIC_NAME_X] nodeLabelList+=NodeLabel* expression3Parts+=Expression3Part*)
	 */
	protected void sequence_Atom_Expression3_ExpressionNodeLabelsAndPropertyLookup(ISerializationContext context, VariableRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Atom returns ExpressionList
	 *
	 * Constraint:
	 *     (expressions+=Expression expressions+=Expression*)
	 */
	protected void sequence_Atom(ISerializationContext context, ExpressionList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionNodeLabelsAndPropertyLookup returns All
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabelsAndPropertyLookup_1_0_0 returns All
	 *
	 * Constraint:
	 *     (filterExpression=FilterExpression nodeLabelList+=NodeLabel*)
	 */
	protected void sequence_Atom_ExpressionNodeLabelsAndPropertyLookup(ISerializationContext context, All semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionNodeLabelsAndPropertyLookup returns Any
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabelsAndPropertyLookup_1_0_0 returns Any
	 *
	 * Constraint:
	 *     (filterExpression=FilterExpression nodeLabelList+=NodeLabel*)
	 */
	protected void sequence_Atom_ExpressionNodeLabelsAndPropertyLookup(ISerializationContext context, Any semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionNodeLabelsAndPropertyLookup returns BoolConstant
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabelsAndPropertyLookup_1_0_0 returns BoolConstant
	 *
	 * Constraint:
	 *     ((value='TRUE' | value='FALSE') nodeLabelList+=NodeLabel*)
	 */
	protected void sequence_Atom_ExpressionNodeLabelsAndPropertyLookup(ISerializationContext context, BoolConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionNodeLabelsAndPropertyLookup returns CaseExpression
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabelsAndPropertyLookup_1_0_0 returns CaseExpression
	 *
	 * Constraint:
	 *     (expression=CaseExpression nodeLabelList+=NodeLabel*)
	 */
	protected void sequence_Atom_ExpressionNodeLabelsAndPropertyLookup(ISerializationContext context, CaseExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionNodeLabelsAndPropertyLookup returns Count
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabelsAndPropertyLookup_1_0_0 returns Count
	 *
	 * Constraint:
	 *     nodeLabelList+=NodeLabel*
	 */
	protected void sequence_Atom_ExpressionNodeLabelsAndPropertyLookup(ISerializationContext context, Count semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionNodeLabelsAndPropertyLookup returns ExpressionList
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabelsAndPropertyLookup_1_0_0 returns ExpressionList
	 *
	 * Constraint:
	 *     (expressions+=Expression expressions+=Expression* nodeLabelList+=NodeLabel*)
	 */
	protected void sequence_Atom_ExpressionNodeLabelsAndPropertyLookup(ISerializationContext context, ExpressionList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionNodeLabelsAndPropertyLookup returns Filter
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabelsAndPropertyLookup_1_0_0 returns Filter
	 *
	 * Constraint:
	 *     (((filterExpression=FilterExpression expression=Expression?) | filterExpression=FilterExpression) nodeLabelList+=NodeLabel*)
	 */
	protected void sequence_Atom_ExpressionNodeLabelsAndPropertyLookup(ISerializationContext context, Filter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionNodeLabelsAndPropertyLookup returns None
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabelsAndPropertyLookup_1_0_0 returns None
	 *
	 * Constraint:
	 *     (filterExpression=FilterExpression nodeLabelList+=NodeLabel*)
	 */
	protected void sequence_Atom_ExpressionNodeLabelsAndPropertyLookup(ISerializationContext context, None semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionNodeLabelsAndPropertyLookup returns NullConstant
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabelsAndPropertyLookup_1_0_0 returns NullConstant
	 *
	 * Constraint:
	 *     nodeLabelList+=NodeLabel*
	 */
	protected void sequence_Atom_ExpressionNodeLabelsAndPropertyLookup(ISerializationContext context, NullConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionNodeLabelsAndPropertyLookup returns NumberConstant
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabelsAndPropertyLookup_1_0_0 returns NumberConstant
	 *
	 * Constraint:
	 *     (value=Number nodeLabelList+=NodeLabel*)
	 */
	protected void sequence_Atom_ExpressionNodeLabelsAndPropertyLookup(ISerializationContext context, NumberConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionNodeLabelsAndPropertyLookup returns Single
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabelsAndPropertyLookup_1_0_0 returns Single
	 *
	 * Constraint:
	 *     (filterExpression=FilterExpression nodeLabelList+=NodeLabel*)
	 */
	protected void sequence_Atom_ExpressionNodeLabelsAndPropertyLookup(ISerializationContext context, Single semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionNodeLabelsAndPropertyLookup returns StringConstant
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabelsAndPropertyLookup_1_0_0 returns StringConstant
	 *
	 * Constraint:
	 *     (value=STRING_LITERAL nodeLabelList+=NodeLabel*)
	 */
	protected void sequence_Atom_ExpressionNodeLabelsAndPropertyLookup(ISerializationContext context, StringConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionNodeLabelsAndPropertyLookup returns VariableRef
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabelsAndPropertyLookup_1_0_0 returns VariableRef
	 *
	 * Constraint:
	 *     (variableRef=[Variable|SYMBOLIC_NAME_X] nodeLabelList+=NodeLabel*)
	 */
	protected void sequence_Atom_ExpressionNodeLabelsAndPropertyLookup(ISerializationContext context, VariableRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Atom returns Filter
	 *
	 * Constraint:
	 *     ((filterExpression=FilterExpression expression=Expression?) | filterExpression=FilterExpression)
	 */
	protected void sequence_Atom(ISerializationContext context, Filter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Atom returns None
	 *
	 * Constraint:
	 *     filterExpression=FilterExpression
	 */
	protected void sequence_Atom(ISerializationContext context, None semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.NONE__FILTER_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.NONE__FILTER_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomAccess().getFilterExpressionFilterExpressionParserRuleCall_16_3_0(), semanticObject.getFilterExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Atom returns NullConstant
	 *
	 * Constraint:
	 *     {NullConstant}
	 */
	protected void sequence_Atom(ISerializationContext context, NullConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Atom returns NumberConstant
	 *
	 * Constraint:
	 *     value=Number
	 */
	protected void sequence_Atom(ISerializationContext context, NumberConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.NUMBER_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.NUMBER_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomAccess().getValueNumberParserRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RemoveItem returns All
	 *     PropertyExpression returns All
	 *
	 * Constraint:
	 *     (filterExpression=FilterExpression propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_Atom_PropertyExpression(ISerializationContext context, All semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RemoveItem returns Any
	 *     PropertyExpression returns Any
	 *
	 * Constraint:
	 *     (filterExpression=FilterExpression propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_Atom_PropertyExpression(ISerializationContext context, Any semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RemoveItem returns BoolConstant
	 *     PropertyExpression returns BoolConstant
	 *
	 * Constraint:
	 *     ((value='TRUE' | value='FALSE') propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_Atom_PropertyExpression(ISerializationContext context, BoolConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RemoveItem returns CaseExpression
	 *     PropertyExpression returns CaseExpression
	 *
	 * Constraint:
	 *     (expression=CaseExpression propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_Atom_PropertyExpression(ISerializationContext context, CaseExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RemoveItem returns Count
	 *     PropertyExpression returns Count
	 *
	 * Constraint:
	 *     propertyLookups+=PropertyLookup+
	 */
	protected void sequence_Atom_PropertyExpression(ISerializationContext context, Count semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RemoveItem returns ExpressionList
	 *     PropertyExpression returns ExpressionList
	 *
	 * Constraint:
	 *     (expressions+=Expression expressions+=Expression* propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_Atom_PropertyExpression(ISerializationContext context, ExpressionList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RemoveItem returns Filter
	 *     PropertyExpression returns Filter
	 *
	 * Constraint:
	 *     (((filterExpression=FilterExpression expression=Expression?) | filterExpression=FilterExpression) propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_Atom_PropertyExpression(ISerializationContext context, Filter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RemoveItem returns None
	 *     PropertyExpression returns None
	 *
	 * Constraint:
	 *     (filterExpression=FilterExpression propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_Atom_PropertyExpression(ISerializationContext context, None semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RemoveItem returns NullConstant
	 *     PropertyExpression returns NullConstant
	 *
	 * Constraint:
	 *     propertyLookups+=PropertyLookup+
	 */
	protected void sequence_Atom_PropertyExpression(ISerializationContext context, NullConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RemoveItem returns NumberConstant
	 *     PropertyExpression returns NumberConstant
	 *
	 * Constraint:
	 *     (value=Number propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_Atom_PropertyExpression(ISerializationContext context, NumberConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RemoveItem returns Single
	 *     PropertyExpression returns Single
	 *
	 * Constraint:
	 *     (filterExpression=FilterExpression propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_Atom_PropertyExpression(ISerializationContext context, Single semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RemoveItem returns StringConstant
	 *     PropertyExpression returns StringConstant
	 *
	 * Constraint:
	 *     (value=STRING_LITERAL propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_Atom_PropertyExpression(ISerializationContext context, StringConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RemoveItem returns VariableRef
	 *     PropertyExpression returns VariableRef
	 *
	 * Constraint:
	 *     (variableRef=[Variable|SYMBOLIC_NAME_X] propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_Atom_PropertyExpression(ISerializationContext context, VariableRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Atom returns Single
	 *
	 * Constraint:
	 *     filterExpression=FilterExpression
	 */
	protected void sequence_Atom(ISerializationContext context, Single semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.SINGLE__FILTER_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.SINGLE__FILTER_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomAccess().getFilterExpressionFilterExpressionParserRuleCall_17_3_0(), semanticObject.getFilterExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Atom returns StringConstant
	 *
	 * Constraint:
	 *     value=STRING_LITERAL
	 */
	protected void sequence_Atom(ISerializationContext context, StringConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.STRING_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.STRING_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomAccess().getValueSTRING_LITERALTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Atom returns VariableRef
	 *
	 * Constraint:
	 *     variableRef=[Variable|SYMBOLIC_NAME_X]
	 */
	protected void sequence_Atom(ISerializationContext context, VariableRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.VARIABLE_REF__VARIABLE_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.VARIABLE_REF__VARIABLE_REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomAccess().getVariableRefVariableSYMBOLIC_NAME_XParserRuleCall_22_1_0_1(), semanticObject.getVariableRef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns BulkImportQuery
	 *     Query returns BulkImportQuery
	 *     BulkImportQuery returns BulkImportQuery
	 *
	 * Constraint:
	 *     (periodicCommitHint=PeriodicCommitHint loadCSVQuery=LoadCSVQuery)
	 */
	protected void sequence_BulkImportQuery(ISerializationContext context, BulkImportQuery semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.BULK_IMPORT_QUERY__PERIODIC_COMMIT_HINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.BULK_IMPORT_QUERY__PERIODIC_COMMIT_HINT));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.BULK_IMPORT_QUERY__LOAD_CSV_QUERY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.BULK_IMPORT_QUERY__LOAD_CSV_QUERY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBulkImportQueryAccess().getPeriodicCommitHintPeriodicCommitHintParserRuleCall_0_0(), semanticObject.getPeriodicCommitHint());
		feeder.accept(grammarAccess.getBulkImportQueryAccess().getLoadCSVQueryLoadCSVQueryParserRuleCall_1_0(), semanticObject.getLoadCSVQuery());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CaseAlternatives returns CaseAlternatives
	 *
	 * Constraint:
	 *     (when=Expression then=Expression)
	 */
	protected void sequence_CaseAlternatives(ISerializationContext context, CaseAlternatives semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.CASE_ALTERNATIVES__WHEN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.CASE_ALTERNATIVES__WHEN));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.CASE_ALTERNATIVES__THEN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.CASE_ALTERNATIVES__THEN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCaseAlternativesAccess().getWhenExpressionParserRuleCall_1_0(), semanticObject.getWhen());
		feeder.accept(grammarAccess.getCaseAlternativesAccess().getThenExpressionParserRuleCall_3_0(), semanticObject.getThen());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CaseExpression returns CaseExpression
	 *
	 * Constraint:
	 *     ((caseAlternatives+=CaseAlternatives+ | (caseExpression=Expression caseAlternatives+=CaseAlternatives+)) elseExpression=Expression?)
	 */
	protected void sequence_CaseExpression(ISerializationContext context, CaseExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConfigurationOption returns ConfigurationOption
	 *
	 * Constraint:
	 *     (key=SYMBOLIC_NAME value=SYMBOLIC_NAME)
	 */
	protected void sequence_ConfigurationOption(ISerializationContext context, ConfigurationOption semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.CONFIGURATION_OPTION__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.CONFIGURATION_OPTION__KEY));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.CONFIGURATION_OPTION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.CONFIGURATION_OPTION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConfigurationOptionAccess().getKeySYMBOLIC_NAMETerminalRuleCall_0_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getConfigurationOptionAccess().getValueSYMBOLIC_NAMETerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns CreateIndex
	 *     Command returns CreateIndex
	 *     CreateIndex returns CreateIndex
	 *
	 * Constraint:
	 *     index=Index
	 */
	protected void sequence_CreateIndex(ISerializationContext context, CreateIndex semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.CREATE_INDEX__INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.CREATE_INDEX__INDEX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCreateIndexAccess().getIndexIndexParserRuleCall_1_0(), semanticObject.getIndex());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns Create
	 *     Create returns Create
	 *
	 * Constraint:
	 *     (unique?='UNIQUE'? pattern=Pattern)
	 */
	protected void sequence_Create(ISerializationContext context, Create semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CypherOption returns CypherOption
	 *
	 * Constraint:
	 *     (versionNumber=VersionNumber? configurationOption+=ConfigurationOption*)
	 */
	protected void sequence_CypherOption(ISerializationContext context, CypherOption semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Cypher returns Cypher
	 *
	 * Constraint:
	 *     (queryOptions=QueryOptions statement=Statement)
	 */
	protected void sequence_Cypher(ISerializationContext context, Cypher semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.CYPHER__QUERY_OPTIONS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.CYPHER__QUERY_OPTIONS));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.CYPHER__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.CYPHER__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCypherAccess().getQueryOptionsQueryOptionsParserRuleCall_1_0(), semanticObject.getQueryOptions());
		feeder.accept(grammarAccess.getCypherAccess().getStatementStatementParserRuleCall_2_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DecimalInteger returns DecimalInteger
	 *
	 * Constraint:
	 *     value=Number
	 */
	protected void sequence_DecimalInteger(ISerializationContext context, DecimalInteger semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.DECIMAL_INTEGER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.DECIMAL_INTEGER__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDecimalIntegerAccess().getValueNumberParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns Delete
	 *     Delete returns Delete
	 *
	 * Constraint:
	 *     (detach?='DETACH'? expressions+=Expression expressions+=Expression*)
	 */
	protected void sequence_Delete(ISerializationContext context, Delete semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DropIndex
	 *     Command returns DropIndex
	 *     DropIndex returns DropIndex
	 *
	 * Constraint:
	 *     index=Index
	 */
	protected void sequence_DropIndex(ISerializationContext context, DropIndex semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.DROP_INDEX__INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.DROP_INDEX__INDEX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDropIndexAccess().getIndexIndexParserRuleCall_1_0(), semanticObject.getIndex());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DropNodePropertyExistenceConstraint
	 *     Command returns DropNodePropertyExistenceConstraint
	 *     DropNodePropertyExistenceConstraint returns DropNodePropertyExistenceConstraint
	 *
	 * Constraint:
	 *     nodePropertyExistenceConstraint=NodePropertyExistenceConstraint
	 */
	protected void sequence_DropNodePropertyExistenceConstraint(ISerializationContext context, DropNodePropertyExistenceConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.DROP_NODE_PROPERTY_EXISTENCE_CONSTRAINT__NODE_PROPERTY_EXISTENCE_CONSTRAINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.DROP_NODE_PROPERTY_EXISTENCE_CONSTRAINT__NODE_PROPERTY_EXISTENCE_CONSTRAINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDropNodePropertyExistenceConstraintAccess().getNodePropertyExistenceConstraintNodePropertyExistenceConstraintParserRuleCall_1_0(), semanticObject.getNodePropertyExistenceConstraint());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DropRelationshipPropertyExistenceConstraint
	 *     Command returns DropRelationshipPropertyExistenceConstraint
	 *     DropRelationshipPropertyExistenceConstraint returns DropRelationshipPropertyExistenceConstraint
	 *
	 * Constraint:
	 *     relationshipPropertyExistenceConstraint=RelationshipPropertyExistenceConstraint
	 */
	protected void sequence_DropRelationshipPropertyExistenceConstraint(ISerializationContext context, DropRelationshipPropertyExistenceConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.DROP_RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT__RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.DROP_RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT__RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDropRelationshipPropertyExistenceConstraintAccess().getRelationshipPropertyExistenceConstraintRelationshipPropertyExistenceConstraintParserRuleCall_1_0(), semanticObject.getRelationshipPropertyExistenceConstraint());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DropUniqueConstraint
	 *     Command returns DropUniqueConstraint
	 *     DropUniqueConstraint returns DropUniqueConstraint
	 *
	 * Constraint:
	 *     uniqueConstraint=UniqueConstraint
	 */
	protected void sequence_DropUniqueConstraint(ISerializationContext context, DropUniqueConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.DROP_UNIQUE_CONSTRAINT__UNIQUE_CONSTRAINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.DROP_UNIQUE_CONSTRAINT__UNIQUE_CONSTRAINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDropUniqueConstraintAccess().getUniqueConstraintUniqueConstraintParserRuleCall_1_0(), semanticObject.getUniqueConstraint());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression3Part returns Contains
	 *
	 * Constraint:
	 *     expression=ExpressionNodeLabelsAndPropertyLookup
	 */
	protected void sequence_Expression3Part(ISerializationContext context, Contains semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.CONTAINS__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.CONTAINS__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpression3PartAccess().getExpressionExpressionNodeLabelsAndPropertyLookupParserRuleCall_5_1_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression3Part returns EndsWith
	 *
	 * Constraint:
	 *     expression=ExpressionNodeLabelsAndPropertyLookup
	 */
	protected void sequence_Expression3Part(ISerializationContext context, EndsWith semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.ENDS_WITH__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.ENDS_WITH__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpression3PartAccess().getExpressionExpressionNodeLabelsAndPropertyLookupParserRuleCall_4_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression3Part returns InCollection
	 *
	 * Constraint:
	 *     expression=ExpressionNodeLabelsAndPropertyLookup
	 */
	protected void sequence_Expression3Part(ISerializationContext context, InCollection semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.IN_COLLECTION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.IN_COLLECTION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpression3PartAccess().getExpressionExpressionNodeLabelsAndPropertyLookupParserRuleCall_2_1_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression3Part returns Index
	 *
	 * Constraint:
	 *     (expression=Expression upper=Expression?)
	 */
	protected void sequence_Expression3Part(ISerializationContext context, Index semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression3Part returns IsNotNull
	 *
	 * Constraint:
	 *     {IsNotNull}
	 */
	protected void sequence_Expression3Part(ISerializationContext context, IsNotNull semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression3Part returns IsNull
	 *
	 * Constraint:
	 *     {IsNull}
	 */
	protected void sequence_Expression3Part(ISerializationContext context, IsNull semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression3Part returns RegExpMatching
	 *
	 * Constraint:
	 *     expression=ExpressionNodeLabelsAndPropertyLookup
	 */
	protected void sequence_Expression3Part(ISerializationContext context, RegExpMatching semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.REG_EXP_MATCHING__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.REG_EXP_MATCHING__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpression3PartAccess().getExpressionExpressionNodeLabelsAndPropertyLookupParserRuleCall_1_1_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression3Part returns StartsWith
	 *
	 * Constraint:
	 *     expression=ExpressionNodeLabelsAndPropertyLookup
	 */
	protected void sequence_Expression3Part(ISerializationContext context, StartsWith semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.STARTS_WITH__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.STARTS_WITH__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpression3PartAccess().getExpressionExpressionNodeLabelsAndPropertyLookupParserRuleCall_3_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionNodeLabelsAndPropertyLookup
	 *     ExpressionOr returns ExpressionNodeLabelsAndPropertyLookup
	 *     ExpressionOr.ExpressionOr_1_0 returns ExpressionNodeLabelsAndPropertyLookup
	 *     ExpressionXor returns ExpressionNodeLabelsAndPropertyLookup
	 *     ExpressionXor.ExpressionXor_1_0 returns ExpressionNodeLabelsAndPropertyLookup
	 *     ExpressionAnd returns ExpressionNodeLabelsAndPropertyLookup
	 *     ExpressionAnd.ExpressionAnd_1_0 returns ExpressionNodeLabelsAndPropertyLookup
	 *     ExpressionNot returns ExpressionNodeLabelsAndPropertyLookup
	 *     ExpressionComparison returns ExpressionNodeLabelsAndPropertyLookup
	 *     ExpressionComparison.ExpressionComparison_1_0 returns ExpressionNodeLabelsAndPropertyLookup
	 *     ExpressionPlusMinus returns ExpressionNodeLabelsAndPropertyLookup
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns ExpressionNodeLabelsAndPropertyLookup
	 *     ExpressionMulDiv returns ExpressionNodeLabelsAndPropertyLookup
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns ExpressionNodeLabelsAndPropertyLookup
	 *     ExpressionPower returns ExpressionNodeLabelsAndPropertyLookup
	 *     ExpressionPower.ExpressionPower_1_0 returns ExpressionNodeLabelsAndPropertyLookup
	 *     ExpressionUnaryPlusMinus returns ExpressionNodeLabelsAndPropertyLookup
	 *     Expression3 returns ExpressionNodeLabelsAndPropertyLookup
	 *
	 * Constraint:
	 *     (
	 *         left=ExpressionNodeLabelsAndPropertyLookup_ExpressionNodeLabelsAndPropertyLookup_1_0_0 
	 *         propertyLookups+=PropertyLookup 
	 *         nodeLabelList+=NodeLabel* 
	 *         expression3Parts+=Expression3Part*
	 *     )
	 */
	protected void sequence_Expression3_ExpressionNodeLabelsAndPropertyLookup(ISerializationContext context, ExpressionNodeLabelsAndPropertyLookup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns FunctionInvocation
	 *     ExpressionOr returns FunctionInvocation
	 *     ExpressionOr.ExpressionOr_1_0 returns FunctionInvocation
	 *     ExpressionXor returns FunctionInvocation
	 *     ExpressionXor.ExpressionXor_1_0 returns FunctionInvocation
	 *     ExpressionAnd returns FunctionInvocation
	 *     ExpressionAnd.ExpressionAnd_1_0 returns FunctionInvocation
	 *     ExpressionNot returns FunctionInvocation
	 *     ExpressionComparison returns FunctionInvocation
	 *     ExpressionComparison.ExpressionComparison_1_0 returns FunctionInvocation
	 *     ExpressionPlusMinus returns FunctionInvocation
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns FunctionInvocation
	 *     ExpressionMulDiv returns FunctionInvocation
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns FunctionInvocation
	 *     ExpressionPower returns FunctionInvocation
	 *     ExpressionPower.ExpressionPower_1_0 returns FunctionInvocation
	 *     ExpressionUnaryPlusMinus returns FunctionInvocation
	 *     Expression3 returns FunctionInvocation
	 *
	 * Constraint:
	 *     (
	 *         functionName=FunctionName 
	 *         distinct?='DISTINCT'? 
	 *         (parameter+=Expression parameter+=Expression*)? 
	 *         nodeLabelList+=NodeLabel* 
	 *         expression3Parts+=Expression3Part*
	 *     )
	 */
	protected void sequence_Expression3_ExpressionNodeLabelsAndPropertyLookup_FunctionInvocation(ISerializationContext context, FunctionInvocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LegacyParameter
	 *     ExpressionOr returns LegacyParameter
	 *     ExpressionOr.ExpressionOr_1_0 returns LegacyParameter
	 *     ExpressionXor returns LegacyParameter
	 *     ExpressionXor.ExpressionXor_1_0 returns LegacyParameter
	 *     ExpressionAnd returns LegacyParameter
	 *     ExpressionAnd.ExpressionAnd_1_0 returns LegacyParameter
	 *     ExpressionNot returns LegacyParameter
	 *     ExpressionComparison returns LegacyParameter
	 *     ExpressionComparison.ExpressionComparison_1_0 returns LegacyParameter
	 *     ExpressionPlusMinus returns LegacyParameter
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns LegacyParameter
	 *     ExpressionMulDiv returns LegacyParameter
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns LegacyParameter
	 *     ExpressionPower returns LegacyParameter
	 *     ExpressionPower.ExpressionPower_1_0 returns LegacyParameter
	 *     ExpressionUnaryPlusMinus returns LegacyParameter
	 *     Expression3 returns LegacyParameter
	 *
	 * Constraint:
	 *     ((parameter=SYMBOLIC_NAME | parameter=Number) nodeLabelList+=NodeLabel* expression3Parts+=Expression3Part*)
	 */
	protected void sequence_Expression3_ExpressionNodeLabelsAndPropertyLookup_LegacyParameter(ISerializationContext context, LegacyParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ListComprehension
	 *     ExpressionOr returns ListComprehension
	 *     ExpressionOr.ExpressionOr_1_0 returns ListComprehension
	 *     ExpressionXor returns ListComprehension
	 *     ExpressionXor.ExpressionXor_1_0 returns ListComprehension
	 *     ExpressionAnd returns ListComprehension
	 *     ExpressionAnd.ExpressionAnd_1_0 returns ListComprehension
	 *     ExpressionNot returns ListComprehension
	 *     ExpressionComparison returns ListComprehension
	 *     ExpressionComparison.ExpressionComparison_1_0 returns ListComprehension
	 *     ExpressionPlusMinus returns ListComprehension
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns ListComprehension
	 *     ExpressionMulDiv returns ListComprehension
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns ListComprehension
	 *     ExpressionPower returns ListComprehension
	 *     ExpressionPower.ExpressionPower_1_0 returns ListComprehension
	 *     ExpressionUnaryPlusMinus returns ListComprehension
	 *     Expression3 returns ListComprehension
	 *
	 * Constraint:
	 *     (filterExpression=FilterExpression expression=Expression? nodeLabelList+=NodeLabel* expression3Parts+=Expression3Part*)
	 */
	protected void sequence_Expression3_ExpressionNodeLabelsAndPropertyLookup_ListComprehension(ISerializationContext context, ListComprehension semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MapLiteral
	 *     ExpressionOr returns MapLiteral
	 *     ExpressionOr.ExpressionOr_1_0 returns MapLiteral
	 *     ExpressionXor returns MapLiteral
	 *     ExpressionXor.ExpressionXor_1_0 returns MapLiteral
	 *     ExpressionAnd returns MapLiteral
	 *     ExpressionAnd.ExpressionAnd_1_0 returns MapLiteral
	 *     ExpressionNot returns MapLiteral
	 *     ExpressionComparison returns MapLiteral
	 *     ExpressionComparison.ExpressionComparison_1_0 returns MapLiteral
	 *     ExpressionPlusMinus returns MapLiteral
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns MapLiteral
	 *     ExpressionMulDiv returns MapLiteral
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns MapLiteral
	 *     ExpressionPower returns MapLiteral
	 *     ExpressionPower.ExpressionPower_1_0 returns MapLiteral
	 *     ExpressionUnaryPlusMinus returns MapLiteral
	 *     Expression3 returns MapLiteral
	 *
	 * Constraint:
	 *     ((entries+=MapLiteralEntry entries+=MapLiteralEntry*)? nodeLabelList+=NodeLabel* expression3Parts+=Expression3Part*)
	 */
	protected void sequence_Expression3_ExpressionNodeLabelsAndPropertyLookup_MapLiteral(ISerializationContext context, MapLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Parameter
	 *     ExpressionOr returns Parameter
	 *     ExpressionOr.ExpressionOr_1_0 returns Parameter
	 *     ExpressionXor returns Parameter
	 *     ExpressionXor.ExpressionXor_1_0 returns Parameter
	 *     ExpressionAnd returns Parameter
	 *     ExpressionAnd.ExpressionAnd_1_0 returns Parameter
	 *     ExpressionNot returns Parameter
	 *     ExpressionComparison returns Parameter
	 *     ExpressionComparison.ExpressionComparison_1_0 returns Parameter
	 *     ExpressionPlusMinus returns Parameter
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns Parameter
	 *     ExpressionMulDiv returns Parameter
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns Parameter
	 *     ExpressionPower returns Parameter
	 *     ExpressionPower.ExpressionPower_1_0 returns Parameter
	 *     ExpressionUnaryPlusMinus returns Parameter
	 *     Expression3 returns Parameter
	 *
	 * Constraint:
	 *     ((parameter=SYMBOLIC_NAME | parameter=Number) nodeLabelList+=NodeLabel* expression3Parts+=Expression3Part*)
	 */
	protected void sequence_Expression3_ExpressionNodeLabelsAndPropertyLookup_Parameter(ISerializationContext context, org.slizaa.neo4j.opencypher.openCypher.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ParenthesizedExpression
	 *     ExpressionOr returns ParenthesizedExpression
	 *     ExpressionOr.ExpressionOr_1_0 returns ParenthesizedExpression
	 *     ExpressionXor returns ParenthesizedExpression
	 *     ExpressionXor.ExpressionXor_1_0 returns ParenthesizedExpression
	 *     ExpressionAnd returns ParenthesizedExpression
	 *     ExpressionAnd.ExpressionAnd_1_0 returns ParenthesizedExpression
	 *     ExpressionNot returns ParenthesizedExpression
	 *     ExpressionComparison returns ParenthesizedExpression
	 *     ExpressionComparison.ExpressionComparison_1_0 returns ParenthesizedExpression
	 *     ExpressionPlusMinus returns ParenthesizedExpression
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns ParenthesizedExpression
	 *     ExpressionMulDiv returns ParenthesizedExpression
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns ParenthesizedExpression
	 *     ExpressionPower returns ParenthesizedExpression
	 *     ExpressionPower.ExpressionPower_1_0 returns ParenthesizedExpression
	 *     ExpressionUnaryPlusMinus returns ParenthesizedExpression
	 *     Expression3 returns ParenthesizedExpression
	 *
	 * Constraint:
	 *     (expression=Expression nodeLabelList+=NodeLabel* expression3Parts+=Expression3Part*)
	 */
	protected void sequence_Expression3_ExpressionNodeLabelsAndPropertyLookup_ParenthesizedExpression(ISerializationContext context, ParenthesizedExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Reduce
	 *     ExpressionOr returns Reduce
	 *     ExpressionOr.ExpressionOr_1_0 returns Reduce
	 *     ExpressionXor returns Reduce
	 *     ExpressionXor.ExpressionXor_1_0 returns Reduce
	 *     ExpressionAnd returns Reduce
	 *     ExpressionAnd.ExpressionAnd_1_0 returns Reduce
	 *     ExpressionNot returns Reduce
	 *     ExpressionComparison returns Reduce
	 *     ExpressionComparison.ExpressionComparison_1_0 returns Reduce
	 *     ExpressionPlusMinus returns Reduce
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns Reduce
	 *     ExpressionMulDiv returns Reduce
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns Reduce
	 *     ExpressionPower returns Reduce
	 *     ExpressionPower.ExpressionPower_1_0 returns Reduce
	 *     ExpressionUnaryPlusMinus returns Reduce
	 *     Expression3 returns Reduce
	 *
	 * Constraint:
	 *     (
	 *         accumulator=Variable 
	 *         accumulatorExpression=Expression 
	 *         idInColl=IdInColl 
	 *         expression=Expression 
	 *         nodeLabelList+=NodeLabel* 
	 *         expression3Parts+=Expression3Part*
	 *     )
	 */
	protected void sequence_Expression3_ExpressionNodeLabelsAndPropertyLookup_Reduce(ISerializationContext context, Reduce semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns RelationshipsPattern
	 *     ExpressionOr returns RelationshipsPattern
	 *     ExpressionOr.ExpressionOr_1_0 returns RelationshipsPattern
	 *     ExpressionXor returns RelationshipsPattern
	 *     ExpressionXor.ExpressionXor_1_0 returns RelationshipsPattern
	 *     ExpressionAnd returns RelationshipsPattern
	 *     ExpressionAnd.ExpressionAnd_1_0 returns RelationshipsPattern
	 *     ExpressionNot returns RelationshipsPattern
	 *     ExpressionComparison returns RelationshipsPattern
	 *     ExpressionComparison.ExpressionComparison_1_0 returns RelationshipsPattern
	 *     ExpressionPlusMinus returns RelationshipsPattern
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns RelationshipsPattern
	 *     ExpressionMulDiv returns RelationshipsPattern
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns RelationshipsPattern
	 *     ExpressionPower returns RelationshipsPattern
	 *     ExpressionPower.ExpressionPower_1_0 returns RelationshipsPattern
	 *     ExpressionUnaryPlusMinus returns RelationshipsPattern
	 *     Expression3 returns RelationshipsPattern
	 *
	 * Constraint:
	 *     (nodePattern=NodePattern chain+=PatternElementChain+ nodeLabelList+=NodeLabel* expression3Parts+=Expression3Part*)
	 */
	protected void sequence_Expression3_ExpressionNodeLabelsAndPropertyLookup_RelationshipsPattern(ISerializationContext context, RelationshipsPattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns AllShortestPath
	 *     ExpressionOr returns AllShortestPath
	 *     ExpressionOr.ExpressionOr_1_0 returns AllShortestPath
	 *     ExpressionXor returns AllShortestPath
	 *     ExpressionXor.ExpressionXor_1_0 returns AllShortestPath
	 *     ExpressionAnd returns AllShortestPath
	 *     ExpressionAnd.ExpressionAnd_1_0 returns AllShortestPath
	 *     ExpressionNot returns AllShortestPath
	 *     ExpressionComparison returns AllShortestPath
	 *     ExpressionComparison.ExpressionComparison_1_0 returns AllShortestPath
	 *     ExpressionPlusMinus returns AllShortestPath
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns AllShortestPath
	 *     ExpressionMulDiv returns AllShortestPath
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns AllShortestPath
	 *     ExpressionPower returns AllShortestPath
	 *     ExpressionPower.ExpressionPower_1_0 returns AllShortestPath
	 *     ExpressionUnaryPlusMinus returns AllShortestPath
	 *     Expression3 returns AllShortestPath
	 *
	 * Constraint:
	 *     (patternElement=PatternElement nodeLabelList+=NodeLabel* expression3Parts+=Expression3Part*)
	 */
	protected void sequence_Expression3_ExpressionNodeLabelsAndPropertyLookup_ShortestPathPattern(ISerializationContext context, AllShortestPath semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ShortestPath
	 *     ExpressionOr returns ShortestPath
	 *     ExpressionOr.ExpressionOr_1_0 returns ShortestPath
	 *     ExpressionXor returns ShortestPath
	 *     ExpressionXor.ExpressionXor_1_0 returns ShortestPath
	 *     ExpressionAnd returns ShortestPath
	 *     ExpressionAnd.ExpressionAnd_1_0 returns ShortestPath
	 *     ExpressionNot returns ShortestPath
	 *     ExpressionComparison returns ShortestPath
	 *     ExpressionComparison.ExpressionComparison_1_0 returns ShortestPath
	 *     ExpressionPlusMinus returns ShortestPath
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns ShortestPath
	 *     ExpressionMulDiv returns ShortestPath
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns ShortestPath
	 *     ExpressionPower returns ShortestPath
	 *     ExpressionPower.ExpressionPower_1_0 returns ShortestPath
	 *     ExpressionUnaryPlusMinus returns ShortestPath
	 *     Expression3 returns ShortestPath
	 *
	 * Constraint:
	 *     (patternElement=PatternElement nodeLabelList+=NodeLabel* expression3Parts+=Expression3Part*)
	 */
	protected void sequence_Expression3_ExpressionNodeLabelsAndPropertyLookup_ShortestPathPattern(ISerializationContext context, ShortestPath semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionAnd
	 *     ExpressionOr returns ExpressionAnd
	 *     ExpressionOr.ExpressionOr_1_0 returns ExpressionAnd
	 *     ExpressionXor returns ExpressionAnd
	 *     ExpressionXor.ExpressionXor_1_0 returns ExpressionAnd
	 *     ExpressionAnd returns ExpressionAnd
	 *     ExpressionAnd.ExpressionAnd_1_0 returns ExpressionAnd
	 *
	 * Constraint:
	 *     (left=ExpressionAnd_ExpressionAnd_1_0 operator='AND' right=ExpressionNot)
	 */
	protected void sequence_ExpressionAnd(ISerializationContext context, ExpressionAnd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.EXPRESSION_AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.EXPRESSION_AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAndAccess().getExpressionAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionAndAccess().getOperatorANDKeyword_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getExpressionAndAccess().getRightExpressionNotParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionComparison
	 *     ExpressionOr returns ExpressionComparison
	 *     ExpressionOr.ExpressionOr_1_0 returns ExpressionComparison
	 *     ExpressionXor returns ExpressionComparison
	 *     ExpressionXor.ExpressionXor_1_0 returns ExpressionComparison
	 *     ExpressionAnd returns ExpressionComparison
	 *     ExpressionAnd.ExpressionAnd_1_0 returns ExpressionComparison
	 *     ExpressionNot returns ExpressionComparison
	 *     ExpressionComparison returns ExpressionComparison
	 *     ExpressionComparison.ExpressionComparison_1_0 returns ExpressionComparison
	 *
	 * Constraint:
	 *     (
	 *         left=ExpressionComparison_ExpressionComparison_1_0 
	 *         (
	 *             operator='=' | 
	 *             operator='<>' | 
	 *             operator='!=' | 
	 *             operator='<' | 
	 *             operator='>' | 
	 *             operator='<=' | 
	 *             operator='>='
	 *         ) 
	 *         right=ExpressionPlusMinus
	 *     )
	 */
	protected void sequence_ExpressionComparison(ISerializationContext context, ExpressionComparison semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionMulDiv
	 *     ExpressionOr returns ExpressionMulDiv
	 *     ExpressionOr.ExpressionOr_1_0 returns ExpressionMulDiv
	 *     ExpressionXor returns ExpressionMulDiv
	 *     ExpressionXor.ExpressionXor_1_0 returns ExpressionMulDiv
	 *     ExpressionAnd returns ExpressionMulDiv
	 *     ExpressionAnd.ExpressionAnd_1_0 returns ExpressionMulDiv
	 *     ExpressionNot returns ExpressionMulDiv
	 *     ExpressionComparison returns ExpressionMulDiv
	 *     ExpressionComparison.ExpressionComparison_1_0 returns ExpressionMulDiv
	 *     ExpressionPlusMinus returns ExpressionMulDiv
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns ExpressionMulDiv
	 *     ExpressionMulDiv returns ExpressionMulDiv
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns ExpressionMulDiv
	 *
	 * Constraint:
	 *     (left=ExpressionMulDiv_ExpressionMulDiv_1_0 (operator='*' | operator='/' | operator='%') right=ExpressionPower)
	 */
	protected void sequence_ExpressionMulDiv(ISerializationContext context, ExpressionMulDiv semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionNodeLabelsAndPropertyLookup returns ExpressionNodeLabelsAndPropertyLookup
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabelsAndPropertyLookup_1_0_0 returns ExpressionNodeLabelsAndPropertyLookup
	 *
	 * Constraint:
	 *     (
	 *         left=ExpressionNodeLabelsAndPropertyLookup_ExpressionNodeLabelsAndPropertyLookup_1_0_0 
	 *         propertyLookups+=PropertyLookup 
	 *         nodeLabelList+=NodeLabel*
	 *     )
	 */
	protected void sequence_ExpressionNodeLabelsAndPropertyLookup(ISerializationContext context, ExpressionNodeLabelsAndPropertyLookup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionNodeLabelsAndPropertyLookup returns FunctionInvocation
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabelsAndPropertyLookup_1_0_0 returns FunctionInvocation
	 *
	 * Constraint:
	 *     (functionName=FunctionName distinct?='DISTINCT'? (parameter+=Expression parameter+=Expression*)? nodeLabelList+=NodeLabel*)
	 */
	protected void sequence_ExpressionNodeLabelsAndPropertyLookup_FunctionInvocation(ISerializationContext context, FunctionInvocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionNodeLabelsAndPropertyLookup returns LegacyParameter
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabelsAndPropertyLookup_1_0_0 returns LegacyParameter
	 *
	 * Constraint:
	 *     ((parameter=SYMBOLIC_NAME | parameter=Number) nodeLabelList+=NodeLabel*)
	 */
	protected void sequence_ExpressionNodeLabelsAndPropertyLookup_LegacyParameter(ISerializationContext context, LegacyParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionNodeLabelsAndPropertyLookup returns ListComprehension
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabelsAndPropertyLookup_1_0_0 returns ListComprehension
	 *
	 * Constraint:
	 *     (filterExpression=FilterExpression expression=Expression? nodeLabelList+=NodeLabel*)
	 */
	protected void sequence_ExpressionNodeLabelsAndPropertyLookup_ListComprehension(ISerializationContext context, ListComprehension semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionNodeLabelsAndPropertyLookup returns MapLiteral
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabelsAndPropertyLookup_1_0_0 returns MapLiteral
	 *
	 * Constraint:
	 *     ((entries+=MapLiteralEntry entries+=MapLiteralEntry*)? nodeLabelList+=NodeLabel*)
	 */
	protected void sequence_ExpressionNodeLabelsAndPropertyLookup_MapLiteral(ISerializationContext context, MapLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionNodeLabelsAndPropertyLookup returns Parameter
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabelsAndPropertyLookup_1_0_0 returns Parameter
	 *
	 * Constraint:
	 *     ((parameter=SYMBOLIC_NAME | parameter=Number) nodeLabelList+=NodeLabel*)
	 */
	protected void sequence_ExpressionNodeLabelsAndPropertyLookup_Parameter(ISerializationContext context, org.slizaa.neo4j.opencypher.openCypher.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionNodeLabelsAndPropertyLookup returns ParenthesizedExpression
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabelsAndPropertyLookup_1_0_0 returns ParenthesizedExpression
	 *
	 * Constraint:
	 *     (expression=Expression nodeLabelList+=NodeLabel*)
	 */
	protected void sequence_ExpressionNodeLabelsAndPropertyLookup_ParenthesizedExpression(ISerializationContext context, ParenthesizedExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionNodeLabelsAndPropertyLookup returns Reduce
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabelsAndPropertyLookup_1_0_0 returns Reduce
	 *
	 * Constraint:
	 *     (accumulator=Variable accumulatorExpression=Expression idInColl=IdInColl expression=Expression nodeLabelList+=NodeLabel*)
	 */
	protected void sequence_ExpressionNodeLabelsAndPropertyLookup_Reduce(ISerializationContext context, Reduce semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionNodeLabelsAndPropertyLookup returns RelationshipsPattern
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabelsAndPropertyLookup_1_0_0 returns RelationshipsPattern
	 *
	 * Constraint:
	 *     (nodePattern=NodePattern chain+=PatternElementChain+ nodeLabelList+=NodeLabel*)
	 */
	protected void sequence_ExpressionNodeLabelsAndPropertyLookup_RelationshipsPattern(ISerializationContext context, RelationshipsPattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionNodeLabelsAndPropertyLookup returns AllShortestPath
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabelsAndPropertyLookup_1_0_0 returns AllShortestPath
	 *
	 * Constraint:
	 *     (patternElement=PatternElement nodeLabelList+=NodeLabel*)
	 */
	protected void sequence_ExpressionNodeLabelsAndPropertyLookup_ShortestPathPattern(ISerializationContext context, AllShortestPath semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionNodeLabelsAndPropertyLookup returns ShortestPath
	 *     ExpressionNodeLabelsAndPropertyLookup.ExpressionNodeLabelsAndPropertyLookup_1_0_0 returns ShortestPath
	 *
	 * Constraint:
	 *     (patternElement=PatternElement nodeLabelList+=NodeLabel*)
	 */
	protected void sequence_ExpressionNodeLabelsAndPropertyLookup_ShortestPathPattern(ISerializationContext context, ShortestPath semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Expression
	 *     ExpressionOr returns Expression
	 *     ExpressionOr.ExpressionOr_1_0 returns Expression
	 *     ExpressionXor returns Expression
	 *     ExpressionXor.ExpressionXor_1_0 returns Expression
	 *     ExpressionAnd returns Expression
	 *     ExpressionAnd.ExpressionAnd_1_0 returns Expression
	 *     ExpressionNot returns Expression
	 *
	 * Constraint:
	 *     ((operator='NOT' left=ExpressionNot) | (operator='+' left=Expression3) | (operator='-' left=Expression3))
	 */
	protected void sequence_ExpressionNot_ExpressionUnaryPlusMinus(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionOr
	 *     ExpressionOr returns ExpressionOr
	 *     ExpressionOr.ExpressionOr_1_0 returns ExpressionOr
	 *
	 * Constraint:
	 *     (left=ExpressionOr_ExpressionOr_1_0 operator='OR' right=ExpressionXor)
	 */
	protected void sequence_ExpressionOr(ISerializationContext context, ExpressionOr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.EXPRESSION_OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.EXPRESSION_OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionOrAccess().getExpressionOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionOrAccess().getOperatorORKeyword_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getExpressionOrAccess().getRightExpressionXorParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionPlusMinus
	 *     ExpressionOr returns ExpressionPlusMinus
	 *     ExpressionOr.ExpressionOr_1_0 returns ExpressionPlusMinus
	 *     ExpressionXor returns ExpressionPlusMinus
	 *     ExpressionXor.ExpressionXor_1_0 returns ExpressionPlusMinus
	 *     ExpressionAnd returns ExpressionPlusMinus
	 *     ExpressionAnd.ExpressionAnd_1_0 returns ExpressionPlusMinus
	 *     ExpressionNot returns ExpressionPlusMinus
	 *     ExpressionComparison returns ExpressionPlusMinus
	 *     ExpressionComparison.ExpressionComparison_1_0 returns ExpressionPlusMinus
	 *     ExpressionPlusMinus returns ExpressionPlusMinus
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns ExpressionPlusMinus
	 *
	 * Constraint:
	 *     (left=ExpressionPlusMinus_ExpressionPlusMinus_1_0 (operator='+' | operator='-') right=ExpressionMulDiv)
	 */
	protected void sequence_ExpressionPlusMinus(ISerializationContext context, ExpressionPlusMinus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionPower
	 *     ExpressionOr returns ExpressionPower
	 *     ExpressionOr.ExpressionOr_1_0 returns ExpressionPower
	 *     ExpressionXor returns ExpressionPower
	 *     ExpressionXor.ExpressionXor_1_0 returns ExpressionPower
	 *     ExpressionAnd returns ExpressionPower
	 *     ExpressionAnd.ExpressionAnd_1_0 returns ExpressionPower
	 *     ExpressionNot returns ExpressionPower
	 *     ExpressionComparison returns ExpressionPower
	 *     ExpressionComparison.ExpressionComparison_1_0 returns ExpressionPower
	 *     ExpressionPlusMinus returns ExpressionPower
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns ExpressionPower
	 *     ExpressionMulDiv returns ExpressionPower
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns ExpressionPower
	 *     ExpressionPower returns ExpressionPower
	 *     ExpressionPower.ExpressionPower_1_0 returns ExpressionPower
	 *
	 * Constraint:
	 *     (left=ExpressionPower_ExpressionPower_1_0 operator='^' right=ExpressionUnaryPlusMinus)
	 */
	protected void sequence_ExpressionPower(ISerializationContext context, ExpressionPower semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.EXPRESSION_POWER__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.EXPRESSION_POWER__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionPowerAccess().getExpressionPowerLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionPowerAccess().getOperatorCircumflexAccentKeyword_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getExpressionPowerAccess().getRightExpressionUnaryPlusMinusParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionComparison returns Expression
	 *     ExpressionComparison.ExpressionComparison_1_0 returns Expression
	 *     ExpressionPlusMinus returns Expression
	 *     ExpressionPlusMinus.ExpressionPlusMinus_1_0 returns Expression
	 *     ExpressionMulDiv returns Expression
	 *     ExpressionMulDiv.ExpressionMulDiv_1_0 returns Expression
	 *     ExpressionPower returns Expression
	 *     ExpressionPower.ExpressionPower_1_0 returns Expression
	 *     ExpressionUnaryPlusMinus returns Expression
	 *
	 * Constraint:
	 *     ((operator='+' left=Expression3) | (operator='-' left=Expression3))
	 */
	protected void sequence_ExpressionUnaryPlusMinus(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExpressionXor
	 *     ExpressionOr returns ExpressionXor
	 *     ExpressionOr.ExpressionOr_1_0 returns ExpressionXor
	 *     ExpressionXor returns ExpressionXor
	 *     ExpressionXor.ExpressionXor_1_0 returns ExpressionXor
	 *
	 * Constraint:
	 *     (left=ExpressionXor_ExpressionXor_1_0 operator='XOR' right=ExpressionAnd)
	 */
	protected void sequence_ExpressionXor(ISerializationContext context, ExpressionXor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.EXPRESSION_XOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.EXPRESSION_XOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionXorAccess().getExpressionXorLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionXorAccess().getOperatorXORKeyword_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getExpressionXorAccess().getRightExpressionAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FilterExpression returns FilterExpression
	 *
	 * Constraint:
	 *     (idInColl=IdInColl where=Where?)
	 */
	protected void sequence_FilterExpression(ISerializationContext context, FilterExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns Foreach
	 *     Foreach returns Foreach
	 *
	 * Constraint:
	 *     (variable=Variable expression=Expression clause+=Clause+)
	 */
	protected void sequence_Foreach(ISerializationContext context, Foreach semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Atom returns FunctionInvocation
	 *     FunctionInvocation returns FunctionInvocation
	 *
	 * Constraint:
	 *     (functionName=FunctionName distinct?='DISTINCT'? (parameter+=Expression parameter+=Expression*)?)
	 */
	protected void sequence_FunctionInvocation(ISerializationContext context, FunctionInvocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RemoveItem returns FunctionInvocation
	 *     PropertyExpression returns FunctionInvocation
	 *
	 * Constraint:
	 *     (functionName=FunctionName distinct?='DISTINCT'? (parameter+=Expression parameter+=Expression*)? propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_FunctionInvocation_PropertyExpression(ISerializationContext context, FunctionInvocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionName returns FunctionName
	 *
	 * Constraint:
	 *     name=SYMBOLIC_NAME_X
	 */
	protected void sequence_FunctionName(ISerializationContext context, FunctionName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.FUNCTION_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.FUNCTION_NAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionNameAccess().getNameSYMBOLIC_NAME_XParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Hint returns IndexHint
	 *
	 * Constraint:
	 *     (variable=Variable nodeLabel=NodeLabel propertyKeyName=PropertyKeyName)
	 */
	protected void sequence_Hint(ISerializationContext context, IndexHint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.INDEX_HINT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.INDEX_HINT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.INDEX_HINT__NODE_LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.INDEX_HINT__NODE_LABEL));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.INDEX_HINT__PROPERTY_KEY_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.INDEX_HINT__PROPERTY_KEY_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHintAccess().getVariableVariableParserRuleCall_0_5_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getHintAccess().getNodeLabelNodeLabelParserRuleCall_0_6_0(), semanticObject.getNodeLabel());
		feeder.accept(grammarAccess.getHintAccess().getPropertyKeyNamePropertyKeyNameParserRuleCall_0_9_0(), semanticObject.getPropertyKeyName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Hint returns JoinHint
	 *
	 * Constraint:
	 *     (variables+=Variable variables+=Variable*)
	 */
	protected void sequence_Hint(ISerializationContext context, JoinHint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Hint returns ScanHint
	 *
	 * Constraint:
	 *     (variable=Variable nodeLabel=NodeLabel)
	 */
	protected void sequence_Hint(ISerializationContext context, ScanHint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.SCAN_HINT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.SCAN_HINT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.SCAN_HINT__NODE_LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.SCAN_HINT__NODE_LABEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHintAccess().getVariableVariableParserRuleCall_2_1_4_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getHintAccess().getNodeLabelNodeLabelParserRuleCall_2_1_5_0(), semanticObject.getNodeLabel());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IdInColl returns IdInColl
	 *
	 * Constraint:
	 *     (variable=Variable expression=Expression)
	 */
	protected void sequence_IdInColl(ISerializationContext context, IdInColl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.ID_IN_COLL__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.ID_IN_COLL__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.ID_IN_COLL__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.ID_IN_COLL__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIdInCollAccess().getVariableVariableParserRuleCall_0_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getIdInCollAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Lookup returns IdLookup
	 *     NodeLookup returns IdLookup
	 *     RelationshipLookup returns IdLookup
	 *     IdLookup returns IdLookup
	 *
	 * Constraint:
	 *     (ids=LiteralIds | legacyParameter=Parameter | wildcard='*')
	 */
	protected void sequence_IdLookup(ISerializationContext context, IdLookup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Lookup returns IdentifiedIndexLookup
	 *     NodeLookup returns IdentifiedIndexLookup
	 *     RelationshipLookup returns IdentifiedIndexLookup
	 *     IdentifiedIndexLookup returns IdentifiedIndexLookup
	 *
	 * Constraint:
	 *     (indexName=SYMBOLIC_NAME key=SYMBOLIC_NAME (value=STRING_LITERAL | legacyParameter=LegacyParameter))
	 */
	protected void sequence_IdentifiedIndexLookup(ISerializationContext context, IdentifiedIndexLookup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Lookup returns IndexQuery
	 *     NodeLookup returns IndexQuery
	 *     RelationshipLookup returns IndexQuery
	 *     IndexQuery returns IndexQuery
	 *
	 * Constraint:
	 *     (indexName=SYMBOLIC_NAME (query=STRING_LITERAL | parameter=Parameter))
	 */
	protected void sequence_IndexQuery(ISerializationContext context, IndexQuery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Index returns Index
	 *
	 * Constraint:
	 *     (nodeLabel=NodeLabel propertyKeyName=PropertyKeyName)
	 */
	protected void sequence_Index(ISerializationContext context, Index semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.INDEX__NODE_LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.INDEX__NODE_LABEL));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.INDEX__PROPERTY_KEY_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.INDEX__PROPERTY_KEY_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIndexAccess().getNodeLabelNodeLabelParserRuleCall_2_0(), semanticObject.getNodeLabel());
		feeder.accept(grammarAccess.getIndexAccess().getPropertyKeyNamePropertyKeyNameParserRuleCall_4_0(), semanticObject.getPropertyKeyName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Properties returns LegacyParameter
	 *     Atom returns LegacyParameter
	 *     LegacyParameter returns LegacyParameter
	 *
	 * Constraint:
	 *     (parameter=SYMBOLIC_NAME | parameter=Number)
	 */
	protected void sequence_LegacyParameter(ISerializationContext context, LegacyParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RemoveItem returns LegacyParameter
	 *     PropertyExpression returns LegacyParameter
	 *
	 * Constraint:
	 *     ((parameter=SYMBOLIC_NAME | parameter=Number) propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_LegacyParameter_PropertyExpression(ISerializationContext context, LegacyParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Limit returns Limit
	 *
	 * Constraint:
	 *     limit=Expression
	 */
	protected void sequence_Limit(ISerializationContext context, Limit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.LIMIT__LIMIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.LIMIT__LIMIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLimitAccess().getLimitExpressionParserRuleCall_1_0(), semanticObject.getLimit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Atom returns ListComprehension
	 *     ListComprehension returns ListComprehension
	 *
	 * Constraint:
	 *     (filterExpression=FilterExpression expression=Expression?)
	 */
	protected void sequence_ListComprehension(ISerializationContext context, ListComprehension semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RemoveItem returns ListComprehension
	 *     PropertyExpression returns ListComprehension
	 *
	 * Constraint:
	 *     (filterExpression=FilterExpression expression=Expression? propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_ListComprehension_PropertyExpression(ISerializationContext context, ListComprehension semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LiteralIds returns LiteralIds
	 *
	 * Constraint:
	 *     (ids+=DecimalInteger ids+=DecimalInteger*)
	 */
	protected void sequence_LiteralIds(ISerializationContext context, LiteralIds semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LoadCSVQuery returns LoadCSVQuery
	 *
	 * Constraint:
	 *     (loadCSV=LoadCSV clauses+=Clause*)
	 */
	protected void sequence_LoadCSVQuery(ISerializationContext context, LoadCSVQuery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns LoadCSV
	 *     LoadCSV returns LoadCSV
	 *
	 * Constraint:
	 *     (withHeaders?=LoadCSVWithHeaders? expression=Expression variable=Variable fieldterminator=STRING_LITERAL?)
	 */
	protected void sequence_LoadCSV(ISerializationContext context, LoadCSV semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MapLiteralEntry returns MapLiteralEntry
	 *
	 * Constraint:
	 *     (key=PropertyKeyName value=Expression)
	 */
	protected void sequence_MapLiteralEntry(ISerializationContext context, MapLiteralEntry semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.MAP_LITERAL_ENTRY__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.MAP_LITERAL_ENTRY__KEY));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.MAP_LITERAL_ENTRY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.MAP_LITERAL_ENTRY__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMapLiteralEntryAccess().getKeyPropertyKeyNameParserRuleCall_0_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getMapLiteralEntryAccess().getValueExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Properties returns MapLiteral
	 *     Atom returns MapLiteral
	 *     MapLiteral returns MapLiteral
	 *
	 * Constraint:
	 *     (entries+=MapLiteralEntry entries+=MapLiteralEntry*)?
	 */
	protected void sequence_MapLiteral(ISerializationContext context, MapLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RemoveItem returns MapLiteral
	 *     PropertyExpression returns MapLiteral
	 *
	 * Constraint:
	 *     ((entries+=MapLiteralEntry entries+=MapLiteralEntry*)? propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_MapLiteral_PropertyExpression(ISerializationContext context, MapLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns Match
	 *     Match returns Match
	 *
	 * Constraint:
	 *     (optional?='OPTIONAL'? pattern=Pattern hints+=Hint* where=Where?)
	 */
	protected void sequence_Match(ISerializationContext context, Match semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MergeAction returns MergeAction
	 *
	 * Constraint:
	 *     ((action='MATCH' | action='CREATE') set=Set)
	 */
	protected void sequence_MergeAction(ISerializationContext context, MergeAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns Merge
	 *     Merge returns Merge
	 *
	 * Constraint:
	 *     (patternPart=PatternPart mergeActions+=MergeAction*)
	 */
	protected void sequence_Merge(ISerializationContext context, Merge semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NodeLabel returns NodeLabel
	 *
	 * Constraint:
	 *     labelName=LabelName
	 */
	protected void sequence_NodeLabel(ISerializationContext context, NodeLabel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.NODE_LABEL__LABEL_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.NODE_LABEL__LABEL_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNodeLabelAccess().getLabelNameLabelNameParserRuleCall_1_0(), semanticObject.getLabelName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NodeLabels returns NodeLabels
	 *
	 * Constraint:
	 *     (nodeLabels+=NodeLabel nodeLabels+=NodeLabel*)
	 */
	protected void sequence_NodeLabels(ISerializationContext context, NodeLabels semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NodePattern returns NodePattern
	 *
	 * Constraint:
	 *     (variable=Variable? nodeLabels=NodeLabels? properties=Properties?)
	 */
	protected void sequence_NodePattern(ISerializationContext context, NodePattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns NodePropertyExistenceConstraint
	 *     Command returns NodePropertyExistenceConstraint
	 *     CreateNodePropertyExistenceConstraint returns NodePropertyExistenceConstraint
	 *     NodePropertyExistenceConstraint returns NodePropertyExistenceConstraint
	 *
	 * Constraint:
	 *     (variable=Variable nodeLabel=NodeLabel propertyExpression=PropertyExpression)
	 */
	protected void sequence_NodePropertyExistenceConstraint(ISerializationContext context, NodePropertyExistenceConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.NODE_PROPERTY_EXISTENCE_CONSTRAINT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.NODE_PROPERTY_EXISTENCE_CONSTRAINT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.NODE_PROPERTY_EXISTENCE_CONSTRAINT__NODE_LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.NODE_PROPERTY_EXISTENCE_CONSTRAINT__NODE_LABEL));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.NODE_PROPERTY_EXISTENCE_CONSTRAINT__PROPERTY_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.NODE_PROPERTY_EXISTENCE_CONSTRAINT__PROPERTY_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNodePropertyExistenceConstraintAccess().getVariableVariableParserRuleCall_3_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getNodePropertyExistenceConstraintAccess().getNodeLabelNodeLabelParserRuleCall_4_0(), semanticObject.getNodeLabel());
		feeder.accept(grammarAccess.getNodePropertyExistenceConstraintAccess().getPropertyExpressionPropertyExpressionParserRuleCall_9_0(), semanticObject.getPropertyExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Order returns Order
	 *
	 * Constraint:
	 *     (orderBy+=SortItem orderBy+=SortItem*)
	 */
	protected void sequence_Order(ISerializationContext context, Order semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Properties returns Parameter
	 *     Atom returns Parameter
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (parameter=SYMBOLIC_NAME | parameter=Number)
	 */
	protected void sequence_Parameter(ISerializationContext context, org.slizaa.neo4j.opencypher.openCypher.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RemoveItem returns Parameter
	 *     PropertyExpression returns Parameter
	 *
	 * Constraint:
	 *     ((parameter=SYMBOLIC_NAME | parameter=Number) propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_Parameter_PropertyExpression(ISerializationContext context, org.slizaa.neo4j.opencypher.openCypher.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Atom returns ParenthesizedExpression
	 *     ParenthesizedExpression returns ParenthesizedExpression
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_ParenthesizedExpression(ISerializationContext context, ParenthesizedExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.PARENTHESIZED_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.PARENTHESIZED_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParenthesizedExpressionAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RemoveItem returns ParenthesizedExpression
	 *     PropertyExpression returns ParenthesizedExpression
	 *
	 * Constraint:
	 *     (expression=Expression propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_ParenthesizedExpression_PropertyExpression(ISerializationContext context, ParenthesizedExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PatternElementChain returns PatternElementChain
	 *
	 * Constraint:
	 *     (relationshipPattern=RelationshipPattern nodePattern=NodePattern)
	 */
	protected void sequence_PatternElementChain(ISerializationContext context, PatternElementChain semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.PATTERN_ELEMENT_CHAIN__RELATIONSHIP_PATTERN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.PATTERN_ELEMENT_CHAIN__RELATIONSHIP_PATTERN));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.PATTERN_ELEMENT_CHAIN__NODE_PATTERN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.PATTERN_ELEMENT_CHAIN__NODE_PATTERN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternElementChainAccess().getRelationshipPatternRelationshipPatternParserRuleCall_0_0(), semanticObject.getRelationshipPattern());
		feeder.accept(grammarAccess.getPatternElementChainAccess().getNodePatternNodePatternParserRuleCall_1_0(), semanticObject.getNodePattern());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PatternPart returns PatternElement
	 *     AnonymousPatternPart returns PatternElement
	 *     PatternElement returns PatternElement
	 *
	 * Constraint:
	 *     (nodepattern=NodePattern chain+=PatternElementChain*)
	 */
	protected void sequence_PatternElement(ISerializationContext context, PatternElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PatternPart returns PatternPart
	 *
	 * Constraint:
	 *     (var=Variable part=AnonymousPatternPart)
	 */
	protected void sequence_PatternPart(ISerializationContext context, PatternPart semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.PATTERN_PART__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.PATTERN_PART__VAR));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.PATTERN_PART__PART) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.PATTERN_PART__PART));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternPartAccess().getVarVariableParserRuleCall_0_0_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getPatternPartAccess().getPartAnonymousPatternPartParserRuleCall_0_2_0(), semanticObject.getPart());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns Pattern
	 *
	 * Constraint:
	 *     (patterns+=PatternPart patterns+=PatternPart*)
	 */
	protected void sequence_Pattern(ISerializationContext context, Pattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PeriodicCommitHint returns PeriodicCommitHint
	 *
	 * Constraint:
	 *     numberOfRowsPerCommit=DecimalInteger?
	 */
	protected void sequence_PeriodicCommitHint(ISerializationContext context, PeriodicCommitHint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RemoveItem returns Reduce
	 *     PropertyExpression returns Reduce
	 *
	 * Constraint:
	 *     (accumulator=Variable accumulatorExpression=Expression idInColl=IdInColl expression=Expression propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_PropertyExpression_Reduce(ISerializationContext context, Reduce semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RemoveItem returns RelationshipsPattern
	 *     PropertyExpression returns RelationshipsPattern
	 *
	 * Constraint:
	 *     (nodePattern=NodePattern chain+=PatternElementChain+ propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_PropertyExpression_RelationshipsPattern(ISerializationContext context, RelationshipsPattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RemoveItem returns AllShortestPath
	 *     PropertyExpression returns AllShortestPath
	 *
	 * Constraint:
	 *     (patternElement=PatternElement propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_PropertyExpression_ShortestPathPattern(ISerializationContext context, AllShortestPath semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RemoveItem returns ShortestPath
	 *     PropertyExpression returns ShortestPath
	 *
	 * Constraint:
	 *     (patternElement=PatternElement propertyLookups+=PropertyLookup+)
	 */
	protected void sequence_PropertyExpression_ShortestPathPattern(ISerializationContext context, ShortestPath semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyLookup returns PropertyLookup
	 *
	 * Constraint:
	 *     ((propertyKeyName=PropertyKeyName (propertyOperator='?' | propertyOperator='!')) | propertyKeyName=PropertyKeyName)
	 */
	protected void sequence_PropertyLookup(ISerializationContext context, PropertyLookup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     QueryOptions returns AllOptions
	 *
	 * Constraint:
	 *     (explain?='EXPLAIN' | profile?='PROFILE' | cypherOption+=CypherOption)*
	 */
	protected void sequence_QueryOptions(ISerializationContext context, AllOptions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RangeLiteral returns RangeLiteral
	 *
	 * Constraint:
	 *     (lower=Number? upper=Number?)
	 */
	protected void sequence_RangeLiteral(ISerializationContext context, RangeLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Atom returns Reduce
	 *     Reduce returns Reduce
	 *
	 * Constraint:
	 *     (accumulator=Variable accumulatorExpression=Expression idInColl=IdInColl expression=Expression)
	 */
	protected void sequence_Reduce(ISerializationContext context, Reduce semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.REDUCE__ACCUMULATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.REDUCE__ACCUMULATOR));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.REDUCE__ACCUMULATOR_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.REDUCE__ACCUMULATOR_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.REDUCE__ID_IN_COLL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.REDUCE__ID_IN_COLL));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.REDUCE__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.REDUCE__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReduceAccess().getAccumulatorVariableParserRuleCall_2_0(), semanticObject.getAccumulator());
		feeder.accept(grammarAccess.getReduceAccess().getAccumulatorExpressionExpressionParserRuleCall_4_0(), semanticObject.getAccumulatorExpression());
		feeder.accept(grammarAccess.getReduceAccess().getIdInCollIdInCollParserRuleCall_6_0(), semanticObject.getIdInColl());
		feeder.accept(grammarAccess.getReduceAccess().getExpressionExpressionParserRuleCall_8_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns RegularQuery
	 *     Query returns RegularQuery
	 *     RegularQuery returns RegularQuery
	 *     RegularQuery.RegularQuery_1_0 returns RegularQuery
	 *
	 * Constraint:
	 *     (singleQuery=RegularQuery_RegularQuery_1_0 union+=Union)
	 */
	protected void sequence_RegularQuery(ISerializationContext context, RegularQuery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationshipDetail returns RelationshipDetail
	 *
	 * Constraint:
	 *     (variable=Variable? optional?='?'? types=RelationshipTypes? range=RangeLiteral? properties=Properties?)
	 */
	protected void sequence_RelationshipDetail(ISerializationContext context, RelationshipDetail semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationshipPatternSyntax returns RelationshipPatternSyntax
	 *
	 * Constraint:
	 *     (incoming?=LeftArrowHead? variable=Variable relType=RelType outgoing?=RightArrowHead?)
	 */
	protected void sequence_RelationshipPatternSyntax(ISerializationContext context, RelationshipPatternSyntax semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationshipPattern returns RelationshipPattern
	 *
	 * Constraint:
	 *     (incoming?=LeftArrowHead? detail=RelationshipDetail? outgoing?=RightArrowHead?)
	 */
	protected void sequence_RelationshipPattern(ISerializationContext context, RelationshipPattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns RelationshipPropertyExistenceConstraint
	 *     Command returns RelationshipPropertyExistenceConstraint
	 *     CreateRelationshipPropertyExistenceConstraint returns RelationshipPropertyExistenceConstraint
	 *     RelationshipPropertyExistenceConstraint returns RelationshipPropertyExistenceConstraint
	 *
	 * Constraint:
	 *     (relationshipPattern=RelationshipPatternSyntax propertyExpression=PropertyExpression)
	 */
	protected void sequence_RelationshipPropertyExistenceConstraint(ISerializationContext context, RelationshipPropertyExistenceConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT__RELATIONSHIP_PATTERN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT__RELATIONSHIP_PATTERN));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT__PROPERTY_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT__PROPERTY_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationshipPropertyExistenceConstraintAccess().getRelationshipPatternRelationshipPatternSyntaxParserRuleCall_2_0(), semanticObject.getRelationshipPattern());
		feeder.accept(grammarAccess.getRelationshipPropertyExistenceConstraintAccess().getPropertyExpressionPropertyExpressionParserRuleCall_6_0(), semanticObject.getPropertyExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RelationshipTypes returns RelationshipTypes
	 *
	 * Constraint:
	 *     (relTypeName+=RelTypeName relTypeName+=RelTypeName*)
	 */
	protected void sequence_RelationshipTypes(ISerializationContext context, RelationshipTypes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Atom returns RelationshipsPattern
	 *     RelationshipsPattern returns RelationshipsPattern
	 *
	 * Constraint:
	 *     (nodePattern=NodePattern chain+=PatternElementChain+)
	 */
	protected void sequence_RelationshipsPattern(ISerializationContext context, RelationshipsPattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RemoveItem returns RemoveItem
	 *
	 * Constraint:
	 *     (variable=Variable nodeLabels=NodeLabels)
	 */
	protected void sequence_RemoveItem(ISerializationContext context, RemoveItem semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.REMOVE_ITEM__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.REMOVE_ITEM__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.REMOVE_ITEM__NODE_LABELS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.REMOVE_ITEM__NODE_LABELS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRemoveItemAccess().getVariableVariableParserRuleCall_0_0_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getRemoveItemAccess().getNodeLabelsNodeLabelsParserRuleCall_0_1_0(), semanticObject.getNodeLabels());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns Remove
	 *     Remove returns Remove
	 *
	 * Constraint:
	 *     (removeItems+=RemoveItem removeItems+=RemoveItem*)
	 */
	protected void sequence_Remove(ISerializationContext context, Remove semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReturnBody returns ReturnItems
	 *
	 * Constraint:
	 *     (((all='*' items+=ReturnItem*) | (items+=ReturnItem items+=ReturnItem*)) order=Order? skip=Skip? limit=Limit?)
	 */
	protected void sequence_ReturnBody_ReturnItems(ISerializationContext context, ReturnItems semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReturnItem returns ReturnItem
	 *
	 * Constraint:
	 *     (expression=Expression alias=Variable?)
	 */
	protected void sequence_ReturnItem(ISerializationContext context, ReturnItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReturnItems returns ReturnItems
	 *
	 * Constraint:
	 *     ((all='*' items+=ReturnItem*) | (items+=ReturnItem items+=ReturnItem*))
	 */
	protected void sequence_ReturnItems(ISerializationContext context, ReturnItems semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns Return
	 *     Return returns Return
	 *
	 * Constraint:
	 *     (return='RETURN' distinct?='DISTINCT'? body=ReturnBody)
	 */
	protected void sequence_Return(ISerializationContext context, Return semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SetItem returns SetItem
	 *
	 * Constraint:
	 *     (
	 *         (propertyExpression=PropertyExpression expression=Expression) | 
	 *         (variable=Variable expression=Expression) | 
	 *         (variable=Variable expression=Expression) | 
	 *         (variable=Variable nodeLabels=NodeLabels)
	 *     )
	 */
	protected void sequence_SetItem(ISerializationContext context, SetItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns Set
	 *     Set returns Set
	 *
	 * Constraint:
	 *     (setItems+=SetItem setItems+=SetItem*)
	 */
	protected void sequence_Set(ISerializationContext context, org.slizaa.neo4j.opencypher.openCypher.Set semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PatternPart returns AllShortestPath
	 *     AnonymousPatternPart returns AllShortestPath
	 *     ShortestPathPattern returns AllShortestPath
	 *     Atom returns AllShortestPath
	 *
	 * Constraint:
	 *     patternElement=PatternElement
	 */
	protected void sequence_ShortestPathPattern(ISerializationContext context, AllShortestPath semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.SHORTEST_PATH_PATTERN__PATTERN_ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.SHORTEST_PATH_PATTERN__PATTERN_ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getShortestPathPatternAccess().getPatternElementPatternElementParserRuleCall_1_3_0(), semanticObject.getPatternElement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PatternPart returns ShortestPath
	 *     AnonymousPatternPart returns ShortestPath
	 *     ShortestPathPattern returns ShortestPath
	 *     Atom returns ShortestPath
	 *
	 * Constraint:
	 *     patternElement=PatternElement
	 */
	protected void sequence_ShortestPathPattern(ISerializationContext context, ShortestPath semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.SHORTEST_PATH_PATTERN__PATTERN_ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.SHORTEST_PATH_PATTERN__PATTERN_ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getShortestPathPatternAccess().getPatternElementPatternElementParserRuleCall_0_3_0(), semanticObject.getPatternElement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SingleQuery
	 *     Query returns SingleQuery
	 *     RegularQuery returns SingleQuery
	 *     RegularQuery.RegularQuery_1_0 returns SingleQuery
	 *     SingleQuery returns SingleQuery
	 *
	 * Constraint:
	 *     (clauses+=Clause clauses+=Clause*)
	 */
	protected void sequence_SingleQuery(ISerializationContext context, SingleQuery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Skip returns Skip
	 *
	 * Constraint:
	 *     skip=Expression
	 */
	protected void sequence_Skip(ISerializationContext context, Skip semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.SKIP__SKIP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.SKIP__SKIP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSkipAccess().getSkipExpressionParserRuleCall_1_0(), semanticObject.getSkip());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SortItem returns SortItem
	 *
	 * Constraint:
	 *     (expression=Expression (sort='DESCENDING' | sort='DESC' | sort='ASCENDING' | sort='ASC')?)
	 */
	protected void sequence_SortItem(ISerializationContext context, SortItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StartPoint returns StartPoint
	 *
	 * Constraint:
	 *     (variable=Variable lookup=Lookup)
	 */
	protected void sequence_StartPoint(ISerializationContext context, StartPoint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.START_POINT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.START_POINT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.START_POINT__LOOKUP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.START_POINT__LOOKUP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStartPointAccess().getVariableVariableParserRuleCall_0_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getStartPointAccess().getLookupLookupParserRuleCall_2_0(), semanticObject.getLookup());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns Start
	 *     Start returns Start
	 *
	 * Constraint:
	 *     (startPoint+=StartPoint startPoint+=StartPoint* where=Where?)
	 */
	protected void sequence_Start(ISerializationContext context, Start semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Union returns Union
	 *
	 * Constraint:
	 *     (all?='ALL'? singleQuery=SingleQuery)
	 */
	protected void sequence_Union(ISerializationContext context, Union semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns UniqueConstraint
	 *     Command returns UniqueConstraint
	 *     CreateUniqueConstraint returns UniqueConstraint
	 *     UniqueConstraint returns UniqueConstraint
	 *
	 * Constraint:
	 *     (variable=Variable nodeLabel=NodeLabel propertyExpression=PropertyExpression)
	 */
	protected void sequence_UniqueConstraint(ISerializationContext context, UniqueConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.UNIQUE_CONSTRAINT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.UNIQUE_CONSTRAINT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.UNIQUE_CONSTRAINT__NODE_LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.UNIQUE_CONSTRAINT__NODE_LABEL));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.UNIQUE_CONSTRAINT__PROPERTY_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.UNIQUE_CONSTRAINT__PROPERTY_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUniqueConstraintAccess().getVariableVariableParserRuleCall_3_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getUniqueConstraintAccess().getNodeLabelNodeLabelParserRuleCall_4_0(), semanticObject.getNodeLabel());
		feeder.accept(grammarAccess.getUniqueConstraintAccess().getPropertyExpressionPropertyExpressionParserRuleCall_7_0(), semanticObject.getPropertyExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns Unwind
	 *     Unwind returns Unwind
	 *
	 * Constraint:
	 *     (expression=Expression variable=Variable)
	 */
	protected void sequence_Unwind(ISerializationContext context, Unwind semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.UNWIND__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.UNWIND__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.UNWIND__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.UNWIND__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnwindAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getUnwindAccess().getVariableVariableParserRuleCall_3_0(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     name=SYMBOLIC_NAME_X
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getNameSYMBOLIC_NAME_XParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VersionNumber returns VersionNumber
	 *
	 * Constraint:
	 *     versionNumber=Number
	 */
	protected void sequence_VersionNumber(ISerializationContext context, VersionNumber semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.VERSION_NUMBER__VERSION_NUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.VERSION_NUMBER__VERSION_NUMBER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVersionNumberAccess().getVersionNumberNumberParserRuleCall_0(), semanticObject.getVersionNumber());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Where returns Where
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_Where(ISerializationContext context, Where semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenCypherPackage.Literals.WHERE__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenCypherPackage.Literals.WHERE__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhereAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Clause returns With
	 *     With returns With
	 *
	 * Constraint:
	 *     (distint?='DISTINCT'? returnBody=ReturnBody where=Where?)
	 */
	protected void sequence_With(ISerializationContext context, With semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
